import typing
from typing import Any
from typing import Callable
from typing import Optional
from typing import Tuple
from typing import Type
from typing import Union

from gi.repository import GObject

ANALYZER_ANALYZING: int = 1
ASCII_DTOSTR_BUF_SIZE: int = 39
BIG_ENDIAN: int = 4321
CSET_A_2_Z: str = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
CSET_DIGITS: str = "0123456789"
CSET_a_2_z: str = "abcdefghijklmnopqrstuvwxyz"
DATALIST_FLAGS_MASK: int = 3
DATE_BAD_DAY: int = 0
DATE_BAD_JULIAN: int = 0
DATE_BAD_YEAR: int = 0
DIR_SEPARATOR: int = 47
DIR_SEPARATOR_S: str = "/"
E: float = 2.718282
GINT16_FORMAT: str = "hi"
GINT16_MODIFIER: str = "h"
GINT32_FORMAT: str = "i"
GINT32_MODIFIER: str = ""
GINT64_FORMAT: str = "li"
GINT64_MODIFIER: str = "l"
GINTPTR_FORMAT: str = "li"
GINTPTR_MODIFIER: str = "l"
GNUC_FUNCTION: str = ""
GNUC_PRETTY_FUNCTION: str = ""
GSIZE_FORMAT: str = "lu"
GSIZE_MODIFIER: str = "l"
GSSIZE_FORMAT: str = "li"
GSSIZE_MODIFIER: str = "l"
GUINT16_FORMAT: str = "hu"
GUINT32_FORMAT: str = "u"
GUINT64_FORMAT: str = "lu"
GUINTPTR_FORMAT: str = "lu"
HAVE_GINT64: int = 1
HAVE_GNUC_VARARGS: int = 1
HAVE_GNUC_VISIBILITY: int = 1
HAVE_GROWING_STACK: int = 0
HAVE_ISO_VARARGS: int = 1
HOOK_FLAG_USER_SHIFT: int = 4
IEEE754_DOUBLE_BIAS: int = 1023
IEEE754_FLOAT_BIAS: int = 127
IO_ERR: int = 8
IO_FLAG_APPEND: int = 1
IO_FLAG_GET_MASK: int = 31
IO_FLAG_IS_READABLE: int = 4
IO_FLAG_IS_SEEKABLE: int = 16
IO_FLAG_IS_WRITEABLE: int = 8
IO_FLAG_MASK: int = 31
IO_FLAG_NONBLOCK: int = 2
IO_FLAG_SET_MASK: int = 3
IO_HUP: int = 16
IO_IN: int = 1
IO_NVAL: int = 32
IO_OUT: int = 4
IO_PRI: int = 2
IO_STATUS_AGAIN: int = 3
IO_STATUS_EOF: int = 2
IO_STATUS_ERROR: int = 0
IO_STATUS_NORMAL: int = 1
KEY_FILE_DESKTOP_GROUP: str = "Desktop Entry"
KEY_FILE_DESKTOP_KEY_ACTIONS: str = "Actions"
KEY_FILE_DESKTOP_KEY_CATEGORIES: str = "Categories"
KEY_FILE_DESKTOP_KEY_COMMENT: str = "Comment"
KEY_FILE_DESKTOP_KEY_DBUS_ACTIVATABLE: str = "DBusActivatable"
KEY_FILE_DESKTOP_KEY_EXEC: str = "Exec"
KEY_FILE_DESKTOP_KEY_GENERIC_NAME: str = "GenericName"
KEY_FILE_DESKTOP_KEY_HIDDEN: str = "Hidden"
KEY_FILE_DESKTOP_KEY_ICON: str = "Icon"
KEY_FILE_DESKTOP_KEY_MIME_TYPE: str = "MimeType"
KEY_FILE_DESKTOP_KEY_NAME: str = "Name"
KEY_FILE_DESKTOP_KEY_NOT_SHOW_IN: str = "NotShowIn"
KEY_FILE_DESKTOP_KEY_NO_DISPLAY: str = "NoDisplay"
KEY_FILE_DESKTOP_KEY_ONLY_SHOW_IN: str = "OnlyShowIn"
KEY_FILE_DESKTOP_KEY_PATH: str = "Path"
KEY_FILE_DESKTOP_KEY_STARTUP_NOTIFY: str = "StartupNotify"
KEY_FILE_DESKTOP_KEY_STARTUP_WM_CLASS: str = "StartupWMClass"
KEY_FILE_DESKTOP_KEY_TERMINAL: str = "Terminal"
KEY_FILE_DESKTOP_KEY_TRY_EXEC: str = "TryExec"
KEY_FILE_DESKTOP_KEY_TYPE: str = "Type"
KEY_FILE_DESKTOP_KEY_URL: str = "URL"
KEY_FILE_DESKTOP_KEY_VERSION: str = "Version"
KEY_FILE_DESKTOP_TYPE_APPLICATION: str = "Application"
KEY_FILE_DESKTOP_TYPE_DIRECTORY: str = "Directory"
KEY_FILE_DESKTOP_TYPE_LINK: str = "Link"
LITTLE_ENDIAN: int = 1234
LN10: float = 2.302585
LN2: float = 0.693147
LOG_2_BASE_10: float = 0.30103
LOG_DOMAIN: int = 0
LOG_FATAL_MASK: int = 5
LOG_LEVEL_USER_SHIFT: int = 8
MAJOR_VERSION: int = 2
MAXDOUBLE: float = 1.7976931348623157e308
MAXFLOAT: float = 3.4028234663852886e38
MAXINT: int = 2147483647
MAXINT16: int = 32767
MAXINT32: int = 2147483647
MAXINT64: int = 9223372036854775807
MAXINT8: int = 127
MAXLONG: int = 9223372036854775807
MAXOFFSET: int = 9223372036854775807
MAXSHORT: int = 32767
MAXSIZE: int = 18446744073709551615
MAXSSIZE: int = 9223372036854775807
MAXUINT: int = 4294967295
MAXUINT16: int = 65535
MAXUINT32: int = 4294967295
MAXUINT64: int = 18446744073709551615
MAXUINT8: int = 255
MAXULONG: int = 18446744073709551615
MAXUSHORT: int = 65535
MICRO_VERSION: int = 0
MINDOUBLE: float = 2.2250738585072014e-308
MINFLOAT: float = 1.1754943508222875e-38
MININT: int = -2147483648
MININT16: int = -32768
MININT32: int = -2147483648
MININT64: int = -9223372036854775808
MININT8: int = -128
MINLONG: int = -9223372036854775808
MINOFFSET: int = -9223372036854775808
MINOR_VERSION: int = 74
MINSHORT: int = -32768
MINSSIZE: int = -9223372036854775808
MODULE_SUFFIX: str = "so"
OPTION_ERROR_BAD_VALUE: int = 1
OPTION_ERROR_FAILED: int = 2
OPTION_ERROR_UNKNOWN_OPTION: int = 0
OPTION_FLAG_FILENAME: int = 16
OPTION_FLAG_HIDDEN: int = 1
OPTION_FLAG_IN_MAIN: int = 2
OPTION_FLAG_NOALIAS: int = 64
OPTION_FLAG_NO_ARG: int = 8
OPTION_FLAG_OPTIONAL_ARG: int = 32
OPTION_FLAG_REVERSE: int = 4
OPTION_REMAINING: str = ""
PDP_ENDIAN: int = 3412
PI: float = 3.141593
PID_FORMAT: str = "i"
PI_2: float = 1.570796
PI_4: float = 0.785398
POLLFD_FORMAT: str = "%d"
PRIORITY_DEFAULT: int = 0
PRIORITY_DEFAULT_IDLE: int = 200
PRIORITY_HIGH: int = -100
PRIORITY_HIGH_IDLE: int = 100
PRIORITY_LOW: int = 300
SEARCHPATH_SEPARATOR: int = 58
SEARCHPATH_SEPARATOR_S: str = ":"
SIZEOF_LONG: int = 8
SIZEOF_SIZE_T: int = 8
SIZEOF_SSIZE_T: int = 8
SIZEOF_VOID_P: int = 8
SOURCE_CONTINUE: bool = True
SOURCE_REMOVE: bool = False
SPAWN_CHILD_INHERITS_STDIN: int = 32
SPAWN_DO_NOT_REAP_CHILD: int = 2
SPAWN_FILE_AND_ARGV_ZERO: int = 64
SPAWN_LEAVE_DESCRIPTORS_OPEN: int = 1
SPAWN_SEARCH_PATH: int = 4
SPAWN_STDERR_TO_DEV_NULL: int = 16
SPAWN_STDOUT_TO_DEV_NULL: int = 8
SQRT2: float = 1.414214
STR_DELIMITERS: str = "_-|> <."
SYSDEF_AF_INET: int = 2
SYSDEF_AF_INET6: int = 10
SYSDEF_AF_UNIX: int = 1
SYSDEF_MSG_DONTROUTE: int = 4
SYSDEF_MSG_OOB: int = 1
SYSDEF_MSG_PEEK: int = 2
TEST_OPTION_ISOLATE_DIRS: str = "isolate_dirs"
TIME_SPAN_DAY: int = 86400000000
TIME_SPAN_HOUR: int = 3600000000
TIME_SPAN_MILLISECOND: int = 1000
TIME_SPAN_MINUTE: int = 60000000
TIME_SPAN_SECOND: int = 1000000
UNICHAR_MAX_DECOMPOSITION_LENGTH: int = 18
URI_RESERVED_CHARS_GENERIC_DELIMITERS: str = ":/?#[]@"
URI_RESERVED_CHARS_SUBCOMPONENT_DELIMITERS: str = "!$&'()*+,;="
USEC_PER_SEC: int = 1000000
USER_DIRECTORY_DESKTOP: int = 0
USER_DIRECTORY_DOCUMENTS: int = 1
USER_DIRECTORY_DOWNLOAD: int = 2
USER_DIRECTORY_MUSIC: int = 3
USER_DIRECTORY_PICTURES: int = 4
USER_DIRECTORY_PUBLIC_SHARE: int = 5
USER_DIRECTORY_TEMPLATES: int = 6
USER_DIRECTORY_VIDEOS: int = 7
VA_COPY_AS_ARRAY: int = 1
VERSION_MIN_REQUIRED: int = 2
WIN32_MSG_HANDLE: int = 19981206
_introspection_module = ...  # FIXME Constant
_namespace: str = "GLib"
_overrides_module = ...  # FIXME Constant
_version: str = "2.0"
glib_version = ...  # FIXME Constant
macro__has_attribute___noreturn__: int = 0
option = ...  # FIXME Constant
pyglib_version = ...  # FIXME Constant

def access(filename: str, mode: int) -> int: ...
def aligned_alloc(n_blocks: int, n_block_bytes: int, alignment: int) -> None: ...
def aligned_alloc0(n_blocks: int, n_block_bytes: int, alignment: int) -> None: ...
def aligned_free(mem: None) -> None: ...
def ascii_digit_value(c: int) -> int: ...
def ascii_dtostr(buffer: str, buf_len: int, d: float) -> str: ...
def ascii_formatd(buffer: str, buf_len: int, format: str, d: float) -> str: ...
def ascii_strcasecmp(s1: str, s2: str) -> int: ...
def ascii_strdown(str: str, len: int) -> str: ...
def ascii_string_to_signed(
    str: str, base: int, min: int, max: int
) -> Tuple[bool, int]: ...
def ascii_string_to_unsigned(
    str: str, base: int, min: int, max: int
) -> Tuple[bool, int]: ...
def ascii_strncasecmp(s1: str, s2: str, n: int) -> int: ...
def ascii_strtod(nptr: str) -> Tuple[float, str]: ...
def ascii_strtoll(nptr: str, base: int) -> Tuple[int, str]: ...
def ascii_strtoull(nptr: str, base: int) -> Tuple[int, str]: ...
def ascii_strup(str: str, len: int) -> str: ...
def ascii_tolower(c: int) -> int: ...
def ascii_toupper(c: int) -> int: ...
def ascii_xdigit_value(c: int) -> int: ...
def assert_warning(
    log_domain: str, file: str, line: int, pretty_function: str, expression: str
) -> None: ...
def assertion_message(
    domain: str, file: str, line: int, func: str, message: str
) -> None: ...
def assertion_message_cmpstr(
    domain: str,
    file: str,
    line: int,
    func: str,
    expr: str,
    arg1: str,
    cmp: str,
    arg2: str,
) -> None: ...
def assertion_message_cmpstrv(
    domain: str,
    file: str,
    line: int,
    func: str,
    expr: str,
    arg1: str,
    arg2: str,
    first_wrong_idx: int,
) -> None: ...
def assertion_message_error(
    domain: str,
    file: str,
    line: int,
    func: str,
    expr: str,
    error: Error,
    error_domain: int,
    error_code: int,
) -> None: ...
def atexit(func: Callable[[], None]) -> None: ...
def atomic_int_add(atomic: int, val: int) -> int: ...
def atomic_int_and(atomic: int, val: int) -> int: ...
def atomic_int_compare_and_exchange(atomic: int, oldval: int, newval: int) -> bool: ...
def atomic_int_compare_and_exchange_full(
    atomic: int, oldval: int, newval: int
) -> Tuple[bool, int]: ...
def atomic_int_dec_and_test(atomic: int) -> bool: ...
def atomic_int_exchange(atomic: int, newval: int) -> int: ...
def atomic_int_exchange_and_add(atomic: int, val: int) -> int: ...
def atomic_int_get(atomic: int) -> int: ...
def atomic_int_inc(atomic: int) -> None: ...
def atomic_int_or(atomic: int, val: int) -> int: ...
def atomic_int_set(atomic: int, newval: int) -> None: ...
def atomic_int_xor(atomic: int, val: int) -> int: ...
def atomic_pointer_add(atomic: None, val: int) -> int: ...
def atomic_pointer_and(atomic: None, val: int) -> int: ...
def atomic_pointer_compare_and_exchange(
    atomic: None, oldval: None, newval: None
) -> bool: ...
def atomic_pointer_compare_and_exchange_full(
    atomic: None, oldval: None, newval: None
) -> Tuple[bool, None]: ...
def atomic_pointer_exchange(atomic: None, newval: None) -> None: ...
def atomic_pointer_get(atomic: None) -> None: ...
def atomic_pointer_or(atomic: None, val: int) -> int: ...
def atomic_pointer_set(atomic: None, newval: None) -> None: ...
def atomic_pointer_xor(atomic: None, val: int) -> int: ...
def atomic_rc_box_acquire(mem_block: None) -> None: ...
def atomic_rc_box_alloc(block_size: int) -> None: ...
def atomic_rc_box_alloc0(block_size: int) -> None: ...
def atomic_rc_box_dup(block_size: int, mem_block: None) -> None: ...
def atomic_rc_box_get_size(mem_block: None) -> int: ...
def atomic_rc_box_release(mem_block: None) -> None: ...
def atomic_rc_box_release_full(
    mem_block: None, clear_func: Callable[[None], None]
) -> None: ...
def atomic_ref_count_compare(arc: int, val: int) -> bool: ...
def atomic_ref_count_dec(arc: int) -> bool: ...
def atomic_ref_count_inc(arc: int) -> None: ...
def atomic_ref_count_init(arc: int) -> None: ...
def base64_decode(text: str) -> bytes: ...
def base64_decode_inplace() -> Tuple[int, bytes]: ...
def base64_encode(data: Optional[typing.Sequence[int]] = None) -> str: ...
def base64_encode_close(break_lines: bool) -> Tuple[int, bytes, int, int]: ...
def base64_encode_step(
    in_: typing.Sequence[int], break_lines: bool
) -> Tuple[int, bytes, int, int]: ...
def basename(file_name: str) -> str: ...
def bit_lock(address: int, lock_bit: int) -> None: ...
def bit_nth_lsf(mask: int, nth_bit: int) -> int: ...
def bit_nth_msf(mask: int, nth_bit: int) -> int: ...
def bit_storage(number: int) -> int: ...
def bit_trylock(address: int, lock_bit: int) -> bool: ...
def bit_unlock(address: int, lock_bit: int) -> None: ...
def bookmark_file_error_quark() -> int: ...
def build_filenamev(args: typing.Sequence[str]) -> str: ...
def build_pathv(separator: str, args: typing.Sequence[str]) -> str: ...
def byte_array_free(array: typing.Sequence[int], free_segment: bool) -> int: ...
def byte_array_free_to_bytes(array: typing.Sequence[int]) -> Bytes: ...
def byte_array_new() -> bytes: ...
def byte_array_new_take(data: typing.Sequence[int]) -> bytes: ...
def byte_array_steal(array: typing.Sequence[int]) -> Tuple[int, int]: ...
def byte_array_unref(array: typing.Sequence[int]) -> None: ...
def canonicalize_filename(filename: str, relative_to: Optional[str] = None) -> str: ...
def chdir(path: str) -> int: ...
def check_version(
    required_major: int, required_minor: int, required_micro: int
) -> Optional[str]: ...
def checksum_type_get_length(checksum_type: ChecksumType) -> int: ...
def child_watch_add(*args, **kwargs): ...  # FIXME Function
def child_watch_source_new(pid: int) -> Source: ...
def clear_error() -> None: ...
def close(fd: int) -> bool: ...
def compute_checksum_for_bytes(
    checksum_type: ChecksumType, data: Bytes
) -> Optional[str]: ...
def compute_checksum_for_data(
    checksum_type: ChecksumType, data: typing.Sequence[int]
) -> Optional[str]: ...
def compute_checksum_for_string(
    checksum_type: ChecksumType, str: str, length: int
) -> Optional[str]: ...
def compute_hmac_for_bytes(
    digest_type: ChecksumType, key: Bytes, data: Bytes
) -> str: ...
def compute_hmac_for_data(
    digest_type: ChecksumType, key: typing.Sequence[int], data: typing.Sequence[int]
) -> str: ...
def compute_hmac_for_string(
    digest_type: ChecksumType, key: typing.Sequence[int], str: str, length: int
) -> str: ...
def convert(
    str: typing.Sequence[int], to_codeset: str, from_codeset: str
) -> Tuple[bytes, int]: ...
def convert_error_quark() -> int: ...
def convert_with_fallback(
    str: typing.Sequence[int], to_codeset: str, from_codeset: str, fallback: str
) -> Tuple[bytes, int]: ...
def datalist_foreach(
    datalist: Data, func: Callable[..., None], *user_data: Any
) -> None: ...
def datalist_get_data(datalist: Data, key: str) -> None: ...
def datalist_get_flags(datalist: Data) -> int: ...
def datalist_id_get_data(datalist: Data, key_id: int) -> None: ...
def datalist_id_remove_multiple(datalist: Data, keys: typing.Sequence[int]) -> None: ...
def datalist_set_flags(datalist: Data, flags: int) -> None: ...
def datalist_unset_flags(datalist: Data, flags: int) -> None: ...
def dataset_destroy(dataset_location: None) -> None: ...
def dataset_foreach(
    dataset_location: None, func: Callable[..., None], *user_data: Any
) -> None: ...
def dataset_id_get_data(dataset_location: None, key_id: int) -> None: ...
def date_get_days_in_month(month: DateMonth, year: int) -> int: ...
def date_get_monday_weeks_in_year(year: int) -> int: ...
def date_get_sunday_weeks_in_year(year: int) -> int: ...
def date_is_leap_year(year: int) -> bool: ...
def date_strftime(s: str, slen: int, format: str, date: Date) -> int: ...
def date_valid_day(day: int) -> bool: ...
def date_valid_dmy(day: int, month: DateMonth, year: int) -> bool: ...
def date_valid_julian(julian_date: int) -> bool: ...
def date_valid_month(month: DateMonth) -> bool: ...
def date_valid_weekday(weekday: DateWeekday) -> bool: ...
def date_valid_year(year: int) -> bool: ...
def dcgettext(domain: Optional[str], msgid: str, category: int) -> str: ...
def dgettext(domain: Optional[str], msgid: str) -> str: ...
def dir_make_tmp(tmpl: Optional[str] = None) -> str: ...
def direct_equal(v1: None, v2: None) -> bool: ...
def direct_hash(v: None) -> int: ...
def dngettext(domain: Optional[str], msgid: str, msgid_plural: str, n: int) -> str: ...
def double_equal(v1: None, v2: None) -> bool: ...
def double_hash(v: None) -> int: ...
def dpgettext(domain: Optional[str], msgctxtid: str, msgidoffset: int) -> str: ...
def dpgettext2(domain: Optional[str], context: str, msgid: str) -> str: ...
def environ_getenv(
    envp: Optional[typing.Sequence[str]], variable: str
) -> Optional[str]: ...
def environ_setenv(
    envp: Optional[typing.Sequence[str]], variable: str, value: str, overwrite: bool
) -> list[str]: ...
def environ_unsetenv(
    envp: Optional[typing.Sequence[str]], variable: str
) -> list[str]: ...
def file_error_from_errno(err_no: int) -> FileError: ...
def file_error_quark() -> int: ...
def file_get_contents(filename: str) -> Tuple[bool, bytes]: ...
def file_open_tmp(tmpl: Optional[str] = None) -> Tuple[int, str]: ...
def file_read_link(filename: str) -> str: ...
def file_set_contents(filename: str, contents: typing.Sequence[int]) -> bool: ...
def file_set_contents_full(
    filename: str,
    contents: typing.Sequence[int],
    flags: FileSetContentsFlags,
    mode: int,
) -> bool: ...
def file_test(filename: str, test: FileTest) -> bool: ...
def filename_display_basename(filename: str) -> str: ...
def filename_display_name(filename: str) -> str: ...
def filename_from_uri(uri: str) -> Tuple[str, str]: ...
def filename_from_utf8(*args, **kwargs): ...  # FIXME Function
def filename_to_uri(filename: str, hostname: Optional[str] = None) -> str: ...
def filename_to_utf8(opsysstring: str, len: int) -> Tuple[str, int, int]: ...
def find_program_in_path(program: str) -> Optional[str]: ...
def format_size(size: int) -> str: ...
def format_size_for_display(size: int) -> str: ...
def format_size_full(size: int, flags: FormatSizeFlags) -> str: ...
def free(mem: None) -> None: ...
def get_application_name() -> Optional[str]: ...
def get_charset() -> Tuple[bool, str]: ...
def get_codeset() -> str: ...
def get_console_charset() -> Tuple[bool, str]: ...
def get_current_dir() -> str: ...
def get_current_time(*args, **kwargs): ...  # FIXME Function
def get_environ() -> list[str]: ...
def get_filename_charsets() -> Tuple[bool, list[str]]: ...
def get_home_dir() -> str: ...
def get_host_name() -> str: ...
def get_language_names() -> list[str]: ...
def get_language_names_with_category(category_name: str) -> list[str]: ...
def get_locale_variants(locale: str) -> list[str]: ...
def get_monotonic_time() -> int: ...
def get_num_processors() -> int: ...
def get_os_info(key_name: str) -> Optional[str]: ...
def get_prgname() -> Optional[str]: ...
def get_real_name() -> str: ...
def get_real_time() -> int: ...
def get_system_config_dirs() -> list[str]: ...
def get_system_data_dirs() -> list[str]: ...
def get_tmp_dir() -> str: ...
def get_user_cache_dir() -> str: ...
def get_user_config_dir() -> str: ...
def get_user_data_dir() -> str: ...
def get_user_name() -> str: ...
def get_user_runtime_dir() -> str: ...
def get_user_special_dir(directory: UserDirectory) -> Optional[str]: ...
def get_user_state_dir() -> str: ...
def getenv(variable: str) -> Optional[str]: ...
def hash_table_add(hash_table: str, key: None) -> bool: ...
def hash_table_contains(hash_table: str, key: None) -> bool: ...
def hash_table_destroy(hash_table: str) -> None: ...
def hash_table_insert(hash_table: str, key: None, value: None) -> bool: ...
def hash_table_lookup(hash_table: str, key: None) -> None: ...
def hash_table_lookup_extended(
    hash_table: str, lookup_key: None
) -> Tuple[bool, None, None]: ...
def hash_table_new_similar(other_hash_table: str) -> str: ...
def hash_table_remove(hash_table: str, key: None) -> bool: ...
def hash_table_remove_all(hash_table: str) -> None: ...
def hash_table_replace(hash_table: str, key: None, value: None) -> bool: ...
def hash_table_size(hash_table: str) -> int: ...
def hash_table_steal(hash_table: str, key: None) -> bool: ...
def hash_table_steal_all(hash_table: str) -> None: ...
def hash_table_steal_extended(
    hash_table: str, lookup_key: None
) -> Tuple[bool, None, None]: ...
def hash_table_unref(hash_table: str) -> None: ...
def hook_destroy(hook_list: HookList, hook_id: int) -> bool: ...
def hook_destroy_link(hook_list: HookList, hook: Hook) -> None: ...
def hook_free(hook_list: HookList, hook: Hook) -> None: ...
def hook_insert_before(
    hook_list: HookList, sibling: Optional[Hook], hook: Hook
) -> None: ...
def hook_prepend(hook_list: HookList, hook: Hook) -> None: ...
def hook_unref(hook_list: HookList, hook: Hook) -> None: ...
def hostname_is_ascii_encoded(hostname: str) -> bool: ...
def hostname_is_ip_address(hostname: str) -> bool: ...
def hostname_is_non_ascii(hostname: str) -> bool: ...
def hostname_to_ascii(hostname: str) -> Optional[str]: ...
def hostname_to_unicode(hostname: str) -> Optional[str]: ...

# override
def idle_add(func: Callable[..., Any], *args: Any) -> int: ...
def idle_remove_by_data(data: None) -> bool: ...
def idle_source_new() -> Source: ...
def int64_equal(v1: None, v2: None) -> bool: ...
def int64_hash(v: None) -> int: ...
def int_equal(v1: None, v2: None) -> bool: ...
def int_hash(v: None) -> int: ...
def intern_static_string(string: Optional[str] = None) -> str: ...
def intern_string(string: Optional[str] = None) -> str: ...
def io_add_watch(*args, **kwargs): ...  # FIXME Function
def io_channel_error_from_errno(en: int) -> IOChannelError: ...
def io_channel_error_quark() -> int: ...
def io_create_watch(channel: IOChannel, condition: IOCondition) -> Source: ...
def key_file_error_quark() -> int: ...
def listenv() -> list[str]: ...
def locale_from_utf8(utf8string: str, len: int) -> Tuple[bytes, int]: ...
def locale_to_utf8(opsysstring: typing.Sequence[int]) -> Tuple[str, int, int]: ...
def log_default_handler(
    log_domain: Optional[str],
    log_level: LogLevelFlags,
    message: Optional[str],
    unused_data: None,
) -> None: ...
def log_get_debug_enabled() -> bool: ...
def log_remove_handler(log_domain: str, handler_id: int) -> None: ...
def log_set_always_fatal(fatal_mask: LogLevelFlags) -> LogLevelFlags: ...
def log_set_debug_enabled(enabled: bool) -> None: ...
def log_set_fatal_mask(log_domain: str, fatal_mask: LogLevelFlags) -> LogLevelFlags: ...
def log_set_handler(
    log_domain: Optional[str],
    log_levels: LogLevelFlags,
    log_func: Callable[..., None],
    *user_data: Any,
) -> int: ...
def log_set_writer_func(
    func: Optional[Callable[..., LogWriterOutput]] = None, *user_data: Any
) -> None: ...
def log_structured_array(
    log_level: LogLevelFlags, fields: typing.Sequence[LogField]
) -> None: ...
def log_variant(
    log_domain: Optional[str], log_level: LogLevelFlags, fields: Variant
) -> None: ...
def log_writer_default(
    log_level: LogLevelFlags, fields: typing.Sequence[LogField], user_data: None
) -> LogWriterOutput: ...
def log_writer_default_set_use_stderr(use_stderr: bool) -> None: ...
def log_writer_default_would_drop(
    log_level: LogLevelFlags, log_domain: Optional[str] = None
) -> bool: ...
def log_writer_format_fields(
    log_level: LogLevelFlags, fields: typing.Sequence[LogField], use_color: bool
) -> str: ...
def log_writer_is_journald(output_fd: int) -> bool: ...
def log_writer_journald(
    log_level: LogLevelFlags, fields: typing.Sequence[LogField], user_data: None
) -> LogWriterOutput: ...
def log_writer_standard_streams(
    log_level: LogLevelFlags, fields: typing.Sequence[LogField], user_data: None
) -> LogWriterOutput: ...
def log_writer_supports_color(output_fd: int) -> bool: ...
def main_context_default() -> MainContext: ...
def main_context_get_thread_default() -> Optional[MainContext]: ...
def main_context_ref_thread_default() -> MainContext: ...
def main_current_source() -> Optional[Source]: ...
def main_depth() -> int: ...
def malloc(n_bytes: int) -> None: ...
def malloc0(n_bytes: int) -> None: ...
def malloc0_n(n_blocks: int, n_block_bytes: int) -> None: ...
def malloc_n(n_blocks: int, n_block_bytes: int) -> None: ...
def markup_error_quark() -> int: ...

# override
def markup_escape_text(str: Union[str, bytes], length: int = ...) -> str: ...
def mem_is_system_malloc() -> bool: ...
def mem_profile() -> None: ...
def mem_set_vtable(vtable: MemVTable) -> None: ...
def memdup(mem: None, byte_size: int) -> None: ...
def memdup2(mem: None, byte_size: int) -> None: ...
def mkdir_with_parents(pathname: str, mode: int) -> int: ...
def nullify_pointer(nullify_location: None) -> None: ...
def number_parser_error_quark() -> int: ...
def on_error_query(prg_name: str) -> None: ...
def on_error_stack_trace(prg_name: str) -> None: ...
def once_init_enter(location: None) -> bool: ...
def once_init_leave(location: None, result: int) -> None: ...
def option_error_quark() -> int: ...
def parse_debug_string(
    string: Optional[str], keys: typing.Sequence[DebugKey]
) -> int: ...
def path_get_basename(file_name: str) -> str: ...
def path_get_dirname(file_name: str) -> str: ...
def path_is_absolute(file_name: str) -> bool: ...
def path_skip_root(file_name: str) -> Optional[str]: ...
def pattern_match_simple(pattern: str, string: str) -> bool: ...
def pointer_bit_lock(address: None, lock_bit: int) -> None: ...
def pointer_bit_trylock(address: None, lock_bit: int) -> bool: ...
def pointer_bit_unlock(address: None, lock_bit: int) -> None: ...
def poll(fds: PollFD, nfds: int, timeout: int) -> int: ...
def prefix_error_literal(err: Optional[Error], prefix: str) -> None: ...
def propagate_error(src: Error) -> Error: ...
def quark_from_static_string(string: Optional[str] = None) -> int: ...
def quark_from_string(string: Optional[str] = None) -> int: ...
def quark_to_string(quark: int) -> str: ...
def quark_try_string(string: Optional[str] = None) -> int: ...
def random_double() -> float: ...
def random_double_range(begin: float, end: float) -> float: ...
def random_int() -> int: ...
def random_int_range(begin: int, end: int) -> int: ...
def random_set_seed(seed: int) -> None: ...
def rc_box_acquire(mem_block: None) -> None: ...
def rc_box_alloc(block_size: int) -> None: ...
def rc_box_alloc0(block_size: int) -> None: ...
def rc_box_dup(block_size: int, mem_block: None) -> None: ...
def rc_box_get_size(mem_block: None) -> int: ...
def rc_box_release(mem_block: None) -> None: ...
def rc_box_release_full(
    mem_block: None, clear_func: Callable[[None], None]
) -> None: ...
def realloc(mem: None, n_bytes: int) -> None: ...
def realloc_n(mem: None, n_blocks: int, n_block_bytes: int) -> None: ...
def ref_count_compare(rc: int, val: int) -> bool: ...
def ref_count_dec(rc: int) -> bool: ...
def ref_count_inc(rc: int) -> None: ...
def ref_count_init(rc: int) -> None: ...
def ref_string_acquire(str: str) -> str: ...
def ref_string_length(str: str) -> int: ...
def ref_string_new(str: str) -> str: ...
def ref_string_new_intern(str: str) -> str: ...
def ref_string_new_len(str: str, len: int) -> str: ...
def ref_string_release(str: str) -> None: ...
def regex_check_replacement(replacement: str) -> Tuple[bool, bool]: ...
def regex_error_quark() -> int: ...
def regex_escape_nul(string: str, length: int) -> str: ...
def regex_escape_string(string: typing.Sequence[str]) -> str: ...
def regex_match_simple(
    pattern: str,
    string: str,
    compile_options: RegexCompileFlags,
    match_options: RegexMatchFlags,
) -> bool: ...
def regex_split_simple(
    pattern: str,
    string: str,
    compile_options: RegexCompileFlags,
    match_options: RegexMatchFlags,
) -> list[str]: ...
def reload_user_special_dirs_cache() -> None: ...
def rmdir(filename: str) -> int: ...
def sequence_get(iter: SequenceIter) -> None: ...
def sequence_insert_before(iter: SequenceIter, data: None) -> SequenceIter: ...
def sequence_move(src: SequenceIter, dest: SequenceIter) -> None: ...
def sequence_move_range(
    dest: SequenceIter, begin: SequenceIter, end: SequenceIter
) -> None: ...
def sequence_range_get_midpoint(
    begin: SequenceIter, end: SequenceIter
) -> SequenceIter: ...
def sequence_remove(iter: SequenceIter) -> None: ...
def sequence_remove_range(begin: SequenceIter, end: SequenceIter) -> None: ...
def sequence_set(iter: SequenceIter, data: None) -> None: ...
def sequence_swap(a: SequenceIter, b: SequenceIter) -> None: ...
def set_application_name(application_name: str) -> None: ...
def set_error_literal(domain: int, code: int, message: str) -> Error: ...
def set_prgname(prgname: str) -> None: ...
def setenv(variable: str, value: str, overwrite: bool) -> bool: ...
def shell_error_quark() -> int: ...
def shell_parse_argv(command_line: str) -> Tuple[bool, int, list[str]]: ...
def shell_quote(unquoted_string: str) -> str: ...
def shell_unquote(quoted_string: str) -> str: ...
def slice_alloc(block_size: int) -> None: ...
def slice_alloc0(block_size: int) -> None: ...
def slice_copy(block_size: int, mem_block: None) -> None: ...
def slice_free1(block_size: int, mem_block: None) -> None: ...
def slice_free_chain_with_offset(
    block_size: int, mem_chain: None, next_offset: int
) -> None: ...
def slice_get_config(ckey: SliceConfig) -> int: ...
def slice_get_config_state(ckey: SliceConfig, address: int, n_values: int) -> int: ...
def slice_set_config(ckey: SliceConfig, value: int) -> None: ...
def source_remove(tag: int) -> bool: ...
def source_remove_by_funcs_user_data(funcs: SourceFuncs, user_data: None) -> bool: ...
def source_remove_by_user_data(user_data: None) -> bool: ...
def source_set_name_by_id(tag: int, name: str) -> None: ...
def spaced_primes_closest(num: int) -> int: ...
def spawn_async(*args, **kwargs): ...  # FIXME Function
def spawn_async_with_fds(
    working_directory: Optional[str],
    argv: typing.Sequence[str],
    envp: Optional[typing.Sequence[str]],
    flags: SpawnFlags,
    child_setup: Optional[Callable[..., None]],
    stdin_fd: int,
    stdout_fd: int,
    stderr_fd: int,
    *user_data: Any,
) -> Tuple[bool, int]: ...
def spawn_async_with_pipes(
    working_directory: Optional[str],
    argv: typing.Sequence[str],
    envp: Optional[typing.Sequence[str]],
    flags: SpawnFlags,
    child_setup: Optional[Callable[..., None]] = None,
    *user_data: Any,
) -> Tuple[bool, int, int, int, int]: ...
def spawn_async_with_pipes_and_fds(
    working_directory: Optional[str],
    argv: typing.Sequence[str],
    envp: Optional[typing.Sequence[str]],
    flags: SpawnFlags,
    child_setup: Optional[Callable[..., None]],
    stdin_fd: int,
    stdout_fd: int,
    stderr_fd: int,
    source_fds: Optional[typing.Sequence[int]] = None,
    target_fds: Optional[typing.Sequence[int]] = None,
    *user_data: Any,
) -> Tuple[bool, int, int, int, int]: ...
def spawn_check_exit_status(wait_status: int) -> bool: ...
def spawn_check_wait_status(wait_status: int) -> bool: ...
def spawn_close_pid(pid: int) -> None: ...
def spawn_command_line_async(command_line: str) -> bool: ...
def spawn_command_line_sync(command_line: str) -> Tuple[bool, bytes, bytes, int]: ...
def spawn_error_quark() -> int: ...
def spawn_exit_error_quark() -> int: ...
def spawn_sync(
    working_directory: Optional[str],
    argv: typing.Sequence[str],
    envp: Optional[typing.Sequence[str]],
    flags: SpawnFlags,
    child_setup: Optional[Callable[..., None]] = None,
    *user_data: Any,
) -> Tuple[bool, bytes, bytes, int]: ...
def stpcpy(dest: str, src: str) -> str: ...
def str_equal(v1: None, v2: None) -> bool: ...
def str_has_prefix(str: str, prefix: str) -> bool: ...
def str_has_suffix(str: str, suffix: str) -> bool: ...
def str_hash(v: None) -> int: ...
def str_is_ascii(str: str) -> bool: ...
def str_match_string(
    search_term: str, potential_hit: str, accept_alternates: bool
) -> bool: ...
def str_to_ascii(str: str, from_locale: Optional[str] = None) -> str: ...
def str_tokenize_and_fold(
    string: str, translit_locale: Optional[str] = None
) -> Tuple[list[str], list[str]]: ...
def strcanon(string: str, valid_chars: str, substitutor: int) -> str: ...
def strcasecmp(s1: str, s2: str) -> int: ...
def strchomp(string: str) -> str: ...
def strchug(string: str) -> str: ...
def strcmp0(str1: Optional[str] = None, str2: Optional[str] = None) -> int: ...
def strcompress(source: str) -> str: ...
def strdelimit(string: str, delimiters: Optional[str], new_delimiter: int) -> str: ...
def strdown(string: str) -> str: ...
def strdup(str: Optional[str] = None) -> str: ...
def strerror(errnum: int) -> str: ...
def strescape(source: str, exceptions: Optional[str] = None) -> str: ...
def strfreev(str_array: Optional[str] = None) -> None: ...
def strip_context(msgid: str, msgval: str) -> str: ...
def strjoinv(separator: Optional[str], str_array: str) -> str: ...
def strlcat(dest: str, src: str, dest_size: int) -> int: ...
def strlcpy(dest: str, src: str, dest_size: int) -> int: ...
def strncasecmp(s1: str, s2: str, n: int) -> int: ...
def strndup(str: str, n: int) -> str: ...
def strnfill(length: int, fill_char: int) -> str: ...
def strreverse(string: str) -> str: ...
def strrstr(haystack: str, needle: str) -> str: ...
def strrstr_len(haystack: str, haystack_len: int, needle: str) -> str: ...
def strsignal(signum: int) -> str: ...
def strstr_len(haystack: str, haystack_len: int, needle: str) -> str: ...
def strtod(nptr: str) -> Tuple[float, str]: ...
def strup(string: str) -> str: ...
def strv_contains(strv: str, str: str) -> bool: ...
def strv_equal(strv1: str, strv2: str) -> bool: ...
def strv_get_type() -> Type: ...
def strv_length(str_array: str) -> int: ...
def test_add_data_func(
    testpath: str, test_data: None, test_func: Callable[..., None]
) -> None: ...
def test_add_data_func_full(
    testpath: str,
    test_data: None,
    test_func: Callable[..., None],
    data_free_func: Callable[[None], None],
) -> None: ...
def test_add_func(testpath: str, test_func: Callable[[], None]) -> None: ...
def test_assert_expected_messages_internal(
    domain: str, file: str, line: int, func: str
) -> None: ...
def test_bug(bug_uri_snippet: str) -> None: ...
def test_bug_base(uri_pattern: str) -> None: ...
def test_expect_message(
    log_domain: Optional[str], log_level: LogLevelFlags, pattern: str
) -> None: ...
def test_fail() -> None: ...
def test_failed() -> bool: ...
def test_get_dir(file_type: TestFileType) -> str: ...
def test_get_path() -> str: ...
def test_incomplete(msg: Optional[str] = None) -> None: ...
def test_log_type_name(log_type: TestLogType) -> str: ...
def test_queue_destroy(
    destroy_func: Callable[[None], None], destroy_data: None
) -> None: ...
def test_queue_free(gfree_pointer: None) -> None: ...
def test_rand_double() -> float: ...
def test_rand_double_range(range_start: float, range_end: float) -> float: ...
def test_rand_int() -> int: ...
def test_rand_int_range(begin: int, end: int) -> int: ...
def test_run() -> int: ...
def test_run_suite(suite: TestSuite) -> int: ...
def test_set_nonfatal_assertions() -> None: ...
def test_skip(msg: Optional[str] = None) -> None: ...
def test_subprocess() -> bool: ...
def test_summary(summary: str) -> None: ...
def test_timer_elapsed() -> float: ...
def test_timer_last() -> float: ...
def test_timer_start() -> None: ...
def test_trap_assertions(
    domain: str, file: str, line: int, func: str, assertion_flags: int, pattern: str
) -> None: ...
def test_trap_fork(usec_timeout: int, test_trap_flags: TestTrapFlags) -> bool: ...
def test_trap_has_passed() -> bool: ...
def test_trap_reached_timeout() -> bool: ...
def test_trap_subprocess(
    test_path: Optional[str], usec_timeout: int, test_flags: TestSubprocessFlags
) -> None: ...
def thread_error_quark() -> int: ...
def thread_exit(retval: None) -> None: ...
def thread_pool_get_max_idle_time() -> int: ...
def thread_pool_get_max_unused_threads() -> int: ...
def thread_pool_get_num_unused_threads() -> int: ...
def thread_pool_set_max_idle_time(interval: int) -> None: ...
def thread_pool_set_max_unused_threads(max_threads: int) -> None: ...
def thread_pool_stop_unused_threads() -> None: ...
def thread_self() -> Thread: ...
def thread_yield() -> None: ...
def threads_init(*args, **kwargs): ...  # FIXME Function
def time_val_from_iso8601(iso_date: str) -> Tuple[bool, TimeVal]: ...

# override
def timeout_add(interval: int, function: Callable[..., Any], *args: Any) -> int: ...

# override
def timeout_add_seconds(
    interval: int, function: Callable[..., Any], *args: Any
) -> int: ...
def timeout_source_new(interval: int) -> Source: ...
def timeout_source_new_seconds(interval: int) -> Source: ...
def trash_stack_height(stack_p: TrashStack) -> int: ...
def trash_stack_peek(stack_p: TrashStack) -> None: ...
def trash_stack_pop(stack_p: TrashStack) -> None: ...
def trash_stack_push(stack_p: TrashStack, data_p: None) -> None: ...
def try_malloc(n_bytes: int) -> None: ...
def try_malloc0(n_bytes: int) -> None: ...
def try_malloc0_n(n_blocks: int, n_block_bytes: int) -> None: ...
def try_malloc_n(n_blocks: int, n_block_bytes: int) -> None: ...
def try_realloc(mem: None, n_bytes: int) -> None: ...
def try_realloc_n(mem: None, n_blocks: int, n_block_bytes: int) -> None: ...
def ucs4_to_utf16(str: str, len: int) -> Tuple[int, int, int]: ...
def ucs4_to_utf8(str: str, len: int) -> Tuple[str, int, int]: ...
def unichar_break_type(c: str) -> UnicodeBreakType: ...
def unichar_combining_class(uc: str) -> int: ...
def unichar_compose(a: str, b: str) -> Tuple[bool, str]: ...
def unichar_decompose(ch: str) -> Tuple[bool, str, str]: ...
def unichar_digit_value(c: str) -> int: ...
def unichar_fully_decompose(
    ch: str, compat: bool, result_len: int
) -> Tuple[int, str]: ...
def unichar_get_mirror_char(ch: str, mirrored_ch: str) -> bool: ...
def unichar_get_script(ch: str) -> UnicodeScript: ...
def unichar_isalnum(c: str) -> bool: ...
def unichar_isalpha(c: str) -> bool: ...
def unichar_iscntrl(c: str) -> bool: ...
def unichar_isdefined(c: str) -> bool: ...
def unichar_isdigit(c: str) -> bool: ...
def unichar_isgraph(c: str) -> bool: ...
def unichar_islower(c: str) -> bool: ...
def unichar_ismark(c: str) -> bool: ...
def unichar_isprint(c: str) -> bool: ...
def unichar_ispunct(c: str) -> bool: ...
def unichar_isspace(c: str) -> bool: ...
def unichar_istitle(c: str) -> bool: ...
def unichar_isupper(c: str) -> bool: ...
def unichar_iswide(c: str) -> bool: ...
def unichar_iswide_cjk(c: str) -> bool: ...
def unichar_isxdigit(c: str) -> bool: ...
def unichar_iszerowidth(c: str) -> bool: ...
def unichar_to_utf8(c: str) -> Tuple[int, str]: ...
def unichar_tolower(c: str) -> str: ...
def unichar_totitle(c: str) -> str: ...
def unichar_toupper(c: str) -> str: ...
def unichar_type(c: str) -> UnicodeType: ...
def unichar_validate(ch: str) -> bool: ...
def unichar_xdigit_value(c: str) -> int: ...
def unicode_canonical_decomposition(ch: str, result_len: int) -> str: ...
def unicode_canonical_ordering(string: str, len: int) -> None: ...
def unicode_script_from_iso15924(iso15924: int) -> UnicodeScript: ...
def unicode_script_to_iso15924(script: UnicodeScript) -> int: ...
def unix_error_quark() -> int: ...
def unix_fd_add_full(
    priority: int,
    fd: int,
    condition: IOCondition,
    function: Callable[..., bool],
    *user_data: Any,
) -> int: ...
def unix_fd_source_new(fd: int, condition: IOCondition) -> Source: ...
def unix_get_passwd_entry(user_name: str) -> None: ...
def unix_open_pipe(fds: typing.Sequence[int], flags: int) -> bool: ...
def unix_set_fd_nonblocking(fd: int, nonblock: bool) -> bool: ...
def unix_signal_add(
    priority: int, signum: int, handler: Callable[..., bool], *user_data: Any
) -> int: ...
def unix_signal_add_full(
    priority: int, signum: int, handler: Callable[..., bool], *user_data: Any
) -> int: ...
def unix_signal_source_new(signum: int) -> Source: ...
def unlink(filename: str) -> int: ...
def unsetenv(variable: str) -> None: ...
def uri_build(
    flags: UriFlags,
    scheme: str,
    userinfo: Optional[str],
    host: Optional[str],
    port: int,
    path: str,
    query: Optional[str] = None,
    fragment: Optional[str] = None,
) -> Uri: ...
def uri_build_with_user(
    flags: UriFlags,
    scheme: str,
    user: Optional[str],
    password: Optional[str],
    auth_params: Optional[str],
    host: Optional[str],
    port: int,
    path: str,
    query: Optional[str] = None,
    fragment: Optional[str] = None,
) -> Uri: ...
def uri_error_quark() -> int: ...
def uri_escape_bytes(
    unescaped: typing.Sequence[int], reserved_chars_allowed: Optional[str] = None
) -> str: ...
def uri_escape_string(
    unescaped: str, reserved_chars_allowed: Optional[str], allow_utf8: bool
) -> str: ...
def uri_is_valid(uri_string: str, flags: UriFlags) -> bool: ...
def uri_join(
    flags: UriFlags,
    scheme: Optional[str],
    userinfo: Optional[str],
    host: Optional[str],
    port: int,
    path: str,
    query: Optional[str] = None,
    fragment: Optional[str] = None,
) -> str: ...
def uri_join_with_user(
    flags: UriFlags,
    scheme: Optional[str],
    user: Optional[str],
    password: Optional[str],
    auth_params: Optional[str],
    host: Optional[str],
    port: int,
    path: str,
    query: Optional[str] = None,
    fragment: Optional[str] = None,
) -> str: ...
def uri_list_extract_uris(uri_list: str) -> list[str]: ...
def uri_parse(uri_string: str, flags: UriFlags) -> Uri: ...
def uri_parse_params(
    params: str, length: int, separators: str, flags: UriParamsFlags
) -> str: ...
def uri_parse_scheme(uri: str) -> Optional[str]: ...
def uri_peek_scheme(uri: str) -> Optional[str]: ...
def uri_resolve_relative(
    base_uri_string: Optional[str], uri_ref: str, flags: UriFlags
) -> str: ...
def uri_split(
    uri_ref: str, flags: UriFlags
) -> Tuple[bool, str, str, str, int, str, str, str]: ...
def uri_split_network(
    uri_string: str, flags: UriFlags
) -> Tuple[bool, str, str, int]: ...
def uri_split_with_user(
    uri_ref: str, flags: UriFlags
) -> Tuple[bool, str, str, str, str, str, int, str, str, str]: ...
def uri_unescape_bytes(
    escaped_string: str, length: int, illegal_characters: Optional[str] = None
) -> Bytes: ...
def uri_unescape_segment(
    escaped_string: Optional[str] = None,
    escaped_string_end: Optional[str] = None,
    illegal_characters: Optional[str] = None,
) -> Optional[str]: ...
def uri_unescape_string(
    escaped_string: str, illegal_characters: Optional[str] = None
) -> Optional[str]: ...
def usleep(microseconds: int) -> None: ...
def utf16_to_ucs4(str: int, len: int) -> Tuple[str, int, int]: ...
def utf16_to_utf8(str: int, len: int) -> Tuple[str, int, int]: ...
def utf8_casefold(str: str, len: int) -> str: ...
def utf8_collate(str1: str, str2: str) -> int: ...
def utf8_collate_key(str: str, len: int) -> str: ...
def utf8_collate_key_for_filename(str: str, len: int) -> str: ...
def utf8_find_next_char(p: str, end: Optional[str] = None) -> Optional[str]: ...
def utf8_find_prev_char(str: str, p: str) -> Optional[str]: ...
def utf8_get_char(p: str) -> str: ...
def utf8_get_char_validated(p: str, max_len: int) -> str: ...
def utf8_make_valid(str: str, len: int) -> str: ...
def utf8_normalize(str: str, len: int, mode: NormalizeMode) -> Optional[str]: ...
def utf8_offset_to_pointer(str: str, offset: int) -> str: ...
def utf8_pointer_to_offset(str: str, pos: str) -> int: ...
def utf8_prev_char(p: str) -> str: ...
def utf8_strchr(p: str, len: int, c: str) -> Optional[str]: ...
def utf8_strdown(str: str, len: int) -> str: ...
def utf8_strlen(p: str, max: int) -> int: ...
def utf8_strncpy(dest: str, src: str, n: int) -> str: ...
def utf8_strrchr(p: str, len: int, c: str) -> Optional[str]: ...
def utf8_strreverse(str: str, len: int) -> str: ...
def utf8_strup(str: str, len: int) -> str: ...
def utf8_substring(str: str, start_pos: int, end_pos: int) -> str: ...
def utf8_to_ucs4(str: str, len: int) -> Tuple[str, int, int]: ...
def utf8_to_ucs4_fast(str: str, len: int) -> Tuple[str, int]: ...
def utf8_to_utf16(str: str, len: int) -> Tuple[int, int, int]: ...
def utf8_validate(str: typing.Sequence[int]) -> Tuple[bool, str]: ...
def utf8_validate_len(str: typing.Sequence[int]) -> Tuple[bool, str]: ...
def uuid_string_is_valid(str: str) -> bool: ...
def uuid_string_random() -> str: ...
def variant_get_gtype() -> Type: ...
def variant_is_object_path(string: str) -> bool: ...
def variant_is_signature(string: str) -> bool: ...
def variant_parse(
    type: Optional[VariantType],
    text: str,
    limit: Optional[str] = None,
    endptr: Optional[str] = None,
) -> Variant: ...
def variant_parse_error_print_context(error: Error, source_str: str) -> str: ...
def variant_parse_error_quark() -> int: ...
def variant_parser_get_error_quark() -> int: ...
def variant_type_checked_(arg0: str) -> VariantType: ...
def variant_type_string_get_depth_(type_string: str) -> int: ...
def variant_type_string_is_valid(type_string: str) -> bool: ...
def variant_type_string_scan(
    string: str, limit: Optional[str] = None
) -> Tuple[bool, str]: ...

class Array(GObject.GBoxed):
    data: str = ...
    len: int = ...

class AsyncQueue(GObject.GPointer):
    def length(self) -> int: ...
    def length_unlocked(self) -> int: ...
    def lock(self) -> None: ...
    def pop(self) -> None: ...
    def pop_unlocked(self) -> None: ...
    def push(self, data: None) -> None: ...
    def push_front(self, item: None) -> None: ...
    def push_front_unlocked(self, item: None) -> None: ...
    def push_unlocked(self, data: None) -> None: ...
    def ref_unlocked(self) -> None: ...
    def remove(self, item: None) -> bool: ...
    def remove_unlocked(self, item: None) -> bool: ...
    def timed_pop(self, end_time: TimeVal) -> None: ...
    def timed_pop_unlocked(self, end_time: TimeVal) -> None: ...
    def timeout_pop(self, timeout: int) -> None: ...
    def timeout_pop_unlocked(self, timeout: int) -> None: ...
    def try_pop(self) -> None: ...
    def try_pop_unlocked(self) -> None: ...
    def unlock(self) -> None: ...
    def unref(self) -> None: ...
    def unref_and_unlock(self) -> None: ...

class BookmarkFile(GObject.GPointer):
    def add_application(
        self, uri: str, name: Optional[str] = None, exec: Optional[str] = None
    ) -> None: ...
    def add_group(self, uri: str, group: str) -> None: ...
    @staticmethod
    def error_quark() -> int: ...
    def free(self) -> None: ...
    def get_added(self, uri: str) -> int: ...
    def get_added_date_time(self, uri: str) -> DateTime: ...
    def get_app_info(self, uri: str, name: str) -> Tuple[bool, str, int, int]: ...
    def get_application_info(
        self, uri: str, name: str
    ) -> Tuple[bool, str, int, DateTime]: ...
    def get_applications(self, uri: str) -> list[str]: ...
    def get_description(self, uri: str) -> str: ...
    def get_groups(self, uri: str) -> list[str]: ...
    def get_icon(self, uri: str) -> Tuple[bool, str, str]: ...
    def get_is_private(self, uri: str) -> bool: ...
    def get_mime_type(self, uri: str) -> str: ...
    def get_modified(self, uri: str) -> int: ...
    def get_modified_date_time(self, uri: str) -> DateTime: ...
    def get_size(self) -> int: ...
    def get_title(self, uri: Optional[str] = None) -> str: ...
    def get_uris(self) -> list[str]: ...
    def get_visited(self, uri: str) -> int: ...
    def get_visited_date_time(self, uri: str) -> DateTime: ...
    def has_application(self, uri: str, name: str) -> bool: ...
    def has_group(self, uri: str, group: str) -> bool: ...
    def has_item(self, uri: str) -> bool: ...
    def load_from_data(self, data: typing.Sequence[int]) -> bool: ...
    def load_from_data_dirs(self, file: str) -> Tuple[bool, str]: ...
    def load_from_file(self, filename: str) -> bool: ...
    def move_item(self, old_uri: str, new_uri: Optional[str] = None) -> bool: ...
    def remove_application(self, uri: str, name: str) -> bool: ...
    def remove_group(self, uri: str, group: str) -> bool: ...
    def remove_item(self, uri: str) -> bool: ...
    def set_added(self, uri: str, added: int) -> None: ...
    def set_added_date_time(self, uri: str, added: DateTime) -> None: ...
    def set_app_info(
        self, uri: str, name: str, exec: str, count: int, stamp: int
    ) -> bool: ...
    def set_application_info(
        self,
        uri: str,
        name: str,
        exec: str,
        count: int,
        stamp: Optional[DateTime] = None,
    ) -> bool: ...
    def set_description(self, uri: Optional[str], description: str) -> None: ...
    def set_groups(
        self, uri: str, groups: Optional[typing.Sequence[str]] = None
    ) -> None: ...
    def set_icon(self, uri: str, href: Optional[str], mime_type: str) -> None: ...
    def set_is_private(self, uri: str, is_private: bool) -> None: ...
    def set_mime_type(self, uri: str, mime_type: str) -> None: ...
    def set_modified(self, uri: str, modified: int) -> None: ...
    def set_modified_date_time(self, uri: str, modified: DateTime) -> None: ...
    def set_title(self, uri: Optional[str], title: str) -> None: ...
    def set_visited(self, uri: str, visited: int) -> None: ...
    def set_visited_date_time(self, uri: str, visited: DateTime) -> None: ...
    def to_data(self) -> bytes: ...
    def to_file(self, filename: str) -> bool: ...

class ByteArray(GObject.GBoxed):
    data: int = ...
    len: int = ...
    @staticmethod
    def free(array: typing.Sequence[int], free_segment: bool) -> int: ...
    @staticmethod
    def free_to_bytes(array: typing.Sequence[int]) -> Bytes: ...
    @staticmethod
    def new() -> bytes: ...
    @staticmethod
    def new_take(data: typing.Sequence[int]) -> bytes: ...
    @staticmethod
    def steal(array: typing.Sequence[int]) -> Tuple[int, int]: ...
    @staticmethod
    def unref(array: typing.Sequence[int]) -> None: ...

class Bytes(GObject.GBoxed):
    def compare(self, bytes2: Bytes) -> int: ...
    def equal(self, bytes2: Bytes) -> bool: ...
    def get_data(self) -> Optional[bytes]: ...
    def get_region(self, element_size: int, offset: int, n_elements: int) -> None: ...
    def get_size(self) -> int: ...
    def hash(self) -> int: ...
    @classmethod
    def new(cls, data: Optional[typing.Sequence[int]] = None) -> Bytes: ...
    def new_from_bytes(self, offset: int, length: int) -> Bytes: ...
    @classmethod
    def new_take(cls, data: Optional[typing.Sequence[int]] = None) -> Bytes: ...
    def ref(self) -> Bytes: ...
    def unref(self) -> None: ...
    def unref_to_array(self) -> bytes: ...
    def unref_to_data(self) -> bytes: ...

class Checksum(GObject.GBoxed):
    def copy(self) -> Checksum: ...
    def free(self) -> None: ...
    def get_string(self) -> str: ...
    @classmethod
    def new(cls, checksum_type: ChecksumType) -> Optional[Checksum]: ...
    def reset(self) -> None: ...
    @staticmethod
    def type_get_length(checksum_type: ChecksumType) -> int: ...
    def update(self, data: typing.Sequence[int]) -> None: ...

class Cond(GObject.GPointer):
    p: None = ...
    i: list[int] = ...
    def broadcast(self) -> None: ...
    def clear(self) -> None: ...
    def init(self) -> None: ...
    def signal(self) -> None: ...
    def wait(self, mutex: Mutex) -> None: ...
    def wait_until(self, mutex: Mutex, end_time: int) -> bool: ...

class Data(GObject.GPointer): ...

class Date(GObject.GBoxed):
    julian_days: int = ...
    julian: int = ...
    dmy: int = ...
    day: int = ...
    month: int = ...
    year: int = ...
    def add_days(self, n_days: int) -> None: ...
    def add_months(self, n_months: int) -> None: ...
    def add_years(self, n_years: int) -> None: ...
    def clamp(self, min_date: Date, max_date: Date) -> None: ...
    def clear(self, n_dates: int) -> None: ...
    def compare(self, rhs: Date) -> int: ...
    def copy(self) -> Date: ...
    def days_between(self, date2: Date) -> int: ...
    def free(self) -> None: ...
    def get_day(self) -> int: ...
    def get_day_of_year(self) -> int: ...
    @staticmethod
    def get_days_in_month(month: DateMonth, year: int) -> int: ...
    def get_iso8601_week_of_year(self) -> int: ...
    def get_julian(self) -> int: ...
    def get_monday_week_of_year(self) -> int: ...
    @staticmethod
    def get_monday_weeks_in_year(year: int) -> int: ...
    def get_month(self) -> DateMonth: ...
    def get_sunday_week_of_year(self) -> int: ...
    @staticmethod
    def get_sunday_weeks_in_year(year: int) -> int: ...
    def get_weekday(self) -> DateWeekday: ...
    def get_year(self) -> int: ...
    def is_first_of_month(self) -> bool: ...
    def is_last_of_month(self) -> bool: ...
    @staticmethod
    def is_leap_year(year: int) -> bool: ...
    @classmethod
    def new(cls) -> Date: ...
    @classmethod
    def new_dmy(cls, day: int, month: DateMonth, year: int) -> Date: ...
    @classmethod
    def new_julian(cls, julian_day: int) -> Date: ...
    def order(self, date2: Date) -> None: ...
    def set_day(self, day: int) -> None: ...
    def set_dmy(self, day: int, month: DateMonth, y: int) -> None: ...
    def set_julian(self, julian_date: int) -> None: ...
    def set_month(self, month: DateMonth) -> None: ...
    def set_parse(self, str: str) -> None: ...
    def set_time(self, time_: int) -> None: ...
    def set_time_t(self, timet: int) -> None: ...
    def set_time_val(self, timeval: TimeVal) -> None: ...
    def set_year(self, year: int) -> None: ...
    @staticmethod
    def strftime(s: str, slen: int, format: str, date: Date) -> int: ...
    def subtract_days(self, n_days: int) -> None: ...
    def subtract_months(self, n_months: int) -> None: ...
    def subtract_years(self, n_years: int) -> None: ...
    def to_struct_tm(self, tm: None) -> None: ...
    def valid(self) -> bool: ...
    @staticmethod
    def valid_day(day: int) -> bool: ...
    @staticmethod
    def valid_dmy(day: int, month: DateMonth, year: int) -> bool: ...
    @staticmethod
    def valid_julian(julian_date: int) -> bool: ...
    @staticmethod
    def valid_month(month: DateMonth) -> bool: ...
    @staticmethod
    def valid_weekday(weekday: DateWeekday) -> bool: ...
    @staticmethod
    def valid_year(year: int) -> bool: ...

class DateTime(GObject.GBoxed):
    def add(self, timespan: int) -> Optional[DateTime]: ...
    def add_days(self, days: int) -> Optional[DateTime]: ...
    def add_full(
        self,
        years: int,
        months: int,
        days: int,
        hours: int,
        minutes: int,
        seconds: float,
    ) -> Optional[DateTime]: ...
    def add_hours(self, hours: int) -> Optional[DateTime]: ...
    def add_minutes(self, minutes: int) -> Optional[DateTime]: ...
    def add_months(self, months: int) -> Optional[DateTime]: ...
    def add_seconds(self, seconds: float) -> Optional[DateTime]: ...
    def add_weeks(self, weeks: int) -> Optional[DateTime]: ...
    def add_years(self, years: int) -> Optional[DateTime]: ...
    def compare(self, dt2: DateTime) -> int: ...
    def difference(self, begin: DateTime) -> int: ...
    def equal(self, dt2: DateTime) -> bool: ...
    def format(self, format: str) -> Optional[str]: ...
    def format_iso8601(self) -> Optional[str]: ...
    def get_day_of_month(self) -> int: ...
    def get_day_of_week(self) -> int: ...
    def get_day_of_year(self) -> int: ...
    def get_hour(self) -> int: ...
    def get_microsecond(self) -> int: ...
    def get_minute(self) -> int: ...
    def get_month(self) -> int: ...
    def get_second(self) -> int: ...
    def get_seconds(self) -> float: ...
    def get_timezone(self) -> TimeZone: ...
    def get_timezone_abbreviation(self) -> str: ...
    def get_utc_offset(self) -> int: ...
    def get_week_numbering_year(self) -> int: ...
    def get_week_of_year(self) -> int: ...
    def get_year(self) -> int: ...
    def get_ymd(self) -> Tuple[int, int, int]: ...
    def hash(self) -> int: ...
    def is_daylight_savings(self) -> bool: ...
    @classmethod
    def new(
        cls,
        tz: TimeZone,
        year: int,
        month: int,
        day: int,
        hour: int,
        minute: int,
        seconds: float,
    ) -> Optional[DateTime]: ...
    @classmethod
    def new_from_iso8601(
        cls, text: str, default_tz: Optional[TimeZone] = None
    ) -> Optional[DateTime]: ...
    @classmethod
    def new_from_timeval_local(cls, tv: TimeVal) -> Optional[DateTime]: ...
    @classmethod
    def new_from_timeval_utc(cls, tv: TimeVal) -> Optional[DateTime]: ...
    @classmethod
    def new_from_unix_local(cls, t: int) -> Optional[DateTime]: ...
    @classmethod
    def new_from_unix_utc(cls, t: int) -> Optional[DateTime]: ...
    @classmethod
    def new_local(
        cls, year: int, month: int, day: int, hour: int, minute: int, seconds: float
    ) -> Optional[DateTime]: ...
    @classmethod
    def new_now(cls, tz: TimeZone) -> Optional[DateTime]: ...
    @classmethod
    def new_now_local(cls) -> Optional[DateTime]: ...
    @classmethod
    def new_now_utc(cls) -> Optional[DateTime]: ...
    @classmethod
    def new_utc(
        cls, year: int, month: int, day: int, hour: int, minute: int, seconds: float
    ) -> Optional[DateTime]: ...
    def ref(self) -> DateTime: ...
    def to_local(self) -> Optional[DateTime]: ...
    def to_timeval(self, tv: TimeVal) -> bool: ...
    def to_timezone(self, tz: TimeZone) -> Optional[DateTime]: ...
    def to_unix(self) -> int: ...
    def to_utc(self) -> Optional[DateTime]: ...
    def unref(self) -> None: ...

class DebugKey(GObject.GPointer):
    key: str = ...
    value: int = ...

class Dir(GObject.GPointer):
    def close(self) -> None: ...
    @staticmethod
    def make_tmp(tmpl: Optional[str] = None) -> str: ...
    def read_name(self) -> str: ...
    def rewind(self) -> None: ...

class DoubleIEEE754(GObject.GPointer):
    v_double = ...  # FIXME Constant

# override
class Error(Exception):
    args: Any
    code: GObject.GEnum
    domain: int
    message: str
    def __init__(
        self,
        message: str = ...,
        domain: Union[int, str] = ...,
        code: Union[GObject.GEnum, int] = ...,
    ) -> None: ...
    def copy(self) -> Error: ...
    def matches(
        self, domain: Union[int, str], code: Union[GObject.GEnum, int]
    ) -> bool: ...
    @classmethod
    def new_literal(
        cls, domain: int, message: str, code: Union[GObject.GEnum, int]
    ) -> Error: ...

class FloatIEEE754(GObject.GPointer):
    v_float = ...  # FIXME Constant

# override
class GError:
    args: Any
    code: GObject.GEnum
    domain: int
    message: str
    def __init__(
        self,
        message: str = ...,
        domain: Union[int, str] = ...,
        code: Union[GObject.GEnum, int] = ...,
    ) -> None: ...
    def copy(self) -> GError: ...
    def matches(
        self, domain: Union[int, str], code: Union[GObject.GEnum, int]
    ) -> bool: ...
    @classmethod
    def new_literal(
        cls, domain: int, message: str, code: Union[GObject.GEnum, int]
    ) -> GError: ...

class HashTable(GObject.GBoxed):
    @staticmethod
    def add(hash_table: str, key: None) -> bool: ...
    @staticmethod
    def contains(hash_table: str, key: None) -> bool: ...
    @staticmethod
    def destroy(hash_table: str) -> None: ...
    @staticmethod
    def insert(hash_table: str, key: None, value: None) -> bool: ...
    @staticmethod
    def lookup(hash_table: str, key: None) -> None: ...
    @staticmethod
    def lookup_extended(
        hash_table: str, lookup_key: None
    ) -> Tuple[bool, None, None]: ...
    @staticmethod
    def new_similar(other_hash_table: str) -> str: ...
    @staticmethod
    def remove(hash_table: str, key: None) -> bool: ...
    @staticmethod
    def remove_all(hash_table: str) -> None: ...
    @staticmethod
    def replace(hash_table: str, key: None, value: None) -> bool: ...
    @staticmethod
    def size(hash_table: str) -> int: ...
    @staticmethod
    def steal(hash_table: str, key: None) -> bool: ...
    @staticmethod
    def steal_all(hash_table: str) -> None: ...
    @staticmethod
    def steal_extended(
        hash_table: str, lookup_key: None
    ) -> Tuple[bool, None, None]: ...
    @staticmethod
    def unref(hash_table: str) -> None: ...

class HashTableIter(GObject.GPointer):
    dummy1: None = ...
    dummy2: None = ...
    dummy3: None = ...
    dummy4: int = ...
    dummy5: bool = ...
    dummy6: None = ...
    def init(self, hash_table: str) -> None: ...
    def next(self) -> Tuple[bool, None, None]: ...
    def remove(self) -> None: ...
    def replace(self, value: None) -> None: ...
    def steal(self) -> None: ...

class Hmac(GObject.GPointer):
    def get_digest(self, buffer: typing.Sequence[int]) -> None: ...
    def get_string(self) -> str: ...
    def unref(self) -> None: ...
    def update(self, data: typing.Sequence[int]) -> None: ...

class Hook(GObject.GPointer):
    data: None = ...
    next: Hook = ...
    prev: Hook = ...
    ref_count: int = ...
    hook_id: int = ...
    flags: int = ...
    func: None = ...
    destroy: Callable[[None], None] = ...
    def compare_ids(self, sibling: Hook) -> int: ...
    @staticmethod
    def destroy(hook_list: HookList, hook_id: int) -> bool: ...
    @staticmethod
    def destroy_link(hook_list: HookList, hook: Hook) -> None: ...
    @staticmethod
    def free(hook_list: HookList, hook: Hook) -> None: ...
    @staticmethod
    def insert_before(
        hook_list: HookList, sibling: Optional[Hook], hook: Hook
    ) -> None: ...
    @staticmethod
    def prepend(hook_list: HookList, hook: Hook) -> None: ...
    @staticmethod
    def unref(hook_list: HookList, hook: Hook) -> None: ...

class HookList(GObject.GPointer):
    seq_id: int = ...
    hook_size: int = ...
    is_setup: int = ...
    hooks: Hook = ...
    dummy3: None = ...
    finalize_hook: Callable[[HookList, Hook], None] = ...
    dummy: list[None] = ...
    def clear(self) -> None: ...
    def init(self, hook_size: int) -> None: ...
    def invoke(self, may_recurse: bool) -> None: ...
    def invoke_check(self, may_recurse: bool) -> None: ...

class IOChannel(GObject.GBoxed):
    ref_count: int = ...
    funcs: IOFuncs = ...
    encoding: str = ...
    read_cd: None = ...
    write_cd: None = ...
    line_term: str = ...
    line_term_len: int = ...
    buf_size: int = ...
    read_buf: String = ...
    encoded_read_buf: String = ...
    write_buf: String = ...
    partial_write_buf: list[int] = ...
    use_buffer: int = ...
    do_encode: int = ...
    close_on_unref: int = ...
    is_readable: int = ...
    is_writeable: int = ...
    is_seekable: int = ...
    reserved1: None = ...
    reserved2: None = ...
    _whence_map = ...  # FIXME Constant

    def add_watch(self, *args, **kwargs): ...  # FIXME Method
    def close(self) -> None: ...
    @staticmethod
    def error_from_errno(en: int) -> IOChannelError: ...
    @staticmethod
    def error_quark() -> int: ...
    def flush(self) -> IOStatus: ...
    def get_buffer_condition(self) -> IOCondition: ...
    def get_buffer_size(self) -> int: ...
    def get_buffered(self) -> bool: ...
    def get_close_on_unref(self) -> bool: ...
    def get_encoding(self) -> str: ...
    def get_flags(self) -> IOFlags: ...
    def get_line_term(self, length: int) -> str: ...
    def init(self) -> None: ...
    @classmethod
    def new_file(cls, filename: str, mode: str) -> IOChannel: ...
    def next(self, *args, **kwargs): ...  # FIXME Method
    def read(self, *args, **kwargs): ...  # FIXME Method
    def read_chars(self) -> Tuple[IOStatus, bytes, int]: ...
    def read_line(self) -> Tuple[IOStatus, str, int, int]: ...
    def read_line_string(
        self, buffer: String, terminator_pos: Optional[int] = None
    ) -> IOStatus: ...
    def read_to_end(self) -> Tuple[IOStatus, bytes]: ...
    def read_unichar(self) -> Tuple[IOStatus, str]: ...
    def readline(self, *args, **kwargs): ...  # FIXME Method
    def readlines(self, *args, **kwargs): ...  # FIXME Method
    def ref(self) -> IOChannel: ...
    def seek(self, *args, **kwargs): ...  # FIXME Method
    def seek_position(self, offset: int, type: SeekType) -> IOStatus: ...
    def set_buffer_size(self, size: int) -> None: ...
    def set_buffered(self, buffered: bool) -> None: ...
    def set_close_on_unref(self, do_close: bool) -> None: ...
    def set_encoding(self, encoding: Optional[str] = None) -> IOStatus: ...
    def set_flags(self, flags: IOFlags) -> IOStatus: ...
    def set_line_term(self, line_term: Optional[str], length: int) -> None: ...
    def shutdown(self, flush: bool) -> IOStatus: ...
    def unix_get_fd(self) -> int: ...
    @classmethod
    def unix_new(cls, fd: int) -> IOChannel: ...
    def unref(self) -> None: ...
    def write(self, *args, **kwargs): ...  # FIXME Method
    def write_chars(
        self, buf: typing.Sequence[int], count: int
    ) -> Tuple[IOStatus, int]: ...
    def write_unichar(self, thechar: str) -> IOStatus: ...
    def writelines(self, *args, **kwargs): ...  # FIXME Method

class IOFuncs(GObject.GPointer):
    io_read: Callable[[IOChannel, str, int, int], IOStatus] = ...
    io_write: Callable[[IOChannel, str, int, int], IOStatus] = ...
    io_seek: Callable[[IOChannel, int, SeekType], IOStatus] = ...
    io_close: Callable[[IOChannel], IOStatus] = ...
    io_create_watch: Callable[[IOChannel, IOCondition], Source] = ...
    io_free: Callable[[IOChannel], None] = ...
    io_set_flags: Callable[[IOChannel, IOFlags], IOStatus] = ...
    io_get_flags: Callable[[IOChannel], IOFlags] = ...

class Idle(GObject.GBoxed):
    callback_data: None = ...
    callback_funcs: SourceCallbackFuncs = ...
    source_funcs: SourceFuncs = ...
    ref_count: int = ...
    context: MainContext = ...
    priority: int = ...
    flags: int = ...
    source_id: int = ...
    poll_fds: list[None] = ...
    prev: Source = ...
    next: Source = ...
    name: str = ...
    priv: SourcePrivate = ...
    can_recurse = ...  # FIXME Constant

    def add_child_source(self, child_source: Source) -> None: ...
    def add_poll(self, fd: PollFD) -> None: ...
    def add_unix_fd(self, fd: int, events: IOCondition) -> None: ...
    def attach(self, context: Optional[MainContext] = None) -> int: ...
    def destroy(self) -> None: ...
    def get_can_recurse(self) -> bool: ...
    def get_context(self) -> Optional[MainContext]: ...
    def get_current_time(self, *args, **kwargs): ...  # FIXME Method
    def get_id(self) -> int: ...
    def get_name(self) -> Optional[str]: ...
    def get_priority(self) -> int: ...
    def get_ready_time(self) -> int: ...
    def get_time(self) -> int: ...
    def is_destroyed(self) -> bool: ...
    def modify_unix_fd(self, tag: None, new_events: IOCondition) -> None: ...
    @classmethod
    def new(cls, source_funcs: SourceFuncs, struct_size: int) -> Source: ...
    def query_unix_fd(self, tag: None) -> IOCondition: ...
    def ref(self) -> Source: ...
    @staticmethod
    def remove(tag: int) -> bool: ...
    @staticmethod
    def remove_by_funcs_user_data(funcs: SourceFuncs, user_data: None) -> bool: ...
    @staticmethod
    def remove_by_user_data(user_data: None) -> bool: ...
    def remove_child_source(self, child_source: Source) -> None: ...
    def remove_poll(self, fd: PollFD) -> None: ...
    def remove_unix_fd(self, tag: None) -> None: ...
    def set_callback(self, *args, **kwargs): ...  # FIXME Method
    def set_callback_indirect(
        self, callback_data: None, callback_funcs: SourceCallbackFuncs
    ) -> None: ...
    def set_can_recurse(self, can_recurse: bool) -> None: ...
    def set_funcs(self, funcs: SourceFuncs) -> None: ...
    def set_name(self, name: str) -> None: ...
    @staticmethod
    def set_name_by_id(tag: int, name: str) -> None: ...
    def set_priority(self, priority: int) -> None: ...
    def set_ready_time(self, ready_time: int) -> None: ...
    def set_static_name(self, name: str) -> None: ...
    def unref(self) -> None: ...

class KeyFile(GObject.GBoxed):
    @staticmethod
    def error_quark() -> int: ...
    def get_boolean(self, group_name: str, key: str) -> bool: ...
    def get_boolean_list(self, group_name: str, key: str) -> list[bool]: ...
    def get_comment(
        self, group_name: Optional[str] = None, key: Optional[str] = None
    ) -> str: ...
    def get_double(self, group_name: str, key: str) -> float: ...
    def get_double_list(self, group_name: str, key: str) -> list[float]: ...
    def get_groups(self) -> Tuple[list[str], int]: ...
    def get_int64(self, group_name: str, key: str) -> int: ...
    def get_integer(self, group_name: str, key: str) -> int: ...
    def get_integer_list(self, group_name: str, key: str) -> list[int]: ...
    def get_keys(self, group_name: str) -> Tuple[list[str], int]: ...
    def get_locale_for_key(
        self, group_name: str, key: str, locale: Optional[str] = None
    ) -> Optional[str]: ...
    def get_locale_string(
        self, group_name: str, key: str, locale: Optional[str] = None
    ) -> str: ...
    def get_locale_string_list(
        self, group_name: str, key: str, locale: Optional[str] = None
    ) -> list[str]: ...
    def get_start_group(self) -> Optional[str]: ...
    def get_string(self, group_name: str, key: str) -> str: ...
    def get_string_list(self, group_name: str, key: str) -> list[str]: ...
    def get_uint64(self, group_name: str, key: str) -> int: ...
    def get_value(self, group_name: str, key: str) -> str: ...
    def has_group(self, group_name: str) -> bool: ...
    def load_from_bytes(self, bytes: Bytes, flags: KeyFileFlags) -> bool: ...
    def load_from_data(self, data: str, length: int, flags: KeyFileFlags) -> bool: ...
    def load_from_data_dirs(
        self, file: str, flags: KeyFileFlags
    ) -> Tuple[bool, str]: ...
    def load_from_dirs(
        self, file: str, search_dirs: typing.Sequence[str], flags: KeyFileFlags
    ) -> Tuple[bool, str]: ...
    def load_from_file(self, file: str, flags: KeyFileFlags) -> bool: ...
    @classmethod
    def new(cls) -> KeyFile: ...
    def remove_comment(
        self, group_name: Optional[str] = None, key: Optional[str] = None
    ) -> bool: ...
    def remove_group(self, group_name: str) -> bool: ...
    def remove_key(self, group_name: str, key: str) -> bool: ...
    def save_to_file(self, filename: str) -> bool: ...
    def set_boolean(self, group_name: str, key: str, value: bool) -> None: ...
    def set_boolean_list(
        self, group_name: str, key: str, list: typing.Sequence[bool]
    ) -> None: ...
    def set_comment(
        self, group_name: Optional[str], key: Optional[str], comment: str
    ) -> bool: ...
    def set_double(self, group_name: str, key: str, value: float) -> None: ...
    def set_double_list(
        self, group_name: str, key: str, list: typing.Sequence[float]
    ) -> None: ...
    def set_int64(self, group_name: str, key: str, value: int) -> None: ...
    def set_integer(self, group_name: str, key: str, value: int) -> None: ...
    def set_integer_list(
        self, group_name: str, key: str, list: typing.Sequence[int]
    ) -> None: ...
    def set_list_separator(self, separator: int) -> None: ...
    def set_locale_string(
        self, group_name: str, key: str, locale: str, string: str
    ) -> None: ...
    def set_locale_string_list(
        self, group_name: str, key: str, locale: str, list: typing.Sequence[str]
    ) -> None: ...
    def set_string(self, group_name: str, key: str, string: str) -> None: ...
    def set_string_list(
        self, group_name: str, key: str, list: typing.Sequence[str]
    ) -> None: ...
    def set_uint64(self, group_name: str, key: str, value: int) -> None: ...
    def set_value(self, group_name: str, key: str, value: str) -> None: ...
    def to_data(self) -> Tuple[str, int]: ...
    def unref(self) -> None: ...

class List(GObject.GPointer):
    data: None = ...
    next: list[None] = ...
    prev: list[None] = ...

class LogField(GObject.GPointer):
    key: str = ...
    value: None = ...
    length: int = ...

class MainContext(GObject.GBoxed):
    def acquire(self) -> bool: ...
    def add_poll(self, fd: PollFD, priority: int) -> None: ...
    def check(self, max_priority: int, fds: typing.Sequence[PollFD]) -> bool: ...
    @staticmethod
    def default() -> MainContext: ...
    def dispatch(self) -> None: ...
    def find_source_by_funcs_user_data(
        self, funcs: SourceFuncs, user_data: None
    ) -> Source: ...
    def find_source_by_id(self, source_id: int) -> Source: ...
    def find_source_by_user_data(self, user_data: None) -> Source: ...
    @staticmethod
    def get_thread_default() -> Optional[MainContext]: ...
    def invoke_full(
        self, priority: int, function: Callable[..., bool], *data: Any
    ) -> None: ...
    def is_owner(self) -> bool: ...
    # override
    def iteration(self, may_block: bool = True) -> bool: ...
    @classmethod
    def new(cls) -> MainContext: ...
    @classmethod
    def new_with_flags(cls, flags: MainContextFlags) -> MainContext: ...
    def pending(self) -> bool: ...
    def pop_thread_default(self) -> None: ...
    def prepare(self) -> Tuple[bool, int]: ...
    def push_thread_default(self) -> None: ...
    def query(self, max_priority: int) -> Tuple[int, int, list[PollFD]]: ...
    def ref(self) -> MainContext: ...
    @staticmethod
    def ref_thread_default() -> MainContext: ...
    def release(self) -> None: ...
    def remove_poll(self, fd: PollFD) -> None: ...
    def unref(self) -> None: ...
    def wait(self, cond: Cond, mutex: Mutex) -> bool: ...
    def wakeup(self) -> None: ...

class MainLoop(GObject.GBoxed):
    def get_context(self) -> MainContext: ...
    def is_running(self) -> bool: ...
    @classmethod
    def new(cls, context: Optional[MainContext], is_running: bool) -> MainLoop: ...
    def quit(self) -> None: ...
    def ref(self) -> MainLoop: ...
    def run(self, *args, **kwargs): ...  # FIXME Method
    def unref(self) -> None: ...

class MappedFile(GObject.GBoxed):
    def free(self) -> None: ...
    def get_bytes(self) -> Bytes: ...
    def get_contents(self) -> str: ...
    def get_length(self) -> int: ...
    @classmethod
    def new(cls, filename: str, writable: bool) -> MappedFile: ...
    @classmethod
    def new_from_fd(cls, fd: int, writable: bool) -> MappedFile: ...
    def ref(self) -> MappedFile: ...
    def unref(self) -> None: ...

class MarkupParseContext(GObject.GBoxed):
    def end_parse(self) -> bool: ...
    def free(self) -> None: ...
    def get_element(self) -> str: ...
    def get_position(self) -> Tuple[int, int]: ...
    def get_user_data(self) -> None: ...
    @classmethod
    def new(
        cls,
        parser: MarkupParser,
        flags: MarkupParseFlags,
        user_data: None,
        user_data_dnotify: Callable[[None], None],
    ) -> MarkupParseContext: ...
    def parse(self, text: str, text_len: int) -> bool: ...
    def pop(self) -> None: ...
    def push(self, parser: MarkupParser, user_data: None) -> None: ...
    def ref(self) -> MarkupParseContext: ...
    def unref(self) -> None: ...

class MarkupParser(GObject.GPointer):
    start_element: Callable[..., None] = ...
    end_element: Callable[..., None] = ...
    text: Callable[..., None] = ...
    passthrough: Callable[..., None] = ...
    error: Callable[..., None] = ...

class MatchInfo(GObject.GBoxed):
    def expand_references(self, string_to_expand: str) -> Optional[str]: ...
    def fetch(self, match_num: int) -> Optional[str]: ...
    def fetch_all(self) -> list[str]: ...
    def fetch_named(self, name: str) -> Optional[str]: ...
    def fetch_named_pos(self, name: str) -> Tuple[bool, int, int]: ...
    def fetch_pos(self, match_num: int) -> Tuple[bool, int, int]: ...
    def free(self) -> None: ...
    def get_match_count(self) -> int: ...
    def get_regex(self) -> Regex: ...
    def get_string(self) -> str: ...
    def is_partial_match(self) -> bool: ...
    def matches(self) -> bool: ...
    def next(self) -> bool: ...
    def ref(self) -> MatchInfo: ...
    def unref(self) -> None: ...

class MemVTable(GObject.GPointer):
    malloc: Callable[[int], None] = ...
    realloc: Callable[[None, int], None] = ...
    free: Callable[[None], None] = ...
    calloc: Callable[[int, int], None] = ...
    try_malloc: Callable[[int], None] = ...
    try_realloc: Callable[[None, int], None] = ...

class Mutex(GObject.GPointer):
    i = ...  # FIXME Constant
    p = ...  # FIXME Constant

    def clear(self) -> None: ...
    def init(self) -> None: ...
    def lock(self) -> None: ...
    def trylock(self) -> bool: ...
    def unlock(self) -> None: ...

class Node(GObject.GPointer):
    data: None = ...
    next: Node = ...
    prev: Node = ...
    parent: Node = ...
    children: Node = ...
    def child_index(self, data: None) -> int: ...
    def child_position(self, child: Node) -> int: ...
    def depth(self) -> int: ...
    def destroy(self) -> None: ...
    def is_ancestor(self, descendant: Node) -> bool: ...
    def max_height(self) -> int: ...
    def n_children(self) -> int: ...
    def n_nodes(self, flags: TraverseFlags) -> int: ...
    def reverse_children(self) -> None: ...
    def unlink(self) -> None: ...

class Once(GObject.GPointer):
    status: OnceStatus = ...
    retval: None = ...
    @staticmethod
    def init_enter(location: None) -> bool: ...
    @staticmethod
    def init_leave(location: None, result: int) -> None: ...

class OptionContext:
    def add_group(self, *args, **kwargs): ...  # FIXME Method
    def get_help_enabled(self, *args, **kwargs): ...  # FIXME Method
    def get_ignore_unknown_options(self, *args, **kwargs): ...  # FIXME Method
    def get_main_group(self, *args, **kwargs): ...  # FIXME Method
    def parse(self, *args, **kwargs): ...  # FIXME Method
    def set_help_enabled(self, *args, **kwargs): ...  # FIXME Method
    def set_ignore_unknown_options(self, *args, **kwargs): ...  # FIXME Method
    def set_main_group(self, *args, **kwargs): ...  # FIXME Method

class OptionEntry(GObject.GPointer):
    long_name: str = ...
    short_name: int = ...
    flags: int = ...
    arg: OptionArg = ...
    arg_data: None = ...
    description: str = ...
    arg_description: str = ...

class OptionGroup:
    def add_entries(self, *args, **kwargs): ...  # FIXME Method
    def set_translation_domain(self, *args, **kwargs): ...  # FIXME Method

class PatternSpec(GObject.GBoxed):
    def copy(self) -> PatternSpec: ...
    def equal(self, pspec2: PatternSpec) -> bool: ...
    def free(self) -> None: ...
    def match(
        self, string_length: int, string: str, string_reversed: Optional[str] = None
    ) -> bool: ...
    def match_string(self, string: str) -> bool: ...
    @classmethod
    def new(cls, pattern: str) -> PatternSpec: ...

class Pid:
    denominator = ...  # FIXME Constant
    imag = ...  # FIXME Constant
    numerator = ...  # FIXME Constant
    real = ...  # FIXME Constant

    def as_integer_ratio(self, *args, **kwargs): ...  # FIXME Method
    def bit_count(self, *args, **kwargs): ...  # FIXME Method
    def bit_length(self, *args, **kwargs): ...  # FIXME Method
    def close(self, *args, **kwargs): ...  # FIXME Method
    def conjugate(self, *args, **kwargs): ...  # FIXME Method
    def from_bytes(self, *args, **kwargs): ...  # FIXME Method
    def to_bytes(self, *args, **kwargs): ...  # FIXME Method

class PollFD(GObject.GBoxed):
    fd: int = ...
    events: int = ...
    revents: int = ...

class Private(GObject.GPointer):
    p: None = ...
    notify: Callable[[None], None] = ...
    future: list[None] = ...
    def get(self) -> None: ...
    def replace(self, value: None) -> None: ...
    def set(self, value: None) -> None: ...

class PtrArray(GObject.GBoxed):
    pdata: None = ...
    len: int = ...

class Queue(GObject.GPointer):
    head: list[None] = ...
    tail: list[None] = ...
    length: int = ...
    def clear(self) -> None: ...
    def clear_full(
        self, free_func: Optional[Callable[[None], None]] = None
    ) -> None: ...
    def free(self) -> None: ...
    def free_full(self, free_func: Callable[[None], None]) -> None: ...
    def get_length(self) -> int: ...
    def index(self, data: None) -> int: ...
    def init(self) -> None: ...
    def is_empty(self) -> bool: ...
    def peek_head(self) -> None: ...
    def peek_nth(self, n: int) -> None: ...
    def peek_tail(self) -> None: ...
    def pop_head(self) -> None: ...
    def pop_nth(self, n: int) -> None: ...
    def pop_tail(self) -> None: ...
    def push_head(self, data: None) -> None: ...
    def push_nth(self, data: None, n: int) -> None: ...
    def push_tail(self, data: None) -> None: ...
    def remove(self, data: None) -> bool: ...
    def remove_all(self, data: None) -> int: ...
    def reverse(self) -> None: ...

class RWLock(GObject.GPointer):
    p: None = ...
    i: list[int] = ...
    def clear(self) -> None: ...
    def init(self) -> None: ...
    def reader_lock(self) -> None: ...
    def reader_trylock(self) -> bool: ...
    def reader_unlock(self) -> None: ...
    def writer_lock(self) -> None: ...
    def writer_trylock(self) -> bool: ...
    def writer_unlock(self) -> None: ...

class Rand(GObject.GPointer):
    def double(self) -> float: ...
    def double_range(self, begin: float, end: float) -> float: ...
    def free(self) -> None: ...
    def int(self) -> int: ...
    def int_range(self, begin: int, end: int) -> int: ...
    def set_seed(self, seed: int) -> None: ...
    def set_seed_array(self, seed: int, seed_length: int) -> None: ...

class RecMutex(GObject.GPointer):
    p: None = ...
    i: list[int] = ...
    def clear(self) -> None: ...
    def init(self) -> None: ...
    def lock(self) -> None: ...
    def trylock(self) -> bool: ...
    def unlock(self) -> None: ...

class Regex(GObject.GBoxed):
    @staticmethod
    def check_replacement(replacement: str) -> Tuple[bool, bool]: ...
    @staticmethod
    def error_quark() -> int: ...
    @staticmethod
    def escape_nul(string: str, length: int) -> str: ...
    @staticmethod
    def escape_string(string: typing.Sequence[str]) -> str: ...
    def get_capture_count(self) -> int: ...
    def get_compile_flags(self) -> RegexCompileFlags: ...
    def get_has_cr_or_lf(self) -> bool: ...
    def get_match_flags(self) -> RegexMatchFlags: ...
    def get_max_backref(self) -> int: ...
    def get_max_lookbehind(self) -> int: ...
    def get_pattern(self) -> str: ...
    def get_string_number(self, name: str) -> int: ...
    def match(
        self, string: str, match_options: RegexMatchFlags
    ) -> Tuple[bool, MatchInfo]: ...
    def match_all(
        self, string: str, match_options: RegexMatchFlags
    ) -> Tuple[bool, MatchInfo]: ...
    def match_all_full(
        self,
        string: typing.Sequence[str],
        start_position: int,
        match_options: RegexMatchFlags,
    ) -> Tuple[bool, MatchInfo]: ...
    def match_full(
        self,
        string: typing.Sequence[str],
        start_position: int,
        match_options: RegexMatchFlags,
    ) -> Tuple[bool, MatchInfo]: ...
    @staticmethod
    def match_simple(
        pattern: str,
        string: str,
        compile_options: RegexCompileFlags,
        match_options: RegexMatchFlags,
    ) -> bool: ...
    @classmethod
    def new(
        cls,
        pattern: str,
        compile_options: RegexCompileFlags,
        match_options: RegexMatchFlags,
    ) -> Optional[Regex]: ...
    def ref(self) -> Regex: ...
    def replace(
        self,
        string: typing.Sequence[str],
        start_position: int,
        replacement: str,
        match_options: RegexMatchFlags,
    ) -> str: ...
    def replace_literal(
        self,
        string: typing.Sequence[str],
        start_position: int,
        replacement: str,
        match_options: RegexMatchFlags,
    ) -> str: ...
    def split(self, string: str, match_options: RegexMatchFlags) -> list[str]: ...
    def split_full(
        self,
        string: typing.Sequence[str],
        start_position: int,
        match_options: RegexMatchFlags,
        max_tokens: int,
    ) -> list[str]: ...
    @staticmethod
    def split_simple(
        pattern: str,
        string: str,
        compile_options: RegexCompileFlags,
        match_options: RegexMatchFlags,
    ) -> list[str]: ...
    def unref(self) -> None: ...

class SList(GObject.GPointer):
    data: None = ...
    next: list[None] = ...

class Scanner(GObject.GPointer):
    user_data: None = ...
    max_parse_errors: int = ...
    parse_errors: int = ...
    input_name: str = ...
    qdata: Data = ...
    config: ScannerConfig = ...
    token: TokenType = ...
    value: TokenValue = ...
    line: int = ...
    position: int = ...
    next_token: TokenType = ...
    next_value: TokenValue = ...
    next_line: int = ...
    next_position: int = ...
    symbol_table: str = ...
    input_fd: int = ...
    text: str = ...
    text_end: str = ...
    buffer: str = ...
    scope_id: int = ...
    msg_handler: Callable[[Scanner, str, bool], None] = ...
    def cur_line(self) -> int: ...
    def cur_position(self) -> int: ...
    def cur_token(self) -> TokenType: ...
    def destroy(self) -> None: ...
    def eof(self) -> bool: ...
    def get_next_token(self) -> TokenType: ...
    def input_file(self, input_fd: int) -> None: ...
    def input_text(self, text: str, text_len: int) -> None: ...
    def lookup_symbol(self, symbol: str) -> None: ...
    def peek_next_token(self) -> TokenType: ...
    def scope_add_symbol(self, scope_id: int, symbol: str, value: None) -> None: ...
    def scope_lookup_symbol(self, scope_id: int, symbol: str) -> None: ...
    def scope_remove_symbol(self, scope_id: int, symbol: str) -> None: ...
    def set_scope(self, scope_id: int) -> int: ...
    def sync_file_offset(self) -> None: ...
    def unexp_token(
        self,
        expected_token: TokenType,
        identifier_spec: str,
        symbol_spec: str,
        symbol_name: str,
        message: str,
        is_error: int,
    ) -> None: ...

class ScannerConfig(GObject.GPointer):
    cset_skip_characters: str = ...
    cset_identifier_first: str = ...
    cset_identifier_nth: str = ...
    cpair_comment_single: str = ...
    case_sensitive: int = ...
    skip_comment_multi: int = ...
    skip_comment_single: int = ...
    scan_comment_multi: int = ...
    scan_identifier: int = ...
    scan_identifier_1char: int = ...
    scan_identifier_NULL: int = ...
    scan_symbols: int = ...
    scan_binary: int = ...
    scan_octal: int = ...
    scan_float: int = ...
    scan_hex: int = ...
    scan_hex_dollar: int = ...
    scan_string_sq: int = ...
    scan_string_dq: int = ...
    numbers_2_int: int = ...
    int_2_float: int = ...
    identifier_2_string: int = ...
    char_2_token: int = ...
    symbol_2_token: int = ...
    scope_0_fallback: int = ...
    store_int64: int = ...
    padding_dummy: int = ...

class Sequence(GObject.GPointer):
    def append(self, data: None) -> SequenceIter: ...
    def free(self) -> None: ...
    @staticmethod
    def get(iter: SequenceIter) -> None: ...
    def get_begin_iter(self) -> SequenceIter: ...
    def get_end_iter(self) -> SequenceIter: ...
    def get_iter_at_pos(self, pos: int) -> SequenceIter: ...
    def get_length(self) -> int: ...
    @staticmethod
    def insert_before(iter: SequenceIter, data: None) -> SequenceIter: ...
    def is_empty(self) -> bool: ...
    @staticmethod
    def move(src: SequenceIter, dest: SequenceIter) -> None: ...
    @staticmethod
    def move_range(
        dest: SequenceIter, begin: SequenceIter, end: SequenceIter
    ) -> None: ...
    def prepend(self, data: None) -> SequenceIter: ...
    @staticmethod
    def range_get_midpoint(begin: SequenceIter, end: SequenceIter) -> SequenceIter: ...
    @staticmethod
    def remove(iter: SequenceIter) -> None: ...
    @staticmethod
    def remove_range(begin: SequenceIter, end: SequenceIter) -> None: ...
    @staticmethod
    def set(iter: SequenceIter, data: None) -> None: ...
    @staticmethod
    def swap(a: SequenceIter, b: SequenceIter) -> None: ...

class SequenceIter(GObject.GPointer):
    def compare(self, b: SequenceIter) -> int: ...
    def get_position(self) -> int: ...
    def get_sequence(self) -> Sequence: ...
    def is_begin(self) -> bool: ...
    def is_end(self) -> bool: ...
    def move(self, delta: int) -> SequenceIter: ...
    def next(self) -> SequenceIter: ...
    def prev(self) -> SequenceIter: ...

class Source(GObject.GBoxed):
    callback_data: None = ...
    callback_funcs: SourceCallbackFuncs = ...
    source_funcs: SourceFuncs = ...
    ref_count: int = ...
    context: MainContext = ...
    priority: int = ...
    flags: int = ...
    source_id: int = ...
    poll_fds: list[None] = ...
    prev: Source = ...
    next: Source = ...
    name: str = ...
    priv: SourcePrivate = ...
    can_recurse = ...  # FIXME Constant

    def add_child_source(self, child_source: Source) -> None: ...
    def add_poll(self, fd: PollFD) -> None: ...
    def add_unix_fd(self, fd: int, events: IOCondition) -> None: ...
    def attach(self, context: Optional[MainContext] = None) -> int: ...
    def destroy(self) -> None: ...
    def get_can_recurse(self) -> bool: ...
    def get_context(self) -> Optional[MainContext]: ...
    def get_current_time(self, *args, **kwargs): ...  # FIXME Method
    def get_id(self) -> int: ...
    def get_name(self) -> Optional[str]: ...
    def get_priority(self) -> int: ...
    def get_ready_time(self) -> int: ...
    def get_time(self) -> int: ...
    def is_destroyed(self) -> bool: ...
    def modify_unix_fd(self, tag: None, new_events: IOCondition) -> None: ...
    @classmethod
    def new(cls, source_funcs: SourceFuncs, struct_size: int) -> Source: ...
    def query_unix_fd(self, tag: None) -> IOCondition: ...
    def ref(self) -> Source: ...
    @staticmethod
    def remove(tag: int) -> bool: ...
    @staticmethod
    def remove_by_funcs_user_data(funcs: SourceFuncs, user_data: None) -> bool: ...
    @staticmethod
    def remove_by_user_data(user_data: None) -> bool: ...
    def remove_child_source(self, child_source: Source) -> None: ...
    def remove_poll(self, fd: PollFD) -> None: ...
    def remove_unix_fd(self, tag: None) -> None: ...
    def set_callback(self, *args, **kwargs): ...  # FIXME Method
    def set_callback_indirect(
        self, callback_data: None, callback_funcs: SourceCallbackFuncs
    ) -> None: ...
    def set_can_recurse(self, can_recurse: bool) -> None: ...
    def set_funcs(self, funcs: SourceFuncs) -> None: ...
    def set_name(self, name: str) -> None: ...
    @staticmethod
    def set_name_by_id(tag: int, name: str) -> None: ...
    def set_priority(self, priority: int) -> None: ...
    def set_ready_time(self, ready_time: int) -> None: ...
    def set_static_name(self, name: str) -> None: ...
    def unref(self) -> None: ...

class SourceCallbackFuncs(GObject.GPointer):
    ref: Callable[[None], None] = ...
    unref: Callable[[None], None] = ...
    get: None = ...

class SourceFuncs(GObject.GPointer):
    prepare: Callable[[Source, int], bool] = ...
    check: Callable[[Source], bool] = ...
    dispatch: None = ...
    finalize: Callable[[Source], None] = ...
    closure_callback: Callable[..., bool] = ...
    closure_marshal: Callable[[], None] = ...

class SourcePrivate(GObject.GPointer): ...
class StatBuf(GObject.GPointer): ...

class String(GObject.GBoxed):
    str: str = ...
    len: int = ...
    allocated_len: int = ...
    def append(self, val: str) -> String: ...
    def append_c(self, c: int) -> String: ...
    def append_len(self, val: str, len: int) -> String: ...
    def append_unichar(self, wc: str) -> String: ...
    def append_uri_escaped(
        self, unescaped: str, reserved_chars_allowed: str, allow_utf8: bool
    ) -> String: ...
    def ascii_down(self) -> String: ...
    def ascii_up(self) -> String: ...
    def assign(self, rval: str) -> String: ...
    def down(self) -> String: ...
    def equal(self, v2: String) -> bool: ...
    def erase(self, pos: int, len: int) -> String: ...
    def free(self, free_segment: bool) -> Optional[str]: ...
    def free_to_bytes(self) -> Bytes: ...
    def hash(self) -> int: ...
    def insert(self, pos: int, val: str) -> String: ...
    def insert_c(self, pos: int, c: int) -> String: ...
    def insert_len(self, pos: int, val: str, len: int) -> String: ...
    def insert_unichar(self, pos: int, wc: str) -> String: ...
    @classmethod
    def new(cls, init: Optional[str] = None) -> String: ...
    @classmethod
    def new_len(cls, init: str, len: int) -> String: ...
    def overwrite(self, pos: int, val: str) -> String: ...
    def overwrite_len(self, pos: int, val: str, len: int) -> String: ...
    def prepend(self, val: str) -> String: ...
    def prepend_c(self, c: int) -> String: ...
    def prepend_len(self, val: str, len: int) -> String: ...
    def prepend_unichar(self, wc: str) -> String: ...
    def replace(self, find: str, replace: str, limit: int) -> int: ...
    def set_size(self, len: int) -> String: ...
    @classmethod
    def sized_new(cls, dfl_size: int) -> String: ...
    def truncate(self, len: int) -> String: ...
    def up(self) -> String: ...

class StringChunk(GObject.GPointer):
    def clear(self) -> None: ...
    def free(self) -> None: ...
    def insert(self, string: str) -> str: ...
    def insert_const(self, string: str) -> str: ...
    def insert_len(self, string: str, len: int) -> str: ...

class StrvBuilder(GObject.GPointer):
    def add(self, value: str) -> None: ...
    def addv(self, value: typing.Sequence[str]) -> None: ...
    def end(self) -> list[str]: ...
    def unref(self) -> None: ...

class TestCase(GObject.GPointer):
    def free(self) -> None: ...

class TestConfig(GObject.GPointer):
    test_initialized: bool = ...
    test_quick: bool = ...
    test_perf: bool = ...
    test_verbose: bool = ...
    test_quiet: bool = ...
    test_undefined: bool = ...

class TestLogBuffer(GObject.GPointer):
    data: String = ...
    msgs: list[None] = ...
    def free(self) -> None: ...
    def push(self, n_bytes: int, bytes: int) -> None: ...

class TestLogMsg(GObject.GPointer):
    log_type: TestLogType = ...
    n_strings: int = ...
    strings: str = ...
    n_nums: int = ...
    nums: None = ...
    def free(self) -> None: ...

class TestSuite(GObject.GPointer):
    def add(self, test_case: TestCase) -> None: ...
    def add_suite(self, nestedsuite: TestSuite) -> None: ...
    def free(self) -> None: ...

class Thread(GObject.GBoxed):
    @staticmethod
    def error_quark() -> int: ...
    @staticmethod
    def exit(retval: None) -> None: ...
    def join(self) -> None: ...
    @classmethod
    def new(
        cls, name: Optional[str], func: Callable[..., None], *data: Any
    ) -> Thread: ...
    def ref(self) -> Thread: ...
    @staticmethod
    def self() -> Thread: ...
    @classmethod
    def try_new(
        cls, name: Optional[str], func: Callable[..., None], *data: Any
    ) -> Thread: ...
    def unref(self) -> None: ...
    @staticmethod
    def yield_() -> None: ...

class ThreadPool(GObject.GPointer):
    func: Callable[..., None] = ...
    user_data: None = ...
    exclusive: bool = ...
    def free(self, immediate: bool, wait_: bool) -> None: ...
    @staticmethod
    def get_max_idle_time() -> int: ...
    def get_max_threads(self) -> int: ...
    @staticmethod
    def get_max_unused_threads() -> int: ...
    def get_num_threads(self) -> int: ...
    @staticmethod
    def get_num_unused_threads() -> int: ...
    def move_to_front(self, data: None) -> bool: ...
    def push(self, data: None) -> bool: ...
    @staticmethod
    def set_max_idle_time(interval: int) -> None: ...
    def set_max_threads(self, max_threads: int) -> bool: ...
    @staticmethod
    def set_max_unused_threads(max_threads: int) -> None: ...
    @staticmethod
    def stop_unused_threads() -> None: ...
    def unprocessed(self) -> int: ...

class TimeVal(GObject.GPointer):
    tv_sec: int = ...
    tv_usec: int = ...
    def add(self, microseconds: int) -> None: ...
    @staticmethod
    def from_iso8601(iso_date: str) -> Tuple[bool, TimeVal]: ...
    def to_iso8601(self) -> Optional[str]: ...

class TimeZone(GObject.GBoxed):
    def adjust_time(self, type: TimeType, time_: int) -> int: ...
    def find_interval(self, type: TimeType, time_: int) -> int: ...
    def get_abbreviation(self, interval: int) -> str: ...
    def get_identifier(self) -> str: ...
    def get_offset(self, interval: int) -> int: ...
    def is_dst(self, interval: int) -> bool: ...
    @classmethod
    def new(cls, identifier: Optional[str] = None) -> TimeZone: ...
    @classmethod
    def new_identifier(cls, identifier: Optional[str] = None) -> Optional[TimeZone]: ...
    @classmethod
    def new_local(cls) -> TimeZone: ...
    @classmethod
    def new_offset(cls, seconds: int) -> TimeZone: ...
    @classmethod
    def new_utc(cls) -> TimeZone: ...
    def ref(self) -> TimeZone: ...
    def unref(self) -> None: ...

class Timeout(GObject.GBoxed):
    callback_data: None = ...
    callback_funcs: SourceCallbackFuncs = ...
    source_funcs: SourceFuncs = ...
    ref_count: int = ...
    context: MainContext = ...
    priority: int = ...
    flags: int = ...
    source_id: int = ...
    poll_fds: list[None] = ...
    prev: Source = ...
    next: Source = ...
    name: str = ...
    priv: SourcePrivate = ...
    can_recurse = ...  # FIXME Constant

    def add_child_source(self, child_source: Source) -> None: ...
    def add_poll(self, fd: PollFD) -> None: ...
    def add_unix_fd(self, fd: int, events: IOCondition) -> None: ...
    def attach(self, context: Optional[MainContext] = None) -> int: ...
    def destroy(self) -> None: ...
    def get_can_recurse(self) -> bool: ...
    def get_context(self) -> Optional[MainContext]: ...
    def get_current_time(self, *args, **kwargs): ...  # FIXME Method
    def get_id(self) -> int: ...
    def get_name(self) -> Optional[str]: ...
    def get_priority(self) -> int: ...
    def get_ready_time(self) -> int: ...
    def get_time(self) -> int: ...
    def is_destroyed(self) -> bool: ...
    def modify_unix_fd(self, tag: None, new_events: IOCondition) -> None: ...
    @classmethod
    def new(cls, source_funcs: SourceFuncs, struct_size: int) -> Source: ...
    def query_unix_fd(self, tag: None) -> IOCondition: ...
    def ref(self) -> Source: ...
    @staticmethod
    def remove(tag: int) -> bool: ...
    @staticmethod
    def remove_by_funcs_user_data(funcs: SourceFuncs, user_data: None) -> bool: ...
    @staticmethod
    def remove_by_user_data(user_data: None) -> bool: ...
    def remove_child_source(self, child_source: Source) -> None: ...
    def remove_poll(self, fd: PollFD) -> None: ...
    def remove_unix_fd(self, tag: None) -> None: ...
    def set_callback(self, *args, **kwargs): ...  # FIXME Method
    def set_callback_indirect(
        self, callback_data: None, callback_funcs: SourceCallbackFuncs
    ) -> None: ...
    def set_can_recurse(self, can_recurse: bool) -> None: ...
    def set_funcs(self, funcs: SourceFuncs) -> None: ...
    def set_name(self, name: str) -> None: ...
    @staticmethod
    def set_name_by_id(tag: int, name: str) -> None: ...
    def set_priority(self, priority: int) -> None: ...
    def set_ready_time(self, ready_time: int) -> None: ...
    def set_static_name(self, name: str) -> None: ...
    def unref(self) -> None: ...

class Timer(GObject.GPointer):
    def continue_(self) -> None: ...
    def destroy(self) -> None: ...
    def elapsed(self, microseconds: int) -> float: ...
    def is_active(self) -> bool: ...
    def reset(self) -> None: ...
    def start(self) -> None: ...
    def stop(self) -> None: ...

class TokenValue(GObject.GPointer):
    v_binary = ...  # FIXME Constant
    v_char = ...  # FIXME Constant
    v_comment = ...  # FIXME Constant
    v_error = ...  # FIXME Constant
    v_float = ...  # FIXME Constant
    v_hex = ...  # FIXME Constant
    v_identifier = ...  # FIXME Constant
    v_int = ...  # FIXME Constant
    v_int64 = ...  # FIXME Constant
    v_octal = ...  # FIXME Constant
    v_string = ...  # FIXME Constant
    v_symbol = ...  # FIXME Constant

class TrashStack(GObject.GPointer):
    next: TrashStack = ...
    @staticmethod
    def height(stack_p: TrashStack) -> int: ...
    @staticmethod
    def peek(stack_p: TrashStack) -> None: ...
    @staticmethod
    def pop(stack_p: TrashStack) -> None: ...
    @staticmethod
    def push(stack_p: TrashStack, data_p: None) -> None: ...

class Tree(GObject.GBoxed):
    def destroy(self) -> None: ...
    def height(self) -> int: ...
    def insert(self, key: None, value: None) -> None: ...
    def insert_node(self, key: None, value: None) -> TreeNode: ...
    def lookup(self, key: None) -> None: ...
    def lookup_extended(self, lookup_key: None) -> Tuple[bool, None, None]: ...
    def lookup_node(self, key: None) -> Optional[TreeNode]: ...
    def lower_bound(self, key: None) -> Optional[TreeNode]: ...
    @classmethod
    def new_full(
        cls,
        key_compare_func: Callable[..., int],
        key_destroy_func: Callable[[None], None],
        *key_compare_data: Any,
    ) -> Tree: ...
    def nnodes(self) -> int: ...
    def node_first(self) -> Optional[TreeNode]: ...
    def node_last(self) -> Optional[TreeNode]: ...
    def ref(self) -> Tree: ...
    def remove(self, key: None) -> bool: ...
    def remove_all(self) -> None: ...
    def replace(self, key: None, value: None) -> None: ...
    def replace_node(self, key: None, value: None) -> TreeNode: ...
    def steal(self, key: None) -> bool: ...
    def unref(self) -> None: ...
    def upper_bound(self, key: None) -> Optional[TreeNode]: ...

class TreeNode(GObject.GPointer):
    def key(self) -> None: ...
    def next(self) -> Optional[TreeNode]: ...
    def previous(self) -> Optional[TreeNode]: ...
    def value(self) -> None: ...

class Uri(GObject.GBoxed):
    @staticmethod
    def build(
        flags: UriFlags,
        scheme: str,
        userinfo: Optional[str],
        host: Optional[str],
        port: int,
        path: str,
        query: Optional[str] = None,
        fragment: Optional[str] = None,
    ) -> Uri: ...
    @staticmethod
    def build_with_user(
        flags: UriFlags,
        scheme: str,
        user: Optional[str],
        password: Optional[str],
        auth_params: Optional[str],
        host: Optional[str],
        port: int,
        path: str,
        query: Optional[str] = None,
        fragment: Optional[str] = None,
    ) -> Uri: ...
    @staticmethod
    def error_quark() -> int: ...
    @staticmethod
    def escape_bytes(
        unescaped: typing.Sequence[int], reserved_chars_allowed: Optional[str] = None
    ) -> str: ...
    @staticmethod
    def escape_string(
        unescaped: str, reserved_chars_allowed: Optional[str], allow_utf8: bool
    ) -> str: ...
    def get_auth_params(self) -> Optional[str]: ...
    def get_flags(self) -> UriFlags: ...
    def get_fragment(self) -> Optional[str]: ...
    def get_host(self) -> Optional[str]: ...
    def get_password(self) -> Optional[str]: ...
    def get_path(self) -> str: ...
    def get_port(self) -> int: ...
    def get_query(self) -> Optional[str]: ...
    def get_scheme(self) -> str: ...
    def get_user(self) -> Optional[str]: ...
    def get_userinfo(self) -> Optional[str]: ...
    @staticmethod
    def is_valid(uri_string: str, flags: UriFlags) -> bool: ...
    @staticmethod
    def join(
        flags: UriFlags,
        scheme: Optional[str],
        userinfo: Optional[str],
        host: Optional[str],
        port: int,
        path: str,
        query: Optional[str] = None,
        fragment: Optional[str] = None,
    ) -> str: ...
    @staticmethod
    def join_with_user(
        flags: UriFlags,
        scheme: Optional[str],
        user: Optional[str],
        password: Optional[str],
        auth_params: Optional[str],
        host: Optional[str],
        port: int,
        path: str,
        query: Optional[str] = None,
        fragment: Optional[str] = None,
    ) -> str: ...
    @staticmethod
    def list_extract_uris(uri_list: str) -> list[str]: ...
    @staticmethod
    def parse(uri_string: str, flags: UriFlags) -> Uri: ...
    @staticmethod
    def parse_params(
        params: str, length: int, separators: str, flags: UriParamsFlags
    ) -> str: ...
    def parse_relative(self, uri_ref: str, flags: UriFlags) -> Uri: ...
    @staticmethod
    def parse_scheme(uri: str) -> Optional[str]: ...
    @staticmethod
    def peek_scheme(uri: str) -> Optional[str]: ...
    @staticmethod
    def resolve_relative(
        base_uri_string: Optional[str], uri_ref: str, flags: UriFlags
    ) -> str: ...
    @staticmethod
    def split(
        uri_ref: str, flags: UriFlags
    ) -> Tuple[bool, str, str, str, int, str, str, str]: ...
    @staticmethod
    def split_network(
        uri_string: str, flags: UriFlags
    ) -> Tuple[bool, str, str, int]: ...
    @staticmethod
    def split_with_user(
        uri_ref: str, flags: UriFlags
    ) -> Tuple[bool, str, str, str, str, str, int, str, str, str]: ...
    def to_string(self) -> str: ...
    def to_string_partial(self, flags: UriHideFlags) -> str: ...
    @staticmethod
    def unescape_bytes(
        escaped_string: str, length: int, illegal_characters: Optional[str] = None
    ) -> Bytes: ...
    @staticmethod
    def unescape_segment(
        escaped_string: Optional[str] = None,
        escaped_string_end: Optional[str] = None,
        illegal_characters: Optional[str] = None,
    ) -> Optional[str]: ...
    @staticmethod
    def unescape_string(
        escaped_string: str, illegal_characters: Optional[str] = None
    ) -> Optional[str]: ...

class UriParamsIter(GObject.GPointer):
    dummy0: int = ...
    dummy1: None = ...
    dummy2: None = ...
    dummy3: bytes = ...
    def init(
        self, params: str, length: int, separators: str, flags: UriParamsFlags
    ) -> None: ...
    def next(self) -> Tuple[bool, str, str]: ...

class Variant(GObject.GPointer):
    # override
    def __init__(self, format_string: str, value: Any): ...
    def byteswap(self) -> Variant: ...
    def check_format_string(self, format_string: str, copy_only: bool) -> bool: ...
    def classify(self) -> VariantClass: ...
    def compare(self, two: Variant) -> int: ...
    def dup_bytestring(self) -> bytes: ...
    def dup_bytestring_array(self) -> list[str]: ...
    def dup_objv(self) -> list[str]: ...
    def dup_string(self) -> Tuple[str, int]: ...
    def dup_strv(self) -> list[str]: ...
    def equal(self, two: Variant) -> bool: ...
    def get_boolean(self) -> bool: ...
    def get_byte(self) -> int: ...
    def get_bytestring(self) -> bytes: ...
    def get_bytestring_array(self) -> list[str]: ...
    def get_child_value(self, index_: int) -> Variant: ...
    def get_data(self) -> None: ...
    def get_data_as_bytes(self) -> Bytes: ...
    def get_double(self) -> float: ...
    def get_handle(self) -> int: ...
    def get_int16(self) -> int: ...
    def get_int32(self) -> int: ...
    def get_int64(self) -> int: ...
    def get_maybe(self) -> Optional[Variant]: ...
    def get_normal_form(self) -> Variant: ...
    def get_objv(self) -> list[str]: ...
    def get_size(self) -> int: ...
    # override
    def get_string(self) -> str: ...
    def get_strv(self) -> list[str]: ...
    def get_type(self) -> VariantType: ...
    def get_type_string(self) -> str: ...
    def get_uint16(self) -> int: ...
    def get_uint32(self) -> int: ...
    def get_uint64(self) -> int: ...
    def get_variant(self) -> Variant: ...
    def hash(self) -> int: ...
    def is_container(self) -> bool: ...
    def is_floating(self) -> bool: ...
    def is_normal_form(self) -> bool: ...
    @staticmethod
    def is_object_path(string: str) -> bool: ...
    def is_of_type(self, type: VariantType) -> bool: ...
    @staticmethod
    def is_signature(string: str) -> bool: ...
    def keys(self, *args, **kwargs): ...  # FIXME Method
    def lookup_value(
        self, key: str, expected_type: Optional[VariantType] = None
    ) -> Variant: ...
    def n_children(self) -> int: ...
    @classmethod
    def new_array(
        cls,
        child_type: Optional[VariantType] = None,
        children: Optional[typing.Sequence[Variant]] = None,
    ) -> Variant: ...
    @classmethod
    def new_boolean(cls, value: bool) -> Variant: ...
    @classmethod
    def new_byte(cls, value: int) -> Variant: ...
    @classmethod
    def new_bytestring(cls, string: typing.Sequence[int]) -> Variant: ...
    @classmethod
    def new_bytestring_array(cls, strv: typing.Sequence[str]) -> Variant: ...
    @classmethod
    def new_dict_entry(cls, key: Variant, value: Variant) -> Variant: ...
    @classmethod
    def new_double(cls, value: float) -> Variant: ...
    @classmethod
    def new_fixed_array(
        cls,
        element_type: VariantType,
        elements: None,
        n_elements: int,
        element_size: int,
    ) -> Variant: ...
    @classmethod
    def new_from_bytes(
        cls, type: VariantType, bytes: Bytes, trusted: bool
    ) -> Variant: ...
    @classmethod
    def new_from_data(
        cls,
        type: VariantType,
        data: typing.Sequence[int],
        trusted: bool,
        notify: Callable[[None], None],
        user_data: None,
    ) -> Variant: ...
    @classmethod
    def new_handle(cls, value: int) -> Variant: ...
    @classmethod
    def new_int16(cls, value: int) -> Variant: ...
    @classmethod
    def new_int32(cls, value: int) -> Variant: ...
    @classmethod
    def new_int64(cls, value: int) -> Variant: ...
    @classmethod
    def new_maybe(
        cls, child_type: Optional[VariantType] = None, child: Optional[Variant] = None
    ) -> Variant: ...
    @classmethod
    def new_object_path(cls, object_path: str) -> Variant: ...
    @classmethod
    def new_objv(cls, strv: typing.Sequence[str]) -> Variant: ...
    @classmethod
    def new_signature(cls, signature: str) -> Variant: ...
    @classmethod
    def new_string(cls, string: str) -> Variant: ...
    @classmethod
    def new_strv(cls, strv: typing.Sequence[str]) -> Variant: ...
    # override
    @classmethod
    def new_tuple(cls, children: Variant) -> Variant: ...
    @classmethod
    def new_uint16(cls, value: int) -> Variant: ...
    @classmethod
    def new_uint32(cls, value: int) -> Variant: ...
    @classmethod
    def new_uint64(cls, value: int) -> Variant: ...
    @classmethod
    def new_variant(cls, value: Variant) -> Variant: ...
    @staticmethod
    def parse(
        type: Optional[VariantType],
        text: str,
        limit: Optional[str] = None,
        endptr: Optional[str] = None,
    ) -> Variant: ...
    @staticmethod
    def parse_error_print_context(error: Error, source_str: str) -> str: ...
    @staticmethod
    def parse_error_quark() -> int: ...
    @staticmethod
    def parser_get_error_quark() -> int: ...
    def print_(self, type_annotate: bool) -> str: ...
    def ref(self) -> Variant: ...
    def ref_sink(self) -> Variant: ...
    def split_signature(self, *args, **kwargs): ...  # FIXME Method
    def store(self, data: None) -> None: ...
    def take_ref(self) -> Variant: ...
    # override
    def unpack(self) -> Any: ...
    def unref(self) -> None: ...
    # override
    def __getitem__(self, key: Any) -> Any: ...
    # override
    def __len__(self) -> int: ...

class VariantBuilder(GObject.GBoxed):
    # override
    def __init__(self, type: VariantType): ...
    def add_value(self, value: Variant) -> None: ...
    def close(self) -> None: ...
    def end(self) -> Variant: ...
    @classmethod
    def new(cls, type: VariantType) -> VariantBuilder: ...
    def open(self, type: VariantType) -> None: ...
    def ref(self) -> VariantBuilder: ...
    def unref(self) -> None: ...

class VariantDict(GObject.GBoxed):
    def clear(self) -> None: ...
    def contains(self, key: str) -> bool: ...
    def end(self) -> Variant: ...
    def insert_value(self, key: str, value: Variant) -> None: ...
    def lookup_value(
        self, key: str, expected_type: Optional[VariantType] = None
    ) -> Optional[Variant]: ...
    @classmethod
    def new(cls, from_asv: Optional[Variant] = None) -> VariantDict: ...
    def ref(self) -> VariantDict: ...
    def remove(self, key: str) -> bool: ...
    def unref(self) -> None: ...

class VariantType(GObject.GBoxed):
    # override
    def __init__(self, string: str): ...
    @staticmethod
    def checked_(arg0: str) -> VariantType: ...
    def copy(self) -> VariantType: ...
    def dup_string(self) -> str: ...
    def element(self) -> VariantType: ...
    def equal(self, type2: VariantType) -> bool: ...
    def first(self) -> VariantType: ...
    def free(self) -> None: ...
    def get_string_length(self) -> int: ...
    def hash(self) -> int: ...
    def is_array(self) -> bool: ...
    def is_basic(self) -> bool: ...
    def is_container(self) -> bool: ...
    def is_definite(self) -> bool: ...
    def is_dict_entry(self) -> bool: ...
    def is_maybe(self) -> bool: ...
    def is_subtype_of(self, supertype: VariantType) -> bool: ...
    def is_tuple(self) -> bool: ...
    def is_variant(self) -> bool: ...
    def key(self) -> VariantType: ...
    def n_items(self) -> int: ...
    @classmethod
    def new(cls, type_string: str) -> VariantType: ...
    @classmethod
    def new_array(cls, element: VariantType) -> VariantType: ...
    @classmethod
    def new_dict_entry(cls, key: VariantType, value: VariantType) -> VariantType: ...
    @classmethod
    def new_maybe(cls, element: VariantType) -> VariantType: ...
    @classmethod
    def new_tuple(cls, items: typing.Sequence[VariantType]) -> VariantType: ...
    def next(self) -> VariantType: ...
    @staticmethod
    def string_get_depth_(type_string: str) -> int: ...
    @staticmethod
    def string_is_valid(type_string: str) -> bool: ...
    @staticmethod
    def string_scan(string: str, limit: Optional[str] = None) -> Tuple[bool, str]: ...
    def value(self) -> VariantType: ...

class AsciiType(GObject.GFlags):
    ALNUM = 1
    ALPHA = 2
    CNTRL = 4
    DIGIT = 8
    GRAPH = 16
    LOWER = 32
    PRINT = 64
    PUNCT = 128
    SPACE = 256
    UPPER = 512
    XDIGIT = 1024

class FileSetContentsFlags(GObject.GFlags):
    CONSISTENT = 1
    DURABLE = 2
    NONE = 0
    ONLY_EXISTING = 4

class FileTest(GObject.GFlags):
    EXISTS = 16
    IS_DIR = 4
    IS_EXECUTABLE = 8
    IS_REGULAR = 1
    IS_SYMLINK = 2

class FormatSizeFlags(GObject.GFlags):
    BITS = 4
    DEFAULT = 0
    IEC_UNITS = 2
    LONG_FORMAT = 1
    ONLY_UNIT = 16
    ONLY_VALUE = 8

class HookFlagMask(GObject.GFlags):
    ACTIVE = 1
    IN_CALL = 2
    MASK = 15

class IOCondition(GObject.GFlags):
    ERR = 8
    HUP = 16
    IN = 1
    NVAL = 32
    OUT = 4
    PRI = 2

class IOFlags(GObject.GFlags):
    APPEND = 1
    GET_MASK = 31
    IS_READABLE = 4
    IS_SEEKABLE = 16
    IS_WRITABLE = 8
    IS_WRITEABLE = 8
    MASK = 31
    NONBLOCK = 2
    NONE = 0
    SET_MASK = 3

class KeyFileFlags(GObject.GFlags):
    KEEP_COMMENTS = 1
    KEEP_TRANSLATIONS = 2
    NONE = 0

class LogLevelFlags(GObject.GFlags):
    FLAG_FATAL = 2
    FLAG_RECURSION = 1
    LEVEL_CRITICAL = 8
    LEVEL_DEBUG = 128
    LEVEL_ERROR = 4
    LEVEL_INFO = 64
    LEVEL_MASK = 18446744073709551612
    LEVEL_MESSAGE = 32
    LEVEL_WARNING = 16

class MainContextFlags(GObject.GFlags):
    NONE = 0
    OWNERLESS_POLLING = 1

class MarkupCollectType(GObject.GFlags):
    BOOLEAN = 3
    INVALID = 0
    OPTIONAL = 65536
    STRDUP = 2
    STRING = 1
    TRISTATE = 4

class MarkupParseFlags(GObject.GFlags):
    DEFAULT_FLAGS = 0
    DO_NOT_USE_THIS_UNSUPPORTED_FLAG = 1
    IGNORE_QUALIFIED = 8
    PREFIX_ERROR_POSITION = 4
    TREAT_CDATA_AS_TEXT = 2

class OptionFlags(GObject.GFlags):
    FILENAME = 16
    HIDDEN = 1
    IN_MAIN = 2
    NOALIAS = 64
    NONE = 0
    NO_ARG = 8
    OPTIONAL_ARG = 32
    REVERSE = 4

class RegexCompileFlags(GObject.GFlags):
    ANCHORED = 16
    BSR_ANYCRLF = 8388608
    CASELESS = 1
    DEFAULT = 0
    DOLLAR_ENDONLY = 32
    DOTALL = 4
    DUPNAMES = 524288
    EXTENDED = 8
    FIRSTLINE = 262144
    JAVASCRIPT_COMPAT = 33554432
    MULTILINE = 2
    NEWLINE_ANYCRLF = 5242880
    NEWLINE_CR = 1048576
    NEWLINE_CRLF = 3145728
    NEWLINE_LF = 2097152
    NO_AUTO_CAPTURE = 4096
    OPTIMIZE = 8192
    RAW = 2048
    UNGREEDY = 512

class RegexMatchFlags(GObject.GFlags):
    ANCHORED = 16
    BSR_ANY = 16777216
    BSR_ANYCRLF = 8388608
    DEFAULT = 0
    NEWLINE_ANY = 4194304
    NEWLINE_ANYCRLF = 5242880
    NEWLINE_CR = 1048576
    NEWLINE_CRLF = 3145728
    NEWLINE_LF = 2097152
    NOTBOL = 128
    NOTEMPTY = 1024
    NOTEMPTY_ATSTART = 268435456
    NOTEOL = 256
    PARTIAL = 32768
    PARTIAL_HARD = 134217728
    PARTIAL_SOFT = 32768

class SpawnFlags(GObject.GFlags):
    CHILD_INHERITS_STDERR = 1024
    CHILD_INHERITS_STDIN = 32
    CHILD_INHERITS_STDOUT = 512
    CLOEXEC_PIPES = 256
    DEFAULT = 0
    DO_NOT_REAP_CHILD = 2
    FILE_AND_ARGV_ZERO = 64
    LEAVE_DESCRIPTORS_OPEN = 1
    SEARCH_PATH = 4
    SEARCH_PATH_FROM_ENVP = 128
    STDERR_TO_DEV_NULL = 16
    STDIN_FROM_DEV_NULL = 2048
    STDOUT_TO_DEV_NULL = 8

class TestSubprocessFlags(GObject.GFlags):
    DEFAULT = 0
    INHERIT_STDERR = 4
    INHERIT_STDIN = 1
    INHERIT_STDOUT = 2

class TestTrapFlags(GObject.GFlags):
    DEFAULT = 0
    INHERIT_STDIN = 512
    SILENCE_STDERR = 256
    SILENCE_STDOUT = 128

class TraverseFlags(GObject.GFlags):
    ALL = 3
    LEAFS = 1
    LEAVES = 1
    MASK = 3
    NON_LEAFS = 2
    NON_LEAVES = 2

class UriFlags(GObject.GFlags):
    ENCODED = 8
    ENCODED_FRAGMENT = 128
    ENCODED_PATH = 64
    ENCODED_QUERY = 32
    HAS_AUTH_PARAMS = 4
    HAS_PASSWORD = 2
    NONE = 0
    NON_DNS = 16
    PARSE_RELAXED = 1
    SCHEME_NORMALIZE = 256

class UriHideFlags(GObject.GFlags):
    AUTH_PARAMS = 4
    FRAGMENT = 16
    NONE = 0
    PASSWORD = 2
    QUERY = 8
    USERINFO = 1

class UriParamsFlags(GObject.GFlags):
    CASE_INSENSITIVE = 1
    NONE = 0
    PARSE_RELAXED = 4
    WWW_FORM = 2

class BookmarkFileError(GObject.GEnum):
    APP_NOT_REGISTERED = 2
    FILE_NOT_FOUND = 7
    INVALID_URI = 0
    INVALID_VALUE = 1
    READ = 4
    UNKNOWN_ENCODING = 5
    URI_NOT_FOUND = 3
    WRITE = 6

class ChecksumType(GObject.GEnum):
    MD5 = 0
    SHA1 = 1
    SHA256 = 2
    SHA384 = 4
    SHA512 = 3

class ConvertError(GObject.GEnum):
    BAD_URI = 4
    EMBEDDED_NUL = 7
    FAILED = 2
    ILLEGAL_SEQUENCE = 1
    NOT_ABSOLUTE_PATH = 5
    NO_CONVERSION = 0
    NO_MEMORY = 6
    PARTIAL_INPUT = 3

class DateDMY(GObject.GEnum):
    DAY = 0
    MONTH = 1
    YEAR = 2

class DateMonth(GObject.GEnum):
    APRIL = 4
    AUGUST = 8
    BAD_MONTH = 0
    DECEMBER = 12
    FEBRUARY = 2
    JANUARY = 1
    JULY = 7
    JUNE = 6
    MARCH = 3
    MAY = 5
    NOVEMBER = 11
    OCTOBER = 10
    SEPTEMBER = 9

class DateWeekday(GObject.GEnum):
    BAD_WEEKDAY = 0
    FRIDAY = 5
    MONDAY = 1
    SATURDAY = 6
    SUNDAY = 7
    THURSDAY = 4
    TUESDAY = 2
    WEDNESDAY = 3

class ErrorType(GObject.GEnum):
    DIGIT_RADIX = 5
    FLOAT_MALFORMED = 7
    FLOAT_RADIX = 6
    NON_DIGIT_IN_CONST = 4
    UNEXP_EOF = 1
    UNEXP_EOF_IN_COMMENT = 3
    UNEXP_EOF_IN_STRING = 2
    UNKNOWN = 0

class FileError(GObject.GEnum):
    ACCES = 2
    AGAIN = 19
    BADF = 16
    EXIST = 0
    FAILED = 24
    FAULT = 10
    INTR = 20
    INVAL = 17
    IO = 21
    ISDIR = 1
    LOOP = 11
    MFILE = 14
    NAMETOOLONG = 3
    NFILE = 15
    NODEV = 7
    NOENT = 4
    NOMEM = 13
    NOSPC = 12
    NOSYS = 23
    NOTDIR = 5
    NXIO = 6
    PERM = 22
    PIPE = 18
    ROFS = 8
    TXTBSY = 9

class IOChannelError(GObject.GEnum):
    FAILED = 8
    FBIG = 0
    INVAL = 1
    IO = 2
    ISDIR = 3
    NOSPC = 4
    NXIO = 5
    OVERFLOW = 6
    PIPE = 7

class IOError(GObject.GEnum):
    AGAIN = 1
    INVAL = 2
    NONE = 0
    UNKNOWN = 3

class IOStatus(GObject.GEnum):
    AGAIN = 3
    EOF = 2
    ERROR = 0
    NORMAL = 1

class KeyFileError(GObject.GEnum):
    GROUP_NOT_FOUND = 4
    INVALID_VALUE = 5
    KEY_NOT_FOUND = 3
    NOT_FOUND = 2
    PARSE = 1
    UNKNOWN_ENCODING = 0

class LogWriterOutput(GObject.GEnum):
    HANDLED = 1
    UNHANDLED = 0

class MarkupError(GObject.GEnum):
    BAD_UTF8 = 0
    EMPTY = 1
    INVALID_CONTENT = 5
    MISSING_ATTRIBUTE = 6
    PARSE = 2
    UNKNOWN_ATTRIBUTE = 4
    UNKNOWN_ELEMENT = 3

class NormalizeMode(GObject.GEnum):
    ALL = 2
    ALL_COMPOSE = 3
    DEFAULT = 0
    DEFAULT_COMPOSE = 1
    NFC = 1
    NFD = 0
    NFKC = 3
    NFKD = 2

class NumberParserError(GObject.GEnum):
    INVALID = 0
    OUT_OF_BOUNDS = 1

class OnceStatus(GObject.GEnum):
    NOTCALLED = 0
    PROGRESS = 1
    READY = 2

class OptionArg(GObject.GEnum):
    CALLBACK = 3
    DOUBLE = 7
    FILENAME = 4
    FILENAME_ARRAY = 6
    INT = 2
    INT64 = 8
    NONE = 0
    STRING = 1
    STRING_ARRAY = 5

class OptionError(GObject.GEnum):
    BAD_VALUE = 1
    FAILED = 2
    UNKNOWN_OPTION = 0

class RegexError(GObject.GEnum):
    ASSERTION_EXPECTED = 128
    BACKTRACKING_CONTROL_VERB_ARGUMENT_FORBIDDEN = 159
    BACKTRACKING_CONTROL_VERB_ARGUMENT_REQUIRED = 166
    CHARACTER_VALUE_TOO_LARGE = 176
    COMPILE = 0
    DEFINE_REPETION = 155
    DUPLICATE_SUBPATTERN_NAME = 143
    EXPRESSION_TOO_LARGE = 120
    EXTRA_SUBPATTERN_NAME = 165
    HEX_CODE_TOO_LARGE = 134
    INCONSISTENT_NEWLINE_OPTIONS = 156
    INEXISTENT_SUBPATTERN_REFERENCE = 115
    INFINITE_LOOP = 140
    INTERNAL = 4
    INVALID_CONDITION = 135
    INVALID_CONTROL_CHAR = 168
    INVALID_DATA_CHARACTER = 164
    INVALID_ESCAPE_IN_CHARACTER_CLASS = 107
    INVALID_OCTAL_VALUE = 151
    INVALID_RELATIVE_REFERENCE = 158
    MALFORMED_CONDITION = 126
    MALFORMED_PROPERTY = 146
    MATCH = 3
    MEMORY_ERROR = 121
    MISSING_BACK_REFERENCE = 157
    MISSING_CONTROL_CHAR = 102
    MISSING_DIGIT = 163
    MISSING_NAME = 169
    MISSING_SUBPATTERN_NAME = 162
    MISSING_SUBPATTERN_NAME_TERMINATOR = 142
    NAME_TOO_LONG = 175
    NOTHING_TO_REPEAT = 109
    NOT_SUPPORTED_IN_CLASS = 171
    NUMBER_TOO_BIG = 161
    OPTIMIZE = 1
    POSIX_COLLATING_ELEMENTS_NOT_SUPPORTED = 131
    POSIX_NAMED_CLASS_OUTSIDE_CLASS = 113
    QUANTIFIERS_OUT_OF_ORDER = 104
    QUANTIFIER_TOO_BIG = 105
    RANGE_OUT_OF_ORDER = 108
    REPLACE = 2
    SINGLE_BYTE_MATCH_IN_LOOKBEHIND = 136
    STRAY_BACKSLASH = 101
    SUBPATTERN_NAME_TOO_LONG = 148
    TOO_MANY_BRANCHES_IN_DEFINE = 154
    TOO_MANY_CONDITIONAL_BRANCHES = 127
    TOO_MANY_FORWARD_REFERENCES = 172
    TOO_MANY_SUBPATTERNS = 149
    UNKNOWN_BACKTRACKING_CONTROL_VERB = 160
    UNKNOWN_POSIX_CLASS_NAME = 130
    UNKNOWN_PROPERTY = 147
    UNMATCHED_PARENTHESIS = 114
    UNRECOGNIZED_CHARACTER = 112
    UNRECOGNIZED_ESCAPE = 103
    UNTERMINATED_CHARACTER_CLASS = 106
    UNTERMINATED_COMMENT = 118
    VARIABLE_LENGTH_LOOKBEHIND = 125

class SeekType(GObject.GEnum):
    CUR = 0
    END = 2
    SET = 1

class ShellError(GObject.GEnum):
    BAD_QUOTING = 0
    EMPTY_STRING = 1
    FAILED = 2

class SliceConfig(GObject.GEnum):
    ALWAYS_MALLOC = 1
    BYPASS_MAGAZINES = 2
    CHUNK_SIZES = 5
    COLOR_INCREMENT = 4
    CONTENTION_COUNTER = 6
    WORKING_SET_MSECS = 3

class SpawnError(GObject.GEnum):
    ACCES = 3
    CHDIR = 2
    FAILED = 19
    FORK = 0
    INVAL = 16
    IO = 13
    ISDIR = 17
    LIBBAD = 18
    LOOP = 11
    MFILE = 15
    NAMETOOLONG = 7
    NFILE = 14
    NOENT = 8
    NOEXEC = 6
    NOMEM = 9
    NOTDIR = 10
    PERM = 4
    READ = 1
    TOO_BIG = 5
    TXTBUSY = 12

class TestFileType(GObject.GEnum):
    BUILT = 1
    DIST = 0

class TestLogType(GObject.GEnum):
    ERROR = 1
    LIST_CASE = 3
    MAX_RESULT = 8
    MESSAGE = 9
    MIN_RESULT = 7
    NONE = 0
    SKIP_CASE = 4
    START_BINARY = 2
    START_CASE = 5
    START_SUITE = 10
    STOP_CASE = 6
    STOP_SUITE = 11

class TestResult(GObject.GEnum):
    FAILURE = 2
    INCOMPLETE = 3
    SKIPPED = 1
    SUCCESS = 0

class ThreadError(GObject.GEnum):
    THREAD_ERROR_AGAIN = 0

class TimeType(GObject.GEnum):
    DAYLIGHT = 1
    STANDARD = 0
    UNIVERSAL = 2

class TokenType(GObject.GEnum):
    BINARY = 259
    CHAR = 258
    COMMA = 44
    COMMENT_MULTI = 269
    COMMENT_SINGLE = 268
    EOF = 0
    EQUAL_SIGN = 61
    ERROR = 257
    FLOAT = 263
    HEX = 262
    IDENTIFIER = 266
    IDENTIFIER_NULL = 267
    INT = 261
    LEFT_BRACE = 91
    LEFT_CURLY = 123
    LEFT_PAREN = 40
    NONE = 256
    OCTAL = 260
    RIGHT_BRACE = 93
    RIGHT_CURLY = 125
    RIGHT_PAREN = 41
    STRING = 264
    SYMBOL = 265

class TraverseType(GObject.GEnum):
    IN_ORDER = 0
    LEVEL_ORDER = 3
    POST_ORDER = 2
    PRE_ORDER = 1

class UnicodeBreakType(GObject.GEnum):
    AFTER = 10
    ALPHABETIC = 23
    AMBIGUOUS = 27
    BEFORE = 11
    BEFORE_AND_AFTER = 12
    CARRIAGE_RETURN = 1
    CLOSE_PARANTHESIS = 36
    CLOSE_PARENTHESIS = 36
    CLOSE_PUNCTUATION = 16
    COMBINING_MARK = 3
    COMPLEX_CONTEXT = 26
    CONDITIONAL_JAPANESE_STARTER = 37
    CONTINGENT = 8
    EMOJI_BASE = 40
    EMOJI_MODIFIER = 41
    EXCLAMATION = 18
    HANGUL_LVT_SYLLABLE = 35
    HANGUL_LV_SYLLABLE = 34
    HANGUL_L_JAMO = 31
    HANGUL_T_JAMO = 33
    HANGUL_V_JAMO = 32
    HEBREW_LETTER = 38
    HYPHEN = 13
    IDEOGRAPHIC = 19
    INFIX_SEPARATOR = 21
    INSEPARABLE = 6
    LINE_FEED = 2
    MANDATORY = 0
    NEXT_LINE = 29
    NON_BREAKING_GLUE = 7
    NON_STARTER = 14
    NUMERIC = 20
    OPEN_PUNCTUATION = 15
    POSTFIX = 25
    PREFIX = 24
    QUOTATION = 17
    REGIONAL_INDICATOR = 39
    SPACE = 9
    SURROGATE = 4
    SYMBOL = 22
    UNKNOWN = 28
    WORD_JOINER = 30
    ZERO_WIDTH_JOINER = 42
    ZERO_WIDTH_SPACE = 5

class UnicodeScript(GObject.GEnum):
    ADLAM = 132
    AHOM = 126
    ANATOLIAN_HIEROGLYPHS = 127
    ARABIC = 2
    ARMENIAN = 3
    AVESTAN = 78
    BALINESE = 62
    BAMUM = 79
    BASSA_VAH = 103
    BATAK = 93
    BENGALI = 4
    BHAIKSUKI = 133
    BOPOMOFO = 5
    BRAHMI = 94
    BRAILLE = 46
    BUGINESE = 55
    BUHID = 44
    CANADIAN_ABORIGINAL = 40
    CARIAN = 75
    CAUCASIAN_ALBANIAN = 104
    CHAKMA = 96
    CHAM = 72
    CHEROKEE = 6
    CHORASMIAN = 153
    COMMON = 0
    COPTIC = 7
    CUNEIFORM = 63
    CYPRIOT = 47
    CYPRO_MINOAN = 157
    CYRILLIC = 8
    DESERET = 9
    DEVANAGARI = 10
    DIVES_AKURU = 154
    DOGRA = 142
    DUPLOYAN = 105
    EGYPTIAN_HIEROGLYPHS = 80
    ELBASAN = 106
    ELYMAIC = 149
    ETHIOPIC = 11
    GEORGIAN = 12
    GLAGOLITIC = 56
    GOTHIC = 13
    GRANTHA = 107
    GREEK = 14
    GUJARATI = 15
    GUNJALA_GONDI = 143
    GURMUKHI = 16
    HAN = 17
    HANGUL = 18
    HANIFI_ROHINGYA = 144
    HANUNOO = 43
    HATRAN = 128
    HEBREW = 19
    HIRAGANA = 20
    IMPERIAL_ARAMAIC = 81
    INHERITED = 1
    INSCRIPTIONAL_PAHLAVI = 82
    INSCRIPTIONAL_PARTHIAN = 83
    INVALID_CODE = -1
    JAVANESE = 84
    KAITHI = 85
    KANNADA = 21
    KATAKANA = 22
    KAYAH_LI = 67
    KHAROSHTHI = 60
    KHITAN_SMALL_SCRIPT = 155
    KHMER = 23
    KHOJKI = 108
    KHUDAWADI = 109
    LAO = 24
    LATIN = 25
    LEPCHA = 68
    LIMBU = 48
    LINEAR_A = 110
    LINEAR_B = 51
    LISU = 86
    LYCIAN = 76
    LYDIAN = 77
    MAHAJANI = 111
    MAKASAR = 145
    MALAYALAM = 26
    MANDAIC = 95
    MANICHAEAN = 112
    MARCHEN = 134
    MASARAM_GONDI = 138
    MATH = 162
    MEDEFAIDRIN = 146
    MEETEI_MAYEK = 87
    MENDE_KIKAKUI = 113
    MEROITIC_CURSIVE = 97
    MEROITIC_HIEROGLYPHS = 98
    MIAO = 99
    MODI = 114
    MONGOLIAN = 27
    MRO = 115
    MULTANI = 129
    MYANMAR = 28
    NABATAEAN = 116
    NANDINAGARI = 150
    NEWA = 135
    NEW_TAI_LUE = 54
    NKO = 66
    NUSHU = 139
    NYIAKENG_PUACHUE_HMONG = 151
    OGHAM = 29
    OLD_HUNGARIAN = 130
    OLD_ITALIC = 30
    OLD_NORTH_ARABIAN = 117
    OLD_PERMIC = 118
    OLD_PERSIAN = 59
    OLD_SOGDIAN = 147
    OLD_SOUTH_ARABIAN = 88
    OLD_TURKIC = 89
    OLD_UYGHUR = 158
    OL_CHIKI = 73
    ORIYA = 31
    OSAGE = 136
    OSMANYA = 49
    PAHAWH_HMONG = 119
    PALMYRENE = 120
    PAU_CIN_HAU = 121
    PHAGS_PA = 65
    PHOENICIAN = 64
    PSALTER_PAHLAVI = 122
    REJANG = 69
    RUNIC = 32
    SAMARITAN = 90
    SAURASHTRA = 71
    SHARADA = 100
    SHAVIAN = 50
    SIDDHAM = 123
    SIGNWRITING = 131
    SINHALA = 33
    SOGDIAN = 148
    SORA_SOMPENG = 101
    SOYOMBO = 140
    SUNDANESE = 70
    SYLOTI_NAGRI = 58
    SYRIAC = 34
    TAGALOG = 42
    TAGBANWA = 45
    TAI_LE = 52
    TAI_THAM = 91
    TAI_VIET = 92
    TAKRI = 102
    TAMIL = 35
    TANGSA = 159
    TANGUT = 137
    TELUGU = 36
    THAANA = 37
    THAI = 38
    TIBETAN = 39
    TIFINAGH = 57
    TIRHUTA = 124
    TOTO = 160
    UGARITIC = 53
    UNKNOWN = 61
    VAI = 74
    VITHKUQI = 161
    WANCHO = 152
    WARANG_CITI = 125
    YEZIDI = 156
    YI = 41
    ZANABAZAR_SQUARE = 141

class UnicodeType(GObject.GEnum):
    CLOSE_PUNCTUATION = 18
    CONNECT_PUNCTUATION = 16
    CONTROL = 0
    CURRENCY_SYMBOL = 23
    DASH_PUNCTUATION = 17
    DECIMAL_NUMBER = 13
    ENCLOSING_MARK = 11
    FINAL_PUNCTUATION = 19
    FORMAT = 1
    INITIAL_PUNCTUATION = 20
    LETTER_NUMBER = 14
    LINE_SEPARATOR = 27
    LOWERCASE_LETTER = 5
    MATH_SYMBOL = 25
    MODIFIER_LETTER = 6
    MODIFIER_SYMBOL = 24
    NON_SPACING_MARK = 12
    OPEN_PUNCTUATION = 22
    OTHER_LETTER = 7
    OTHER_NUMBER = 15
    OTHER_PUNCTUATION = 21
    OTHER_SYMBOL = 26
    PARAGRAPH_SEPARATOR = 28
    PRIVATE_USE = 3
    SPACE_SEPARATOR = 29
    SPACING_MARK = 10
    SURROGATE = 4
    TITLECASE_LETTER = 8
    UNASSIGNED = 2
    UPPERCASE_LETTER = 9

class UriError(GObject.GEnum):
    BAD_AUTH_PARAMS = 4
    BAD_FRAGMENT = 9
    BAD_HOST = 5
    BAD_PASSWORD = 3
    BAD_PATH = 7
    BAD_PORT = 6
    BAD_QUERY = 8
    BAD_SCHEME = 1
    BAD_USER = 2
    FAILED = 0

class UserDirectory(GObject.GEnum):
    DIRECTORY_DESKTOP = 0
    DIRECTORY_DOCUMENTS = 1
    DIRECTORY_DOWNLOAD = 2
    DIRECTORY_MUSIC = 3
    DIRECTORY_PICTURES = 4
    DIRECTORY_PUBLIC_SHARE = 5
    DIRECTORY_TEMPLATES = 6
    DIRECTORY_VIDEOS = 7
    N_DIRECTORIES = 8

class VariantClass(GObject.GEnum):
    ARRAY = 97
    BOOLEAN = 98
    BYTE = 121
    DICT_ENTRY = 123
    DOUBLE = 100
    HANDLE = 104
    INT16 = 110
    INT32 = 105
    INT64 = 120
    MAYBE = 109
    OBJECT_PATH = 111
    SIGNATURE = 103
    STRING = 115
    TUPLE = 40
    UINT16 = 113
    UINT32 = 117
    UINT64 = 116
    VARIANT = 118

class VariantParseError(GObject.GEnum):
    BASIC_TYPE_EXPECTED = 1
    CANNOT_INFER_TYPE = 2
    DEFINITE_TYPE_EXPECTED = 3
    FAILED = 0
    INPUT_NOT_AT_END = 4
    INVALID_CHARACTER = 5
    INVALID_FORMAT_STRING = 6
    INVALID_OBJECT_PATH = 7
    INVALID_SIGNATURE = 8
    INVALID_TYPE_STRING = 9
    NO_COMMON_TYPE = 10
    NUMBER_OUT_OF_RANGE = 11
    NUMBER_TOO_BIG = 12
    RECURSION = 18
    TYPE_ERROR = 13
    UNEXPECTED_TOKEN = 14
    UNKNOWN_KEYWORD = 15
    UNTERMINATED_STRING_CONSTANT = 16
    VALUE_EXPECTED = 17
