from typing import Any
from typing import Callable
from typing import Literal
from typing import Optional
from typing import Sequence
from typing import Tuple
from typing import Type
from typing import TypeVar

from gi.repository import GLib
from gi.repository import GObject

ALLOCATOR_SYSMEM: str = "SystemMemory"
BUFFER_COPY_ALL: int = 0
BUFFER_COPY_METADATA: int = 0
BUFFER_OFFSET_NONE: int = 18446744073709551615
CAN_INLINE: int = 1
CAPS_FEATURE_MEMORY_SYSTEM_MEMORY: str = "memory:SystemMemory"
CLOCK_TIME_NONE: int = 18446744073709551615
DEBUG_BG_MASK: int = 240
DEBUG_FG_MASK: int = 15
DEBUG_FORMAT_MASK: int = 65280
ELEMENT_FACTORY_KLASS_DECODER: str = "Decoder"
ELEMENT_FACTORY_KLASS_DECRYPTOR: str = "Decryptor"
ELEMENT_FACTORY_KLASS_DEMUXER: str = "Demuxer"
ELEMENT_FACTORY_KLASS_DEPAYLOADER: str = "Depayloader"
ELEMENT_FACTORY_KLASS_ENCODER: str = "Encoder"
ELEMENT_FACTORY_KLASS_ENCRYPTOR: str = "Encryptor"
ELEMENT_FACTORY_KLASS_FORMATTER: str = "Formatter"
ELEMENT_FACTORY_KLASS_HARDWARE: str = "Hardware"
ELEMENT_FACTORY_KLASS_MEDIA_AUDIO: str = "Audio"
ELEMENT_FACTORY_KLASS_MEDIA_IMAGE: str = "Image"
ELEMENT_FACTORY_KLASS_MEDIA_METADATA: str = "Metadata"
ELEMENT_FACTORY_KLASS_MEDIA_SUBTITLE: str = "Subtitle"
ELEMENT_FACTORY_KLASS_MEDIA_VIDEO: str = "Video"
ELEMENT_FACTORY_KLASS_MUXER: str = "Muxer"
ELEMENT_FACTORY_KLASS_PARSER: str = "Parser"
ELEMENT_FACTORY_KLASS_PAYLOADER: str = "Payloader"
ELEMENT_FACTORY_KLASS_SINK: str = "Sink"
ELEMENT_FACTORY_KLASS_SRC: str = "Source"
ELEMENT_FACTORY_TYPE_ANY: int = 562949953421311
ELEMENT_FACTORY_TYPE_AUDIOVIDEO_SINKS: int = 3940649673949188
ELEMENT_FACTORY_TYPE_AUDIO_ENCODER: int = 1125899906842626
ELEMENT_FACTORY_TYPE_DECODABLE: int = 1377
ELEMENT_FACTORY_TYPE_DECODER: int = 1
ELEMENT_FACTORY_TYPE_DECRYPTOR: int = 1024
ELEMENT_FACTORY_TYPE_DEMUXER: int = 32
ELEMENT_FACTORY_TYPE_DEPAYLOADER: int = 256
ELEMENT_FACTORY_TYPE_ENCODER: int = 2
ELEMENT_FACTORY_TYPE_ENCRYPTOR: int = 2048
ELEMENT_FACTORY_TYPE_FORMATTER: int = 512
ELEMENT_FACTORY_TYPE_HARDWARE: int = 4096
ELEMENT_FACTORY_TYPE_MAX_ELEMENTS: int = 281474976710656
ELEMENT_FACTORY_TYPE_MEDIA_ANY: int = 18446462598732840960
ELEMENT_FACTORY_TYPE_MEDIA_AUDIO: int = 1125899906842624
ELEMENT_FACTORY_TYPE_MEDIA_IMAGE: int = 2251799813685248
ELEMENT_FACTORY_TYPE_MEDIA_METADATA: int = 9007199254740992
ELEMENT_FACTORY_TYPE_MEDIA_SUBTITLE: int = 4503599627370496
ELEMENT_FACTORY_TYPE_MEDIA_VIDEO: int = 562949953421312
ELEMENT_FACTORY_TYPE_MUXER: int = 16
ELEMENT_FACTORY_TYPE_PARSER: int = 64
ELEMENT_FACTORY_TYPE_PAYLOADER: int = 128
ELEMENT_FACTORY_TYPE_SINK: int = 4
ELEMENT_FACTORY_TYPE_SRC: int = 8
ELEMENT_FACTORY_TYPE_VIDEO_ENCODER: int = 2814749767106562
ELEMENT_METADATA_AUTHOR: str = "author"
ELEMENT_METADATA_DESCRIPTION: str = "description"
ELEMENT_METADATA_DOC_URI: str = "doc-uri"
ELEMENT_METADATA_ICON_NAME: str = "icon-name"
ELEMENT_METADATA_KLASS: str = "klass"
ELEMENT_METADATA_LONGNAME: str = "long-name"
EVENT_NUM_SHIFT: int = 8
EVENT_TYPE_BOTH: int = 0
FLAG_SET_MASK_EXACT: int = 4294967295
FORMAT_PERCENT_MAX: int = 1000000
FORMAT_PERCENT_SCALE: int = 10000
GROUP_ID_INVALID: int = 0
LICENSE_UNKNOWN: str = "unknown"
LOCK_FLAG_READWRITE: int = 0
MAP_READWRITE: int = 0
META_TAG_MEMORY_REFERENCE_STR: str = "memory-reference"
META_TAG_MEMORY_STR: str = "memory"
MSECOND: int = 1000000
NSECOND: int = 1
PARAM_CONDITIONALLY_AVAILABLE: int = 16384
PARAM_CONTROLLABLE: int = 512
PARAM_DOC_SHOW_DEFAULT: int = 8192
PARAM_MUTABLE_PAUSED: int = 2048
PARAM_MUTABLE_PLAYING: int = 4096
PARAM_MUTABLE_READY: int = 1024
PARAM_USER_SHIFT: int = 65536
PROTECTION_SYSTEM_ID_CAPS_FIELD: str = "protection-system"
PROTECTION_UNSPECIFIED_SYSTEM_ID: str = "unspecified-system-id"
QUERY_NUM_SHIFT: int = 8
QUERY_TYPE_BOTH: int = 0
SECOND: int = 1000000000
SEGMENT_INSTANT_FLAGS: int = 912
SEQNUM_INVALID: int = 0
TAG_ALBUM: str = "album"
TAG_ALBUM_ARTIST: str = "album-artist"
TAG_ALBUM_ARTIST_SORTNAME: str = "album-artist-sortname"
TAG_ALBUM_GAIN: str = "replaygain-album-gain"
TAG_ALBUM_PEAK: str = "replaygain-album-peak"
TAG_ALBUM_SORTNAME: str = "album-sortname"
TAG_ALBUM_VOLUME_COUNT: str = "album-disc-count"
TAG_ALBUM_VOLUME_NUMBER: str = "album-disc-number"
TAG_APPLICATION_DATA: str = "application-data"
TAG_APPLICATION_NAME: str = "application-name"
TAG_ARTIST: str = "artist"
TAG_ARTIST_SORTNAME: str = "artist-sortname"
TAG_ATTACHMENT: str = "attachment"
TAG_AUDIO_CODEC: str = "audio-codec"
TAG_BEATS_PER_MINUTE: str = "beats-per-minute"
TAG_BITRATE: str = "bitrate"
TAG_CODEC: str = "codec"
TAG_COMMENT: str = "comment"
TAG_COMPOSER: str = "composer"
TAG_COMPOSER_SORTNAME: str = "composer-sortname"
TAG_CONDUCTOR: str = "conductor"
TAG_CONTACT: str = "contact"
TAG_CONTAINER_FORMAT: str = "container-format"
TAG_COPYRIGHT: str = "copyright"
TAG_COPYRIGHT_URI: str = "copyright-uri"
TAG_DATE: str = "date"
TAG_DATE_TIME: str = "datetime"
TAG_DESCRIPTION: str = "description"
TAG_DEVICE_MANUFACTURER: str = "device-manufacturer"
TAG_DEVICE_MODEL: str = "device-model"
TAG_DURATION: str = "duration"
TAG_ENCODED_BY: str = "encoded-by"
TAG_ENCODER: str = "encoder"
TAG_ENCODER_VERSION: str = "encoder-version"
TAG_EXTENDED_COMMENT: str = "extended-comment"
TAG_GENRE: str = "genre"
TAG_GEO_LOCATION_CAPTURE_DIRECTION: str = "geo-location-capture-direction"
TAG_GEO_LOCATION_CITY: str = "geo-location-city"
TAG_GEO_LOCATION_COUNTRY: str = "geo-location-country"
TAG_GEO_LOCATION_ELEVATION: str = "geo-location-elevation"
TAG_GEO_LOCATION_HORIZONTAL_ERROR: str = "geo-location-horizontal-error"
TAG_GEO_LOCATION_LATITUDE: str = "geo-location-latitude"
TAG_GEO_LOCATION_LONGITUDE: str = "geo-location-longitude"
TAG_GEO_LOCATION_MOVEMENT_DIRECTION: str = "geo-location-movement-direction"
TAG_GEO_LOCATION_MOVEMENT_SPEED: str = "geo-location-movement-speed"
TAG_GEO_LOCATION_NAME: str = "geo-location-name"
TAG_GEO_LOCATION_SUBLOCATION: str = "geo-location-sublocation"
TAG_GROUPING: str = "grouping"
TAG_HOMEPAGE: str = "homepage"
TAG_IMAGE: str = "image"
TAG_IMAGE_ORIENTATION: str = "image-orientation"
TAG_INTERPRETED_BY: str = "interpreted-by"
TAG_ISRC: str = "isrc"
TAG_KEYWORDS: str = "keywords"
TAG_LANGUAGE_CODE: str = "language-code"
TAG_LANGUAGE_NAME: str = "language-name"
TAG_LICENSE: str = "license"
TAG_LICENSE_URI: str = "license-uri"
TAG_LOCATION: str = "location"
TAG_LYRICS: str = "lyrics"
TAG_MAXIMUM_BITRATE: str = "maximum-bitrate"
TAG_MIDI_BASE_NOTE: str = "midi-base-note"
TAG_MINIMUM_BITRATE: str = "minimum-bitrate"
TAG_NOMINAL_BITRATE: str = "nominal-bitrate"
TAG_ORGANIZATION: str = "organization"
TAG_PERFORMER: str = "performer"
TAG_PREVIEW_IMAGE: str = "preview-image"
TAG_PRIVATE_DATA: str = "private-data"
TAG_PUBLISHER: str = "publisher"
TAG_REFERENCE_LEVEL: str = "replaygain-reference-level"
TAG_SERIAL: str = "serial"
TAG_SHOW_EPISODE_NUMBER: str = "show-episode-number"
TAG_SHOW_NAME: str = "show-name"
TAG_SHOW_SEASON_NUMBER: str = "show-season-number"
TAG_SHOW_SORTNAME: str = "show-sortname"
TAG_SUBTITLE_CODEC: str = "subtitle-codec"
TAG_TITLE: str = "title"
TAG_TITLE_SORTNAME: str = "title-sortname"
TAG_TRACK_COUNT: str = "track-count"
TAG_TRACK_GAIN: str = "replaygain-track-gain"
TAG_TRACK_NUMBER: str = "track-number"
TAG_TRACK_PEAK: str = "replaygain-track-peak"
TAG_USER_RATING: str = "user-rating"
TAG_VERSION: str = "version"
TAG_VIDEO_CODEC: str = "video-codec"
TOC_REPEAT_COUNT_INFINITE: int = -1
URI_NO_PORT: int = 0
USECOND: int = 1000
VALUE_EQUAL: int = 0
VALUE_GREATER_THAN: int = 1
VALUE_LESS_THAN: int = -1
VALUE_UNORDERED: int = 2
VERSION_MAJOR: int = 1
VERSION_MICRO: int = 5
VERSION_MINOR: int = 20
VERSION_NANO: int = 0
_lock = ...  # FIXME Constant
_namespace: str = "Gst"
_version: str = "1.0"

def buffer_get_max_memory() -> int: ...
def caps_features_from_string(features: str) -> Optional[CapsFeatures]: ...
def caps_from_string(string: str) -> Optional[Caps]: ...
def core_error_quark() -> int: ...
def debug_add_log_function(func: Callable[..., None], *user_data: Any) -> None: ...
def debug_add_ring_buffer_logger(
    max_size_per_thread: int, thread_timeout: int
) -> None: ...
def debug_bin_to_dot_data(bin: Bin, details: DebugGraphDetails) -> str: ...
def debug_bin_to_dot_file(
    bin: Bin, details: DebugGraphDetails, file_name: str
) -> None: ...
def debug_bin_to_dot_file_with_ts(
    bin: Bin, details: DebugGraphDetails, file_name: str
) -> None: ...
def debug_construct_term_color(colorinfo: int) -> str: ...
def debug_construct_win_color(colorinfo: int) -> int: ...
def debug_get_all_categories() -> list[DebugCategory]: ...
def debug_get_color_mode() -> DebugColorMode: ...
def debug_get_default_threshold() -> DebugLevel: ...
def debug_get_stack_trace(flags: StackTraceFlags) -> Optional[str]: ...
def debug_is_active() -> bool: ...
def debug_is_colored() -> bool: ...
def debug_level_get_name(level: DebugLevel) -> str: ...
def debug_log_default(
    category: DebugCategory,
    level: DebugLevel,
    file: str,
    function: str,
    line: int,
    object: Optional[GObject.Object],
    message: DebugMessage,
    user_data: None,
) -> None: ...
def debug_log_get_line(
    category: DebugCategory,
    level: DebugLevel,
    file: str,
    function: str,
    line: int,
    object: Optional[GObject.Object],
    message: DebugMessage,
) -> str: ...
def debug_log_literal(
    category: DebugCategory,
    level: DebugLevel,
    file: str,
    function: str,
    line: int,
    object: Optional[GObject.Object],
    message_string: str,
) -> None: ...
def debug_print_stack_trace() -> None: ...
def debug_remove_log_function(func: Optional[Callable[..., None]] = None) -> int: ...
def debug_remove_log_function_by_data(data: None) -> int: ...
def debug_remove_ring_buffer_logger() -> None: ...
def debug_ring_buffer_logger_get_logs() -> list[str]: ...
def debug_set_active(active: bool) -> None: ...
def debug_set_color_mode(mode: DebugColorMode) -> None: ...
def debug_set_color_mode_from_string(mode: str) -> None: ...
def debug_set_colored(colored: bool) -> None: ...
def debug_set_default_threshold(level: DebugLevel) -> None: ...
def debug_set_threshold_for_name(name: str, level: DebugLevel) -> None: ...
def debug_set_threshold_from_string(list: str, reset: bool) -> None: ...
def debug_unset_threshold_for_name(name: str) -> None: ...
def deinit() -> None: ...
def dynamic_type_register(plugin: Plugin, type: Type) -> bool: ...
def error_get_message(domain: int, code: int) -> str: ...
def event_type_get_flags(type: EventType) -> EventTypeFlags: ...
def event_type_get_name(type: EventType) -> str: ...
def event_type_to_quark(type: EventType) -> int: ...
def filename_to_uri(filename: str) -> str: ...
def flow_get_name(ret: FlowReturn) -> str: ...
def flow_to_quark(ret: FlowReturn) -> int: ...
def format_get_by_nick(nick: str) -> Format: ...
def format_get_details(format: Format) -> Optional[FormatDefinition]: ...
def format_get_name(format: Format) -> Optional[str]: ...
def format_iterate_definitions() -> Iterator: ...
def format_register(nick: str, description: str) -> Format: ...
def format_to_quark(format: Format) -> int: ...
def formats_contains(formats: Sequence[Format], format: Format) -> bool: ...
def get_main_executable_path() -> Optional[str]: ...

# override
def init(argv: Optional[list[str]] = None) -> None: ...

# override
def init_check(argv: Optional[list[str]] = None) -> Tuple[bool, list[str]]: ...
def is_caps_features(obj: None) -> bool: ...
def is_initialized() -> bool: ...
def library_error_quark() -> int: ...
def message_type_get_name(type: MessageType) -> str: ...
def message_type_to_quark(type: MessageType) -> int: ...
def meta_api_type_get_tags(api: Type) -> list[str]: ...
def meta_api_type_has_tag(api: Type, tag: int) -> bool: ...
def meta_api_type_register(api: str, tags: Sequence[str]) -> Type: ...
def meta_get_info(impl: str) -> Optional[MetaInfo]: ...
def meta_register(
    api: Type,
    impl: str,
    size: int,
    init_func: Callable[[Meta, None, Buffer], bool],
    free_func: Callable[[Meta, Buffer], None],
    transform_func: Callable[[Buffer, Meta, Buffer, int, None], bool],
) -> MetaInfo: ...
def meta_register_custom(
    name: str,
    tags: Sequence[str],
    transform_func: Optional[Callable[..., bool]] = None,
    *user_data: Any,
) -> MetaInfo: ...
def mini_object_replace(
    newdata: Optional[MiniObject] = None,
) -> Tuple[bool, MiniObject]: ...
def mini_object_take(newdata: MiniObject) -> Tuple[bool, MiniObject]: ...
def pad_mode_get_name(mode: PadMode) -> str: ...
def param_spec_array(
    name: str,
    nick: str,
    blurb: str,
    element_spec: GObject.ParamSpec,
    flags: GObject.ParamFlags,
) -> GObject.ParamSpec: ...
def param_spec_fraction(
    name: str,
    nick: str,
    blurb: str,
    min_num: int,
    min_denom: int,
    max_num: int,
    max_denom: int,
    default_num: int,
    default_denom: int,
    flags: GObject.ParamFlags,
) -> Optional[GObject.ParamSpec]: ...
def parent_buffer_meta_api_get_type() -> Type: ...
def parent_buffer_meta_get_info() -> MetaInfo: ...
def parse_bin_from_description(
    bin_description: str, ghost_unlinked_pads: bool
) -> Bin: ...
def parse_bin_from_description_full(
    bin_description: str,
    ghost_unlinked_pads: bool,
    context: Optional[ParseContext],
    flags: ParseFlags,
) -> Element: ...
def parse_error_quark() -> int: ...
def parse_launch(pipeline_description: str) -> Element: ...
def parse_launch_full(
    pipeline_description: str, context: Optional[ParseContext], flags: ParseFlags
) -> Element: ...
def parse_launchv(argv: Sequence[str]) -> Element: ...
def parse_launchv_full(
    argv: Sequence[str], context: Optional[ParseContext], flags: ParseFlags
) -> Element: ...
def plugin_error_quark() -> int: ...
def preset_get_app_dir() -> Optional[str]: ...
def preset_set_app_dir(app_dir: str) -> bool: ...
def protection_filter_systems_by_available_decryptors(
    system_identifiers: Sequence[str],
) -> Optional[list[str]]: ...
def protection_meta_api_get_type() -> Type: ...
def protection_meta_get_info() -> MetaInfo: ...
def protection_select_system(system_identifiers: Sequence[str]) -> Optional[str]: ...
def query_type_get_flags(type: QueryType) -> QueryTypeFlags: ...
def query_type_get_name(type: QueryType) -> str: ...
def query_type_to_quark(type: QueryType) -> int: ...
def reference_timestamp_meta_api_get_type() -> Type: ...
def reference_timestamp_meta_get_info() -> MetaInfo: ...
def resource_error_quark() -> int: ...
def segtrap_is_enabled() -> bool: ...
def segtrap_set_enabled(enabled: bool) -> None: ...
def state_change_get_name(transition: StateChange) -> str: ...
def static_caps_get_type() -> Type: ...
def static_pad_template_get_type() -> Type: ...
def stream_error_quark() -> int: ...
def stream_type_get_name(stype: StreamType) -> str: ...
def structure_take(newstr: Optional[Structure] = None) -> Tuple[bool, Structure]: ...
def tag_exists(tag: str) -> bool: ...
def tag_get_description(tag: str) -> Optional[str]: ...
def tag_get_flag(tag: str) -> TagFlag: ...
def tag_get_nick(tag: str) -> Optional[str]: ...
def tag_get_type(tag: str) -> Type: ...
def tag_is_fixed(tag: str) -> bool: ...
def tag_list_copy_value(list: TagList, tag: str) -> Tuple[bool, Any]: ...
def tag_merge_strings_with_comma(src: Any) -> Any: ...
def tag_merge_use_first(src: Any) -> Any: ...
def toc_entry_type_get_nick(type: TocEntryType) -> str: ...
def tracing_get_active_tracers() -> list[Tracer]: ...
def tracing_register_hook(
    tracer: Tracer, detail: str, func: Callable[[], None]
) -> None: ...
def type_find_get_type() -> Type: ...
def type_find_register(
    plugin: Optional[Plugin],
    name: str,
    rank: int,
    func: Callable[..., None],
    extensions: Optional[str] = None,
    possible_caps: Optional[Caps] = None,
    *data: Any,
) -> bool: ...
def type_is_plugin_api(type: Type) -> Tuple[bool, PluginAPIFlags]: ...
def type_mark_as_plugin_api(type: Type, flags: PluginAPIFlags) -> None: ...
def update_registry() -> bool: ...
def uri_construct(protocol: str, location: str) -> str: ...
def uri_error_quark() -> int: ...
def uri_from_string(uri: str) -> Optional[Uri]: ...
def uri_from_string_escaped(uri: str) -> Optional[Uri]: ...
def uri_get_location(uri: str) -> Optional[str]: ...
def uri_get_protocol(uri: str) -> Optional[str]: ...
def uri_has_protocol(uri: str, protocol: str) -> bool: ...
def uri_is_valid(uri: str) -> bool: ...
def uri_join_strings(base_uri: str, ref_uri: str) -> str: ...
def uri_protocol_is_supported(type: URIType, protocol: str) -> bool: ...
def uri_protocol_is_valid(protocol: str) -> bool: ...
def util_array_binary_search(
    array: None,
    num_elements: int,
    element_size: int,
    search_func: Callable[..., int],
    mode: SearchMode,
    search_data: None,
    *user_data: Any,
) -> None: ...
def util_double_to_fraction(src: float) -> Tuple[int, int]: ...
def util_dump_buffer(buf: Buffer) -> None: ...
def util_dump_mem(mem: Sequence[int]) -> None: ...
def util_fraction_add(
    a_n: int, a_d: int, b_n: int, b_d: int
) -> Tuple[bool, int, int]: ...
def util_fraction_compare(a_n: int, a_d: int, b_n: int, b_d: int) -> int: ...
def util_fraction_multiply(
    a_n: int, a_d: int, b_n: int, b_d: int
) -> Tuple[bool, int, int]: ...
def util_fraction_to_double(src_n: int, src_d: int) -> float: ...
def util_gdouble_to_guint64(value: float) -> int: ...
def util_get_object_array(
    object: GObject.Object, name: str
) -> Tuple[bool, GObject.ValueArray]: ...
def util_get_timestamp() -> int: ...
def util_greatest_common_divisor(a: int, b: int) -> int: ...
def util_greatest_common_divisor_int64(a: int, b: int) -> int: ...
def util_group_id_next() -> int: ...
def util_guint64_to_gdouble(value: int) -> float: ...
def util_seqnum_compare(s1: int, s2: int) -> int: ...
def util_seqnum_next() -> int: ...
def util_set_object_arg(object: GObject.Object, name: str, value: str) -> None: ...
def util_set_object_array(
    object: GObject.Object, name: str, array: GObject.ValueArray
) -> bool: ...
def util_set_value_from_string(value_str: str) -> Any: ...
def util_uint64_scale(val: int, num: int, denom: int) -> int: ...
def util_uint64_scale_ceil(val: int, num: int, denom: int) -> int: ...
def util_uint64_scale_int(val: int, num: int, denom: int) -> int: ...
def util_uint64_scale_int_ceil(val: int, num: int, denom: int) -> int: ...
def util_uint64_scale_int_round(val: int, num: int, denom: int) -> int: ...
def util_uint64_scale_round(val: int, num: int, denom: int) -> int: ...
def value_can_compare(value1: Any, value2: Any) -> bool: ...
def value_can_intersect(value1: Any, value2: Any) -> bool: ...
def value_can_subtract(minuend: Any, subtrahend: Any) -> bool: ...
def value_can_union(value1: Any, value2: Any) -> bool: ...
def value_compare(value1: Any, value2: Any) -> int: ...
def value_deserialize(src: str) -> Tuple[bool, Any]: ...
def value_deserialize_with_pspec(
    src: str, pspec: Optional[GObject.ParamSpec] = None
) -> Tuple[bool, Any]: ...
def value_fixate(dest: Any, src: Any) -> bool: ...
def value_fraction_multiply(product: Any, factor1: Any, factor2: Any) -> bool: ...
def value_fraction_subtract(dest: Any, minuend: Any, subtrahend: Any) -> bool: ...
def value_get_bitmask(value: Any) -> int: ...
def value_get_caps(value: Any) -> Caps: ...
def value_get_caps_features(value: Any) -> CapsFeatures: ...
def value_get_double_range_max(value: Any) -> float: ...
def value_get_double_range_min(value: Any) -> float: ...
def value_get_flagset_flags(value: Any) -> int: ...
def value_get_flagset_mask(value: Any) -> int: ...
def value_get_fraction_denominator(value: Any) -> int: ...
def value_get_fraction_numerator(value: Any) -> int: ...
def value_get_fraction_range_max(value: Any) -> Optional[Any]: ...
def value_get_fraction_range_min(value: Any) -> Optional[Any]: ...
def value_get_int64_range_max(value: Any) -> int: ...
def value_get_int64_range_min(value: Any) -> int: ...
def value_get_int64_range_step(value: Any) -> int: ...
def value_get_int_range_max(value: Any) -> int: ...
def value_get_int_range_min(value: Any) -> int: ...
def value_get_int_range_step(value: Any) -> int: ...
def value_get_structure(value: Any) -> Structure: ...
def value_init_and_copy(src: Any) -> Any: ...
def value_intersect(value1: Any, value2: Any) -> Tuple[bool, Any]: ...
def value_is_fixed(value: Any) -> bool: ...
def value_is_subset(value1: Any, value2: Any) -> bool: ...
def value_register(table: ValueTable) -> None: ...
def value_serialize(value: Any) -> Optional[str]: ...
def value_set_bitmask(value: Any, bitmask: int) -> None: ...
def value_set_caps(value: Any, caps: Caps) -> None: ...
def value_set_caps_features(value: Any, features: CapsFeatures) -> None: ...
def value_set_double_range(value: Any, start: float, end: float) -> None: ...
def value_set_flagset(value: Any, flags: int, mask: int) -> None: ...
def value_set_fraction(value: Any, numerator: int, denominator: int) -> None: ...
def value_set_fraction_range(value: Any, start: Any, end: Any) -> None: ...
def value_set_fraction_range_full(
    value: Any,
    numerator_start: int,
    denominator_start: int,
    numerator_end: int,
    denominator_end: int,
) -> None: ...
def value_set_int64_range(value: Any, start: int, end: int) -> None: ...
def value_set_int64_range_step(value: Any, start: int, end: int, step: int) -> None: ...
def value_set_int_range(value: Any, start: int, end: int) -> None: ...
def value_set_int_range_step(value: Any, start: int, end: int, step: int) -> None: ...
def value_set_structure(value: Any, structure: Structure) -> None: ...
def value_subtract(minuend: Any, subtrahend: Any) -> Tuple[bool, Any]: ...
def value_union(value1: Any, value2: Any) -> Tuple[bool, Any]: ...
def version() -> Tuple[int, int, int, int]: ...
def version_string() -> str: ...

class AllocationParams(GObject.GBoxed):
    flags: MemoryFlags = ...
    align: int = ...
    prefix: int = ...
    padding: int = ...
    _gst_reserved: list[None] = ...
    def copy(self) -> Optional[AllocationParams]: ...
    def free(self) -> None: ...
    def init(self) -> None: ...
    @classmethod
    def new(cls) -> AllocationParams: ...

class Allocator(Object):
    class Props:
        name: Optional[str]
        parent: Optional[Object]
    props: Props = ...
    object: Object = ...
    mem_type: str = ...
    mem_map: Callable[[Memory, int, MapFlags], None] = ...
    mem_unmap: Callable[[Memory], None] = ...
    mem_copy: Callable[[Memory, int, int], Memory] = ...
    mem_share: Callable[[Memory, int, int], Memory] = ...
    mem_is_span: Callable[[Memory, Memory, int], bool] = ...
    mem_map_full: Callable[[Memory, MapInfo, int], None] = ...
    mem_unmap_full: Callable[[Memory, MapInfo], None] = ...
    _gst_reserved: list[None] = ...
    priv: AllocatorPrivate = ...
    def __init__(self, name: str = ..., parent: Object = ...): ...
    def alloc(
        self, size: int, params: Optional[AllocationParams] = None
    ) -> Optional[Memory]: ...
    def do_alloc(
        self, size: int, params: Optional[AllocationParams] = None
    ) -> Optional[Memory]: ...
    def do_free(self, memory: Memory) -> None: ...
    @staticmethod
    def find(name: Optional[str] = None) -> Optional[Allocator]: ...
    def free(self, memory: Memory) -> None: ...
    @staticmethod
    def register(name: str, allocator: Allocator) -> None: ...
    def set_default(self) -> None: ...

class AllocatorClass(GObject.GPointer):
    object_class: ObjectClass = ...
    alloc: Callable[
        [Optional[Allocator], int, Optional[AllocationParams]], Optional[Memory]
    ] = ...
    free: Callable[[Allocator, Memory], None] = ...
    _gst_reserved: list[None] = ...

class AllocatorPrivate(GObject.GPointer): ...

class AtomicQueue(GObject.GBoxed):
    def length(self) -> int: ...
    @classmethod
    def new(cls, initial_size: int) -> AtomicQueue: ...
    def peek(self) -> None: ...
    def pop(self) -> None: ...
    def push(self, data: None) -> None: ...
    def ref(self) -> None: ...
    def unref(self) -> None: ...

class Bin(Element, ChildProxy):
    class Props:
        async_handling: bool
        message_forward: bool
        name: Optional[str]
        parent: Optional[Object]
    props: Props = ...
    element: Element = ...
    numchildren: int = ...
    children: list[Element] = ...
    children_cookie: int = ...
    child_bus: Bus = ...
    messages: list[Message] = ...
    polling: bool = ...
    state_dirty: bool = ...
    clock_dirty: bool = ...
    provided_clock: Clock = ...
    clock_provider: Element = ...
    priv: BinPrivate = ...
    _gst_reserved: list[None] = ...
    def __init__(
        self,
        async_handling: bool = ...,
        message_forward: bool = ...,
        name: str = ...,
        parent: Object = ...,
    ): ...
    def add(self, element: Element) -> bool: ...
    def do_add_element(self, element: Element) -> bool: ...
    def do_deep_element_added(self, sub_bin: Bin, child: Element) -> None: ...
    def do_deep_element_removed(self, sub_bin: Bin, child: Element) -> None: ...
    def do_do_latency(self) -> bool: ...
    def do_element_added(self, child: Element) -> None: ...
    def do_element_removed(self, child: Element) -> None: ...
    def do_handle_message(self, message: Message) -> None: ...
    def do_remove_element(self, element: Element) -> bool: ...
    def find_unlinked_pad(self, direction: PadDirection) -> Optional[Pad]: ...
    def get_by_interface(self, iface: Type) -> Optional[Element]: ...
    def get_by_name(self, name: str) -> Optional[Element]: ...
    def get_by_name_recurse_up(self, name: str) -> Optional[Element]: ...
    def get_suppressed_flags(self) -> ElementFlags: ...
    def iterate_all_by_element_factory_name(
        self, factory_name: str
    ) -> Optional[Iterator]: ...
    def iterate_all_by_interface(self, iface: Type) -> Optional[Iterator]: ...
    def iterate_elements(self) -> Optional[Iterator]: ...
    def iterate_recurse(self) -> Optional[Iterator]: ...
    def iterate_sinks(self) -> Optional[Iterator]: ...
    def iterate_sorted(self) -> Optional[Iterator]: ...
    def iterate_sources(self) -> Optional[Iterator]: ...
    @classmethod
    def new(cls, name: Optional[str] = None) -> Bin: ...
    def recalculate_latency(self) -> bool: ...
    def remove(self, element: Element) -> bool: ...
    def set_suppressed_flags(self, flags: ElementFlags) -> None: ...
    def sync_children_states(self) -> bool: ...

class BinClass(GObject.GPointer):
    parent_class: ElementClass = ...
    pool: GLib.ThreadPool = ...
    element_added: Callable[[Bin, Element], None] = ...
    element_removed: Callable[[Bin, Element], None] = ...
    add_element: Callable[[Bin, Element], bool] = ...
    remove_element: Callable[[Bin, Element], bool] = ...
    handle_message: Callable[[Bin, Message], None] = ...
    do_latency: Callable[[Bin], bool] = ...
    deep_element_added: Callable[[Bin, Bin, Element], None] = ...
    deep_element_removed: Callable[[Bin, Bin, Element], None] = ...
    _gst_reserved: list[None] = ...

class BinPrivate(GObject.GPointer): ...
class Bitmask: ...

class Buffer(GObject.GBoxed):
    mini_object: MiniObject = ...
    pool: BufferPool = ...
    pts: int = ...
    dts: int = ...
    duration: int = ...
    offset: int = ...
    offset_end: int = ...
    def add_custom_meta(self, name: str) -> Optional[CustomMeta]: ...
    def add_meta(self, info: MetaInfo, params: None) -> Optional[Meta]: ...
    def add_parent_buffer_meta(self, ref: Buffer) -> Optional[ParentBufferMeta]: ...
    def add_protection_meta(self, info: Structure) -> ProtectionMeta: ...
    def add_reference_timestamp_meta(
        self, reference: Caps, timestamp: int, duration: int
    ) -> Optional[ReferenceTimestampMeta]: ...
    def append(self, buf2: Buffer) -> Buffer: ...
    def append_memory(self, mem: Memory) -> None: ...
    def append_region(self, buf2: Buffer, offset: int, size: int) -> Buffer: ...
    def copy_deep(self) -> Buffer: ...
    def copy_into(
        self, src: Buffer, flags: BufferCopyFlags, offset: int, size: int
    ) -> bool: ...
    def copy_region(self, flags: BufferCopyFlags, offset: int, size: int) -> Buffer: ...
    def extract(self, offset: int) -> Tuple[int, bytes]: ...
    def extract_dup(self, offset: int, size: int) -> bytes: ...
    def fill(self, offset: int, src: Sequence[int]) -> int: ...
    def find_memory(self, offset: int, size: int) -> Tuple[bool, int, int, int]: ...
    def foreach_meta(
        self, func: Callable[..., Tuple[bool, Meta]], *user_data: Any
    ) -> bool: ...
    def get_all_memory(self) -> Optional[Memory]: ...
    def get_custom_meta(self, name: str) -> Optional[CustomMeta]: ...
    def get_flags(self) -> BufferFlags: ...
    @staticmethod
    def get_max_memory() -> int: ...
    def get_memory(self, idx: int) -> Optional[Memory]: ...
    def get_memory_range(self, idx: int, length: int) -> Optional[Memory]: ...
    def get_meta(self, api: Type) -> Optional[Meta]: ...
    def get_n_meta(self, api_type: Type) -> int: ...
    def get_reference_timestamp_meta(
        self, reference: Optional[Caps] = None
    ) -> Optional[ReferenceTimestampMeta]: ...
    def get_size(self) -> int: ...
    def get_sizes(self) -> Tuple[int, int, int]: ...
    def get_sizes_range(self, idx: int, length: int) -> Tuple[int, int, int]: ...
    def has_flags(self, flags: BufferFlags) -> bool: ...
    def insert_memory(self, idx: int, mem: Memory) -> None: ...
    def is_all_memory_writable(self) -> bool: ...
    def is_memory_range_writable(self, idx: int, length: int) -> bool: ...
    def map(self, flags: MapFlags) -> Tuple[bool, MapInfo]: ...
    def map_range(
        self, idx: int, length: int, flags: MapFlags
    ) -> Tuple[bool, MapInfo]: ...
    def memcmp(self, offset: int, mem: Sequence[int]) -> int: ...
    def memset(self, offset: int, val: int, size: int) -> int: ...
    def n_memory(self) -> int: ...
    @classmethod
    def new(cls) -> Buffer: ...
    @classmethod
    def new_allocate(
        cls,
        allocator: Optional[Allocator],
        size: int,
        params: Optional[AllocationParams] = None,
    ) -> Optional[Buffer]: ...
    @classmethod
    def new_memdup(cls, data: Sequence[int]) -> Buffer: ...
    @classmethod
    def new_wrapped(cls, data: Sequence[int]) -> Buffer: ...
    @classmethod
    def new_wrapped_bytes(cls, bytes: GLib.Bytes) -> Buffer: ...
    # override
    @classmethod
    def new_wrapped_full(
        cls,
        flags: MemoryFlags,
        data: Sequence[int],
        maxsize: int,
        offset: int,
        user_data: None,
        notify: Optional[Callable[[None], None]] = None,
        *_user_data: Any,
    ) -> Buffer: ...
    def peek_memory(self, idx: int) -> Optional[Memory]: ...
    def prepend_memory(self, mem: Memory) -> None: ...
    def remove_all_memory(self) -> None: ...
    def remove_memory(self, idx: int) -> None: ...
    def remove_memory_range(self, idx: int, length: int) -> None: ...
    def remove_meta(self, meta: Meta) -> bool: ...
    def replace_all_memory(self, mem: Memory) -> None: ...
    def replace_memory(self, idx: int, mem: Memory) -> None: ...
    def replace_memory_range(self, idx: int, length: int, mem: Memory) -> None: ...
    def resize(self, offset: int, size: int) -> None: ...
    def resize_range(self, idx: int, length: int, offset: int, size: int) -> bool: ...
    def set_flags(self, flags: BufferFlags) -> bool: ...
    def set_size(self, size: int) -> None: ...
    def unmap(self, info: MapInfo) -> None: ...
    def unset_flags(self, flags: BufferFlags) -> bool: ...

class BufferList(GObject.GBoxed):
    def calculate_size(self) -> int: ...
    def copy_deep(self) -> BufferList: ...
    def foreach(
        self, func: Callable[..., Tuple[bool, Buffer]], *user_data: Any
    ) -> bool: ...
    def get(self, idx: int) -> Optional[Buffer]: ...
    def get_writable(self, idx: int) -> Optional[Buffer]: ...
    def insert(self, idx: int, buffer: Buffer) -> None: ...
    def length(self) -> int: ...
    @classmethod
    def new(cls) -> BufferList: ...
    @classmethod
    def new_sized(cls, size: int) -> BufferList: ...
    def remove(self, idx: int, length: int) -> None: ...

class BufferPool(Object):
    class Props:
        name: Optional[str]
        parent: Optional[Object]
    props: Props = ...
    object: Object = ...
    flushing: int = ...
    priv: BufferPoolPrivate = ...
    _gst_reserved: list[None] = ...
    def __init__(self, name: str = ..., parent: Object = ...): ...
    def acquire_buffer(
        self, params: Optional[BufferPoolAcquireParams] = None
    ) -> Tuple[FlowReturn, Buffer]: ...
    @staticmethod
    def config_add_option(config: Structure, option: str) -> None: ...
    @staticmethod
    def config_get_allocator(
        config: Structure,
    ) -> Tuple[bool, Allocator, AllocationParams]: ...
    @staticmethod
    def config_get_option(config: Structure, index: int) -> Optional[str]: ...
    @staticmethod
    def config_get_params(config: Structure) -> Tuple[bool, Caps, int, int, int]: ...
    @staticmethod
    def config_has_option(config: Structure, option: str) -> bool: ...
    @staticmethod
    def config_n_options(config: Structure) -> int: ...
    @staticmethod
    def config_set_allocator(
        config: Structure,
        allocator: Optional[Allocator] = None,
        params: Optional[AllocationParams] = None,
    ) -> None: ...
    @staticmethod
    def config_set_params(
        config: Structure,
        caps: Optional[Caps],
        size: int,
        min_buffers: int,
        max_buffers: int,
    ) -> None: ...
    @staticmethod
    def config_validate_params(
        config: Structure,
        caps: Optional[Caps],
        size: int,
        min_buffers: int,
        max_buffers: int,
    ) -> bool: ...
    def do_acquire_buffer(
        self, params: Optional[BufferPoolAcquireParams] = None
    ) -> Tuple[FlowReturn, Buffer]: ...
    def do_alloc_buffer(
        self, params: Optional[BufferPoolAcquireParams] = None
    ) -> Tuple[FlowReturn, Buffer]: ...
    def do_flush_start(self) -> None: ...
    def do_flush_stop(self) -> None: ...
    def do_free_buffer(self, buffer: Buffer) -> None: ...
    def do_get_options(self) -> list[str]: ...
    def do_release_buffer(self, buffer: Buffer) -> None: ...
    def do_reset_buffer(self, buffer: Buffer) -> None: ...
    def do_set_config(self, config: Structure) -> bool: ...
    def do_start(self) -> bool: ...
    def do_stop(self) -> bool: ...
    def get_config(self) -> Structure: ...
    def get_options(self) -> list[str]: ...
    def has_option(self, option: str) -> bool: ...
    def is_active(self) -> bool: ...
    @classmethod
    def new(cls) -> BufferPool: ...
    def release_buffer(self, buffer: Buffer) -> None: ...
    def set_active(self, active: bool) -> bool: ...
    def set_config(self, config: Structure) -> bool: ...
    def set_flushing(self, flushing: bool) -> None: ...

class BufferPoolAcquireParams(GObject.GPointer):
    format: Format = ...
    start: int = ...
    stop: int = ...
    flags: BufferPoolAcquireFlags = ...
    _gst_reserved: list[None] = ...

class BufferPoolClass(GObject.GPointer):
    object_class: ObjectClass = ...
    get_options: Callable[[BufferPool], list[str]] = ...
    set_config: Callable[[BufferPool, Structure], bool] = ...
    start: Callable[[BufferPool], bool] = ...
    stop: Callable[[BufferPool], bool] = ...
    acquire_buffer: Callable[
        [BufferPool, Optional[BufferPoolAcquireParams]], Tuple[FlowReturn, Buffer]
    ] = ...
    alloc_buffer: Callable[
        [BufferPool, Optional[BufferPoolAcquireParams]], Tuple[FlowReturn, Buffer]
    ] = ...
    reset_buffer: Callable[[BufferPool, Buffer], None] = ...
    release_buffer: Callable[[BufferPool, Buffer], None] = ...
    free_buffer: Callable[[BufferPool, Buffer], None] = ...
    flush_start: Callable[[BufferPool], None] = ...
    flush_stop: Callable[[BufferPool], None] = ...
    _gst_reserved: list[None] = ...

class BufferPoolPrivate(GObject.GPointer): ...

class Bus(Object):
    class Props:
        name: Optional[str]
        parent: Optional[Object]
        enable_async: bool
    props: Props = ...
    object: Object = ...
    priv: BusPrivate = ...
    _gst_reserved: list[None] = ...
    def __init__(
        self, enable_async: bool = ..., name: str = ..., parent: Object = ...
    ): ...
    def add_signal_watch(self) -> None: ...
    def add_signal_watch_full(self, priority: int) -> None: ...
    def add_watch(
        self, priority: int, func: Callable[..., bool], *user_data: Any
    ) -> int: ...
    def async_signal_func(self, message: Message, data: None) -> bool: ...
    def create_watch(self) -> Optional[GLib.Source]: ...
    def disable_sync_message_emission(self) -> None: ...
    def do_message(self, message: Message) -> None: ...
    def do_sync_message(self, message: Message) -> None: ...
    def enable_sync_message_emission(self) -> None: ...
    def get_pollfd(self) -> GLib.PollFD: ...
    def have_pending(self) -> bool: ...
    @classmethod
    def new(cls) -> Bus: ...
    def peek(self) -> Optional[Message]: ...
    def poll(self, events: MessageType, timeout: int) -> Optional[Message]: ...
    def pop(self) -> Optional[Message]: ...
    def pop_filtered(self, types: MessageType) -> Optional[Message]: ...
    def post(self, message: Message) -> bool: ...
    def remove_signal_watch(self) -> None: ...
    def remove_watch(self) -> bool: ...
    def set_flushing(self, flushing: bool) -> None: ...
    def set_sync_handler(
        self, func: Optional[Callable[..., BusSyncReply]] = None, *user_data: Any
    ) -> None: ...
    def sync_signal_handler(self, message: Message, data: None) -> BusSyncReply: ...
    def timed_pop(self, timeout: int) -> Optional[Message]: ...
    def timed_pop_filtered(
        self, timeout: int, types: MessageType
    ) -> Optional[Message]: ...

class BusClass(GObject.GPointer):
    parent_class: ObjectClass = ...
    message: Callable[[Bus, Message], None] = ...
    sync_message: Callable[[Bus, Message], None] = ...
    _gst_reserved: list[None] = ...

class BusPrivate(GObject.GPointer): ...

class Caps(GObject.GBoxed):
    mini_object: MiniObject = ...
    def append(self, caps2: Caps) -> None: ...
    def append_structure(self, structure: Structure) -> None: ...
    def append_structure_full(
        self, structure: Structure, features: Optional[CapsFeatures] = None
    ) -> None: ...
    def can_intersect(self, caps2: Caps) -> bool: ...
    def copy(self) -> Caps: ...
    def copy_nth(self, nth: int) -> Caps: ...
    def filter_and_map_in_place(
        self, func: Callable[..., bool], *user_data: Any
    ) -> None: ...
    def fixate(self) -> Caps: ...
    def foreach(self, func: Callable[..., bool], *user_data: Any) -> bool: ...
    @staticmethod
    def from_string(string: str) -> Optional[Caps]: ...
    def get_features(self, index: int) -> Optional[CapsFeatures]: ...
    def get_size(self) -> int: ...
    def get_structure(self, index: int) -> Structure: ...
    def intersect(self, caps2: Caps) -> Caps: ...
    def intersect_full(self, caps2: Caps, mode: CapsIntersectMode) -> Caps: ...
    def is_always_compatible(self, caps2: Caps) -> bool: ...
    def is_any(self) -> bool: ...
    def is_empty(self) -> bool: ...
    def is_equal(self, caps2: Caps) -> bool: ...
    def is_equal_fixed(self, caps2: Caps) -> bool: ...
    def is_fixed(self) -> bool: ...
    def is_strictly_equal(self, caps2: Caps) -> bool: ...
    def is_subset(self, superset: Caps) -> bool: ...
    def is_subset_structure(self, structure: Structure) -> bool: ...
    def is_subset_structure_full(
        self, structure: Structure, features: Optional[CapsFeatures] = None
    ) -> bool: ...
    def map_in_place(self, func: Callable[..., bool], *user_data: Any) -> bool: ...
    def merge(self, caps2: Caps) -> Caps: ...
    def merge_structure(self, structure: Structure) -> Caps: ...
    def merge_structure_full(
        self, structure: Structure, features: Optional[CapsFeatures] = None
    ) -> Caps: ...
    @classmethod
    def new_any(cls) -> Caps: ...
    @classmethod
    def new_empty(cls) -> Caps: ...
    @classmethod
    def new_empty_simple(cls, media_type: str) -> Caps: ...
    def normalize(self) -> Caps: ...
    def remove_structure(self, idx: int) -> None: ...
    def serialize(self, flags: SerializeFlags) -> str: ...
    def set_features(
        self, index: int, features: Optional[CapsFeatures] = None
    ) -> None: ...
    def set_features_simple(self, features: Optional[CapsFeatures] = None) -> None: ...
    def set_value(self, field: str, value: Any) -> None: ...
    def simplify(self) -> Caps: ...
    def steal_structure(self, index: int) -> Optional[Structure]: ...
    def subtract(self, subtrahend: Caps) -> Caps: ...
    def to_string(self) -> str: ...
    def truncate(self) -> Caps: ...

class CapsFeatures(GObject.GBoxed):
    def add(self, feature: str) -> None: ...
    def add_id(self, feature: int) -> None: ...
    def contains(self, feature: str) -> bool: ...
    def contains_id(self, feature: int) -> bool: ...
    def copy(self) -> CapsFeatures: ...
    def free(self) -> None: ...
    @staticmethod
    def from_string(features: str) -> Optional[CapsFeatures]: ...
    def get_nth(self, i: int) -> Optional[str]: ...
    def get_nth_id(self, i: int) -> int: ...
    def get_size(self) -> int: ...
    def is_any(self) -> bool: ...
    def is_equal(self, features2: CapsFeatures) -> bool: ...
    @classmethod
    def new_any(cls) -> CapsFeatures: ...
    @classmethod
    def new_empty(cls) -> CapsFeatures: ...
    @classmethod
    def new_single(cls, feature: str) -> CapsFeatures: ...
    def remove(self, feature: str) -> None: ...
    def remove_id(self, feature: int) -> None: ...
    def set_parent_refcount(self, refcount: int) -> bool: ...
    def to_string(self) -> str: ...

class ChildProxy(GObject.GInterface):
    def child_added(self, child: GObject.Object, name: str) -> None: ...
    def child_removed(self, child: GObject.Object, name: str) -> None: ...
    def get_child_by_index(self, index: int) -> Optional[GObject.Object]: ...
    def get_child_by_name(self, name: str) -> Optional[GObject.Object]: ...
    def get_children_count(self) -> int: ...
    def get_property(self, name: str) -> Any: ...
    def lookup(self, name: str) -> Tuple[bool, GObject.Object, GObject.ParamSpec]: ...
    def set_property(self, name: str, value: Any) -> None: ...

class ChildProxyInterface(GObject.GPointer):
    parent: GObject.TypeInterface = ...
    get_child_by_name: Callable[[ChildProxy, str], Optional[GObject.Object]] = ...
    get_child_by_index: Callable[[ChildProxy, int], Optional[GObject.Object]] = ...
    get_children_count: Callable[[ChildProxy], int] = ...
    child_added: Callable[[ChildProxy, GObject.Object, str], None] = ...
    child_removed: Callable[[ChildProxy, GObject.Object, str], None] = ...
    _gst_reserved: list[None] = ...

class Clock(Object):
    class Props:
        timeout: int
        window_size: int
        window_threshold: int
        name: Optional[str]
        parent: Optional[Object]
    props: Props = ...
    object: Object = ...
    priv: ClockPrivate = ...
    _gst_reserved: list[None] = ...
    def __init__(
        self,
        timeout: int = ...,
        window_size: int = ...,
        window_threshold: int = ...,
        name: str = ...,
        parent: Object = ...,
    ): ...
    def add_observation(self, slave: int, master: int) -> Tuple[bool, float]: ...
    def add_observation_unapplied(
        self, slave: int, master: int
    ) -> Tuple[bool, float, int, int, int, int]: ...
    def adjust_unlocked(self, internal: int) -> int: ...
    def adjust_with_calibration(
        self,
        internal_target: int,
        cinternal: int,
        cexternal: int,
        cnum: int,
        cdenom: int,
    ) -> int: ...
    def do_change_resolution(self, old_resolution: int, new_resolution: int) -> int: ...
    def do_get_internal_time(self) -> int: ...
    def do_get_resolution(self) -> int: ...
    def do_unschedule(self, entry: ClockEntry) -> None: ...
    def do_wait(self, entry: ClockEntry) -> Tuple[ClockReturn, int]: ...
    def do_wait_async(self, entry: ClockEntry) -> ClockReturn: ...
    def get_calibration(self) -> Tuple[int, int, int, int]: ...
    def get_internal_time(self) -> int: ...
    def get_master(self) -> Optional[Clock]: ...
    def get_resolution(self) -> int: ...
    def get_time(self) -> int: ...
    def get_timeout(self) -> int: ...
    @staticmethod
    def id_compare_func(id1: None, id2: None) -> int: ...
    @staticmethod
    def id_get_clock(id: None) -> Optional[Clock]: ...
    @staticmethod
    def id_get_time(id: None) -> int: ...
    @staticmethod
    def id_ref(id: None) -> None: ...
    @staticmethod
    def id_unref(id: None) -> None: ...
    @staticmethod
    def id_unschedule(id: None) -> None: ...
    @staticmethod
    def id_uses_clock(id: None, clock: Clock) -> bool: ...
    @staticmethod
    def id_wait(id: None) -> Tuple[ClockReturn, int]: ...
    @staticmethod
    def id_wait_async(
        id: None, func: Callable[..., bool], *user_data: Any
    ) -> ClockReturn: ...
    def is_synced(self) -> bool: ...
    def new_periodic_id(self, start_time: int, interval: int) -> None: ...
    def new_single_shot_id(self, time: int) -> None: ...
    def periodic_id_reinit(self, id: None, start_time: int, interval: int) -> bool: ...
    def set_calibration(
        self, internal: int, external: int, rate_num: int, rate_denom: int
    ) -> None: ...
    def set_master(self, master: Optional[Clock] = None) -> bool: ...
    def set_resolution(self, resolution: int) -> int: ...
    def set_synced(self, synced: bool) -> None: ...
    def set_timeout(self, timeout: int) -> None: ...
    def single_shot_id_reinit(self, id: None, time: int) -> bool: ...
    def unadjust_unlocked(self, external: int) -> int: ...
    def unadjust_with_calibration(
        self,
        external_target: int,
        cinternal: int,
        cexternal: int,
        cnum: int,
        cdenom: int,
    ) -> int: ...
    def wait_for_sync(self, timeout: int) -> bool: ...

class ClockClass(GObject.GPointer):
    parent_class: ObjectClass = ...
    change_resolution: Callable[[Clock, int, int], int] = ...
    get_resolution: Callable[[Clock], int] = ...
    get_internal_time: Callable[[Clock], int] = ...
    wait: Callable[[Clock, ClockEntry], Tuple[ClockReturn, int]] = ...
    wait_async: Callable[[Clock, ClockEntry], ClockReturn] = ...
    unschedule: Callable[[Clock, ClockEntry], None] = ...
    _gst_reserved: list[None] = ...

class ClockEntry(GObject.GPointer):
    refcount: int = ...
    clock: Clock = ...
    type: ClockEntryType = ...
    time: int = ...
    interval: int = ...
    status: ClockReturn = ...
    func: Callable[..., bool] = ...
    user_data: None = ...
    destroy_data: Callable[[None], None] = ...
    unscheduled: bool = ...
    woken_up: bool = ...
    _gst_reserved: list[None] = ...

class ClockPrivate(GObject.GPointer): ...

class Context(GObject.GBoxed):
    def get_context_type(self) -> str: ...
    def get_structure(self) -> Structure: ...
    def has_context_type(self, context_type: str) -> bool: ...
    def is_persistent(self) -> bool: ...
    @classmethod
    def new(cls, context_type: str, persistent: bool) -> Context: ...
    def writable_structure(self) -> Structure: ...

class ControlBinding(Object):
    class Props:
        name: str
        object: Object
        parent: Optional[Object]
    props: Props = ...
    parent: Object = ...
    name: str = ...
    pspec: GObject.ParamSpec = ...
    object: Object = ...
    disabled: bool = ...
    def __init__(self, name: str = ..., object: Object = ..., parent: Object = ...): ...
    def do_get_g_value_array(
        self, timestamp: int, interval: int, n_values: int, values: Sequence[Any]
    ) -> bool: ...
    def do_get_value(self, timestamp: int) -> Optional[Any]: ...
    def do_sync_values(
        self, object: Object, timestamp: int, last_sync: int
    ) -> bool: ...
    def get_g_value_array(
        self, timestamp: int, interval: int, n_values: int, values: Sequence[Any]
    ) -> bool: ...
    def get_value(self, timestamp: int) -> Optional[Any]: ...
    def is_disabled(self) -> bool: ...
    def set_disabled(self, disabled: bool) -> None: ...
    def sync_values(self, object: Object, timestamp: int, last_sync: int) -> bool: ...

class ControlBindingClass(GObject.GPointer):
    parent_class: ObjectClass = ...
    sync_values: Callable[[ControlBinding, Object, int, int], bool] = ...
    get_value: Callable[[ControlBinding, int], Optional[Any]] = ...
    get_value_array: None = ...
    get_g_value_array: Callable[
        [ControlBinding, int, int, int, Sequence[Any]], bool
    ] = ...
    _gst_reserved: list[None] = ...

class ControlBindingPrivate(GObject.GPointer): ...

class ControlSource(Object):
    class Props:
        name: Optional[str]
        parent: Optional[Object]
    props: Props = ...
    parent: Object = ...
    get_value: Callable[[ControlSource, int, float], bool] = ...
    get_value_array: Callable[[ControlSource, int, int, int, float], bool] = ...
    _gst_reserved: list[None] = ...
    def __init__(self, name: str = ..., parent: Object = ...): ...
    def control_source_get_value(self, timestamp: int) -> Tuple[bool, float]: ...
    def control_source_get_value_array(
        self, timestamp: int, interval: int, n_values: int, values: Sequence[float]
    ) -> bool: ...

class ControlSourceClass(GObject.GPointer):
    parent_class: ObjectClass = ...
    _gst_reserved: list[None] = ...

class CustomMeta(GObject.GPointer):
    meta: Meta = ...
    def get_structure(self) -> Structure: ...
    def has_name(self, name: str) -> bool: ...

class DateTime(GObject.GBoxed):
    def get_day(self) -> int: ...
    def get_hour(self) -> int: ...
    def get_microsecond(self) -> int: ...
    def get_minute(self) -> int: ...
    def get_month(self) -> int: ...
    def get_second(self) -> int: ...
    def get_time_zone_offset(self) -> float: ...
    def get_year(self) -> int: ...
    def has_day(self) -> bool: ...
    def has_month(self) -> bool: ...
    def has_second(self) -> bool: ...
    def has_time(self) -> bool: ...
    def has_year(self) -> bool: ...
    @classmethod
    def new(
        cls,
        tzoffset: float,
        year: int,
        month: int,
        day: int,
        hour: int,
        minute: int,
        seconds: float,
    ) -> Optional[DateTime]: ...
    @classmethod
    def new_from_g_date_time(
        cls, dt: Optional[GLib.DateTime] = None
    ) -> Optional[DateTime]: ...
    @classmethod
    def new_from_iso8601_string(cls, string: str) -> Optional[DateTime]: ...
    @classmethod
    def new_from_unix_epoch_local_time(cls, secs: int) -> Optional[DateTime]: ...
    @classmethod
    def new_from_unix_epoch_local_time_usecs(cls, usecs: int) -> Optional[DateTime]: ...
    @classmethod
    def new_from_unix_epoch_utc(cls, secs: int) -> Optional[DateTime]: ...
    @classmethod
    def new_from_unix_epoch_utc_usecs(cls, usecs: int) -> Optional[DateTime]: ...
    @classmethod
    def new_local_time(
        cls, year: int, month: int, day: int, hour: int, minute: int, seconds: float
    ) -> Optional[DateTime]: ...
    @classmethod
    def new_now_local_time(cls) -> Optional[DateTime]: ...
    @classmethod
    def new_now_utc(cls) -> Optional[DateTime]: ...
    @classmethod
    def new_y(cls, year: int) -> Optional[DateTime]: ...
    @classmethod
    def new_ym(cls, year: int, month: int) -> Optional[DateTime]: ...
    @classmethod
    def new_ymd(cls, year: int, month: int, day: int) -> Optional[DateTime]: ...
    def ref(self) -> DateTime: ...
    def to_g_date_time(self) -> Optional[GLib.DateTime]: ...
    def to_iso8601_string(self) -> Optional[str]: ...
    def unref(self) -> None: ...

class DebugCategory(GObject.GPointer):
    threshold: int = ...
    color: int = ...
    name: str = ...
    description: str = ...
    def free(self) -> None: ...
    def get_color(self) -> int: ...
    def get_description(self) -> str: ...
    def get_name(self) -> str: ...
    def get_threshold(self) -> DebugLevel: ...
    def reset_threshold(self) -> None: ...
    def set_threshold(self, level: DebugLevel) -> None: ...

class DebugMessage(GObject.GPointer):
    def get(self) -> Optional[str]: ...

class Device(Object):
    class Props:
        caps: Optional[Caps]
        device_class: str
        display_name: str
        properties: Optional[Structure]
        name: Optional[str]
        parent: Optional[Object]
    props: Props = ...
    parent: Object = ...
    priv: DevicePrivate = ...
    _gst_reserved: list[None] = ...
    def __init__(
        self,
        caps: Caps = ...,
        device_class: str = ...,
        display_name: str = ...,
        properties: Structure = ...,
        name: str = ...,
        parent: Object = ...,
    ): ...
    def create_element(self, name: Optional[str] = None) -> Optional[Element]: ...
    def do_create_element(self, name: Optional[str] = None) -> Optional[Element]: ...
    def do_reconfigure_element(self, element: Element) -> bool: ...
    def get_caps(self) -> Optional[Caps]: ...
    def get_device_class(self) -> str: ...
    def get_display_name(self) -> str: ...
    def get_properties(self) -> Optional[Structure]: ...
    def has_classes(self, classes: str) -> bool: ...
    def has_classesv(self, classes: Sequence[str]) -> bool: ...
    def reconfigure_element(self, element: Element) -> bool: ...

class DeviceClass(GObject.GPointer):
    parent_class: ObjectClass = ...
    create_element: Callable[[Device, Optional[str]], Optional[Element]] = ...
    reconfigure_element: Callable[[Device, Element], bool] = ...
    _gst_reserved: list[None] = ...

class DeviceMonitor(Object):
    class Props:
        show_all: bool
        name: Optional[str]
        parent: Optional[Object]
    props: Props = ...
    parent: Object = ...
    priv: DeviceMonitorPrivate = ...
    _gst_reserved: list[None] = ...
    def __init__(self, show_all: bool = ..., name: str = ..., parent: Object = ...): ...
    def add_filter(
        self, classes: Optional[str] = None, caps: Optional[Caps] = None
    ) -> int: ...
    def get_bus(self) -> Bus: ...
    def get_devices(self) -> Optional[list[Device]]: ...
    def get_providers(self) -> list[str]: ...
    def get_show_all_devices(self) -> bool: ...
    @classmethod
    def new(cls) -> DeviceMonitor: ...
    def remove_filter(self, filter_id: int) -> bool: ...
    def set_show_all_devices(self, show_all: bool) -> None: ...
    def start(self) -> bool: ...
    def stop(self) -> None: ...

class DeviceMonitorClass(GObject.GPointer):
    parent_class: ObjectClass = ...
    _gst_reserved: list[None] = ...

class DeviceMonitorPrivate(GObject.GPointer): ...
class DevicePrivate(GObject.GPointer): ...

class DeviceProvider(Object):
    class Props:
        name: Optional[str]
        parent: Optional[Object]
    props: Props = ...
    parent: Object = ...
    devices: list[None] = ...
    priv: DeviceProviderPrivate = ...
    _gst_reserved: list[None] = ...
    def __init__(self, name: str = ..., parent: Object = ...): ...
    def add_metadata(self, key: str, value: str) -> None: ...
    def add_static_metadata(self, key: str, value: str) -> None: ...
    def can_monitor(self) -> bool: ...
    def device_add(self, device: Device) -> None: ...
    def device_changed(self, device: Device, changed_device: Device) -> None: ...
    def device_remove(self, device: Device) -> None: ...
    def do_start(self) -> bool: ...
    def do_stop(self) -> None: ...
    def get_bus(self) -> Bus: ...
    def get_devices(self) -> list[Device]: ...
    def get_factory(self) -> Optional[DeviceProviderFactory]: ...
    def get_hidden_providers(self) -> list[str]: ...
    def get_metadata(self, key: str) -> str: ...
    def hide_provider(self, name: str) -> None: ...
    def is_started(self) -> bool: ...
    @staticmethod
    def register(
        plugin: Optional[Plugin], name: str, rank: int, type: Type
    ) -> bool: ...
    def set_metadata(
        self, longname: str, classification: str, description: str, author: str
    ) -> None: ...
    def set_static_metadata(
        self, longname: str, classification: str, description: str, author: str
    ) -> None: ...
    def start(self) -> bool: ...
    def stop(self) -> None: ...
    def unhide_provider(self, name: str) -> None: ...

class DeviceProviderClass(GObject.GPointer):
    parent_class: ObjectClass = ...
    factory: DeviceProviderFactory = ...
    probe: None = ...
    start: Callable[[DeviceProvider], bool] = ...
    stop: Callable[[DeviceProvider], None] = ...
    metadata: None = ...
    _gst_reserved: list[None] = ...
    def add_metadata(self, key: str, value: str) -> None: ...
    def add_static_metadata(self, key: str, value: str) -> None: ...
    def get_metadata(self, key: str) -> Optional[str]: ...
    def set_metadata(
        self, longname: str, classification: str, description: str, author: str
    ) -> None: ...
    def set_static_metadata(
        self, longname: str, classification: str, description: str, author: str
    ) -> None: ...

class DeviceProviderFactory(PluginFeature):
    class Props:
        name: Optional[str]
        parent: Optional[Object]
    props: Props = ...
    def __init__(self, name: str = ..., parent: Object = ...): ...
    @staticmethod
    def find(name: str) -> Optional[DeviceProviderFactory]: ...
    def get(self) -> Optional[DeviceProvider]: ...
    @staticmethod
    def get_by_name(factoryname: str) -> Optional[DeviceProvider]: ...
    def get_device_provider_type(self) -> Type: ...
    def get_metadata(self, key: str) -> Optional[str]: ...
    def get_metadata_keys(self) -> Optional[list[str]]: ...
    def has_classes(self, classes: Optional[str] = None) -> bool: ...
    def has_classesv(self, classes: Optional[Sequence[str]] = None) -> bool: ...
    @staticmethod
    def list_get_device_providers(minrank: Rank) -> list[DeviceProviderFactory]: ...

class DeviceProviderFactoryClass(GObject.GPointer): ...
class DeviceProviderPrivate(GObject.GPointer): ...
class DoubleRange: ...

class DynamicTypeFactory(PluginFeature):
    class Props:
        name: Optional[str]
        parent: Optional[Object]
    props: Props = ...
    def __init__(self, name: str = ..., parent: Object = ...): ...
    @staticmethod
    def load(factoryname: str) -> Type: ...

class DynamicTypeFactoryClass(GObject.GPointer): ...

class Element(Object):
    class Props:
        name: Optional[str]
        parent: Optional[Object]
    props: Props = ...
    object: Object = ...
    state_lock: GLib.RecMutex = ...
    state_cond: GLib.Cond = ...
    state_cookie: int = ...
    target_state: State = ...
    current_state: State = ...
    next_state: State = ...
    pending_state: State = ...
    last_return: StateChangeReturn = ...
    bus: Bus = ...
    clock: Clock = ...
    base_time: int = ...
    start_time: int = ...
    numpads: int = ...
    pads: list[Pad] = ...
    numsrcpads: int = ...
    srcpads: list[Pad] = ...
    numsinkpads: int = ...
    sinkpads: list[Pad] = ...
    pads_cookie: int = ...
    contexts: list[Context] = ...
    _gst_reserved: list[None] = ...
    def __init__(self, name: str = ..., parent: Object = ...): ...
    def abort_state(self) -> None: ...
    def add_metadata(self, key: str, value: str) -> None: ...
    def add_pad(self, pad: Pad) -> bool: ...
    def add_pad_template(self, templ: PadTemplate) -> None: ...
    def add_property_deep_notify_watch(
        self, property_name: Optional[str], include_value: bool
    ) -> int: ...
    def add_property_notify_watch(
        self, property_name: Optional[str], include_value: bool
    ) -> int: ...
    def add_static_metadata(self, key: str, value: str) -> None: ...
    def add_static_pad_template(self, static_templ: StaticPadTemplate) -> None: ...
    def add_static_pad_template_with_gtype(
        self, static_templ: StaticPadTemplate, pad_type: Type
    ) -> None: ...
    def call_async(self, func: Callable[..., None], *user_data: Any) -> None: ...
    def change_state(self, transition: StateChange) -> StateChangeReturn: ...
    def continue_state(self, ret: StateChangeReturn) -> StateChangeReturn: ...
    def create_all_pads(self) -> None: ...
    def do_change_state(self, transition: StateChange) -> StateChangeReturn: ...
    def do_get_state(self, timeout: int) -> Tuple[StateChangeReturn, State, State]: ...
    def do_no_more_pads(self) -> None: ...
    def do_pad_added(self, pad: Pad) -> None: ...
    def do_pad_removed(self, pad: Pad) -> None: ...
    def do_post_message(self, message: Message) -> bool: ...
    def do_provide_clock(self) -> Optional[Clock]: ...
    def do_query(self, query: Query) -> bool: ...
    def do_release_pad(self, pad: Pad) -> None: ...
    def do_request_new_pad(
        self,
        templ: PadTemplate,
        name: Optional[str] = None,
        caps: Optional[Caps] = None,
    ) -> Optional[Pad]: ...
    def do_send_event(self, event: Event) -> bool: ...
    def do_set_bus(self, bus: Optional[Bus] = None) -> None: ...
    def do_set_clock(self, clock: Optional[Clock] = None) -> bool: ...
    def do_set_context(self, context: Context) -> None: ...
    def do_set_state(self, state: State) -> StateChangeReturn: ...
    def do_state_changed(
        self, oldstate: State, newstate: State, pending: State
    ) -> None: ...
    def foreach_pad(self, func: Callable[..., bool], *user_data: Any) -> bool: ...
    def foreach_sink_pad(self, func: Callable[..., bool], *user_data: Any) -> bool: ...
    def foreach_src_pad(self, func: Callable[..., bool], *user_data: Any) -> bool: ...
    def get_base_time(self) -> int: ...
    def get_bus(self) -> Optional[Bus]: ...
    def get_clock(self) -> Optional[Clock]: ...
    def get_compatible_pad(
        self, pad: Pad, caps: Optional[Caps] = None
    ) -> Optional[Pad]: ...
    def get_compatible_pad_template(
        self, compattempl: PadTemplate
    ) -> Optional[PadTemplate]: ...
    def get_context(self, context_type: str) -> Optional[Context]: ...
    def get_context_unlocked(self, context_type: str) -> Optional[Context]: ...
    def get_contexts(self) -> list[Context]: ...
    def get_current_clock_time(self) -> int: ...
    def get_current_running_time(self) -> int: ...
    def get_factory(self) -> Optional[ElementFactory]: ...
    def get_metadata(self, key: str) -> str: ...
    def get_pad_template(self, name: str) -> Optional[PadTemplate]: ...
    def get_pad_template_list(self) -> list[PadTemplate]: ...
    def get_request_pad(self, name: str) -> Optional[Pad]: ...
    def get_start_time(self) -> int: ...
    def get_state(self, timeout: int) -> Tuple[StateChangeReturn, State, State]: ...
    def get_static_pad(self, name: str) -> Optional[Pad]: ...
    def is_locked_state(self) -> bool: ...
    def iterate_pads(self) -> Iterator: ...
    def iterate_sink_pads(self) -> Iterator: ...
    def iterate_src_pads(self) -> Iterator: ...
    def link(self, dest: Element) -> bool: ...
    def link_filtered(self, dest: Element, filter: Optional[Caps] = None) -> bool: ...
    def link_pads(
        self,
        srcpadname: Optional[str],
        dest: Element,
        destpadname: Optional[str] = None,
    ) -> bool: ...
    def link_pads_filtered(
        self,
        srcpadname: Optional[str],
        dest: Element,
        destpadname: Optional[str] = None,
        filter: Optional[Caps] = None,
    ) -> bool: ...
    def link_pads_full(
        self,
        srcpadname: Optional[str],
        dest: Element,
        destpadname: Optional[str],
        flags: PadLinkCheck,
    ) -> bool: ...
    def lost_state(self) -> None: ...
    @staticmethod
    def make_from_uri(
        type: URIType, uri: str, elementname: Optional[str] = None
    ) -> Element: ...
    def message_full(
        self,
        type: MessageType,
        domain: int,
        code: int,
        text: Optional[str],
        debug: Optional[str],
        file: str,
        function: str,
        line: int,
    ) -> None: ...
    def message_full_with_details(
        self,
        type: MessageType,
        domain: int,
        code: int,
        text: Optional[str],
        debug: Optional[str],
        file: str,
        function: str,
        line: int,
        structure: Structure,
    ) -> None: ...
    def no_more_pads(self) -> None: ...
    def post_message(self, message: Message) -> bool: ...
    def provide_clock(self) -> Optional[Clock]: ...
    def query(self, query: Query) -> bool: ...
    def query_convert(
        self, src_format: Format, src_val: int, dest_format: Format
    ) -> Tuple[bool, int]: ...
    def query_duration(self, format: Format) -> Tuple[bool, int]: ...
    def query_position(self, format: Format) -> Tuple[bool, int]: ...
    @staticmethod
    def register(
        plugin: Optional[Plugin], name: str, rank: int, type: Type
    ) -> bool: ...
    def release_request_pad(self, pad: Pad) -> None: ...
    def remove_pad(self, pad: Pad) -> bool: ...
    def remove_property_notify_watch(self, watch_id: int) -> None: ...
    def request_pad(
        self,
        templ: PadTemplate,
        name: Optional[str] = None,
        caps: Optional[Caps] = None,
    ) -> Optional[Pad]: ...
    def request_pad_simple(self, name: str) -> Optional[Pad]: ...
    def seek(
        self,
        rate: float,
        format: Format,
        flags: SeekFlags,
        start_type: SeekType,
        start: int,
        stop_type: SeekType,
        stop: int,
    ) -> bool: ...
    def seek_simple(
        self, format: Format, seek_flags: SeekFlags, seek_pos: int
    ) -> bool: ...
    def send_event(self, event: Event) -> bool: ...
    def set_base_time(self, time: int) -> None: ...
    def set_bus(self, bus: Optional[Bus] = None) -> None: ...
    def set_clock(self, clock: Optional[Clock] = None) -> bool: ...
    def set_context(self, context: Context) -> None: ...
    def set_locked_state(self, locked_state: bool) -> bool: ...
    def set_metadata(
        self, longname: str, classification: str, description: str, author: str
    ) -> None: ...
    def set_start_time(self, time: int) -> None: ...
    def set_state(self, state: State) -> StateChangeReturn: ...
    def set_static_metadata(
        self, longname: str, classification: str, description: str, author: str
    ) -> None: ...
    @staticmethod
    def state_change_return_get_name(state_ret: StateChangeReturn) -> str: ...
    @staticmethod
    def state_get_name(state: State) -> str: ...
    def sync_state_with_parent(self) -> bool: ...
    @staticmethod
    def type_set_skip_documentation(type: Type) -> None: ...
    def unlink(self, dest: Element) -> None: ...
    def unlink_pads(self, srcpadname: str, dest: Element, destpadname: str) -> None: ...

class ElementClass(GObject.GPointer):
    parent_class: ObjectClass = ...
    metadata: None = ...
    elementfactory: ElementFactory = ...
    padtemplates: list[None] = ...
    numpadtemplates: int = ...
    pad_templ_cookie: int = ...
    pad_added: Callable[[Element, Pad], None] = ...
    pad_removed: Callable[[Element, Pad], None] = ...
    no_more_pads: Callable[[Element], None] = ...
    request_new_pad: Callable[
        [Element, PadTemplate, Optional[str], Optional[Caps]], Optional[Pad]
    ] = ...
    release_pad: Callable[[Element, Pad], None] = ...
    get_state: Callable[[Element, int], Tuple[StateChangeReturn, State, State]] = ...
    set_state: Callable[[Element, State], StateChangeReturn] = ...
    change_state: Callable[[Element, StateChange], StateChangeReturn] = ...
    state_changed: Callable[[Element, State, State, State], None] = ...
    set_bus: Callable[[Element, Optional[Bus]], None] = ...
    provide_clock: Callable[[Element], Optional[Clock]] = ...
    set_clock: Callable[[Element, Optional[Clock]], bool] = ...
    send_event: Callable[[Element, Event], bool] = ...
    query: Callable[[Element, Query], bool] = ...
    post_message: Callable[[Element, Message], bool] = ...
    set_context: Callable[[Element, Context], None] = ...
    _gst_reserved: list[None] = ...
    def add_metadata(self, key: str, value: str) -> None: ...
    def add_pad_template(self, templ: PadTemplate) -> None: ...
    def add_static_metadata(self, key: str, value: str) -> None: ...
    def add_static_pad_template(self, static_templ: StaticPadTemplate) -> None: ...
    def add_static_pad_template_with_gtype(
        self, static_templ: StaticPadTemplate, pad_type: Type
    ) -> None: ...
    def get_metadata(self, key: str) -> str: ...
    def get_pad_template(self, name: str) -> Optional[PadTemplate]: ...
    def get_pad_template_list(self) -> list[PadTemplate]: ...
    def set_metadata(
        self, longname: str, classification: str, description: str, author: str
    ) -> None: ...
    def set_static_metadata(
        self, longname: str, classification: str, description: str, author: str
    ) -> None: ...

class ElementFactory(PluginFeature):
    class Props:
        name: Optional[str]
        parent: Optional[Object]
    props: Props = ...
    def __init__(self, name: str = ..., parent: Object = ...): ...
    def can_sink_all_caps(self, caps: Caps) -> bool: ...
    def can_sink_any_caps(self, caps: Caps) -> bool: ...
    def can_src_all_caps(self, caps: Caps) -> bool: ...
    def can_src_any_caps(self, caps: Caps) -> bool: ...
    def create(self, name: Optional[str] = None) -> Optional[Element]: ...
    def create_with_properties(
        self,
        n: int,
        names: Optional[Sequence[str]] = None,
        values: Optional[Sequence[Any]] = None,
    ) -> Optional[Element]: ...
    @staticmethod
    def find(name: str) -> Optional[ElementFactory]: ...
    def get_element_type(self) -> Type: ...
    def get_metadata(self, key: str) -> Optional[str]: ...
    def get_metadata_keys(self) -> Optional[list[str]]: ...
    def get_num_pad_templates(self) -> int: ...
    def get_skip_documentation(self) -> bool: ...
    def get_static_pad_templates(self) -> list[StaticPadTemplate]: ...
    def get_uri_protocols(self) -> list[str]: ...
    def get_uri_type(self) -> URIType: ...
    def has_interface(self, interfacename: str) -> bool: ...
    @staticmethod
    def list_filter(
        list: list[ElementFactory],
        caps: Caps,
        direction: PadDirection,
        subsetonly: bool,
    ) -> list[ElementFactory]: ...
    @staticmethod
    def list_get_elements(type: int, minrank: Rank) -> list[ElementFactory]: ...
    def list_is_type(self, type: int) -> bool: ...
    @staticmethod
    def make(factoryname: str, name: Optional[str] = None) -> Optional[Element]: ...
    @staticmethod
    def make_with_properties(
        factoryname: str,
        n: int,
        names: Optional[Sequence[str]] = None,
        values: Optional[Sequence[Any]] = None,
    ) -> Optional[Element]: ...

class ElementFactoryClass(GObject.GPointer): ...

class Event(GObject.GBoxed):
    mini_object: MiniObject = ...
    type: EventType = ...
    timestamp: int = ...
    seqnum: int = ...
    def copy_segment(self, segment: Segment) -> None: ...
    def get_running_time_offset(self) -> int: ...
    def get_seqnum(self) -> int: ...
    def get_structure(self) -> Optional[Structure]: ...
    def has_name(self, name: str) -> bool: ...
    def has_name_id(self, name: int) -> bool: ...
    # override
    @classmethod
    def new_buffer_size(
        cls, format: Format, minsize: int, maxsize: int, _async: bool
    ) -> Event: ...
    @classmethod
    def new_caps(cls, caps: Caps) -> Optional[Event]: ...
    @classmethod
    def new_custom(cls, type: EventType, structure: Structure) -> Optional[Event]: ...
    @classmethod
    def new_eos(cls) -> Event: ...
    @classmethod
    def new_flush_start(cls) -> Event: ...
    @classmethod
    def new_flush_stop(cls, reset_time: bool) -> Event: ...
    @classmethod
    def new_gap(cls, timestamp: int, duration: int) -> Event: ...
    @classmethod
    def new_instant_rate_change(
        cls, rate_multiplier: float, new_flags: SegmentFlags
    ) -> Event: ...
    @classmethod
    def new_instant_rate_sync_time(
        cls, rate_multiplier: float, running_time: int, upstream_running_time: int
    ) -> Event: ...
    @classmethod
    def new_latency(cls, latency: int) -> Event: ...
    @classmethod
    def new_navigation(cls, structure: Structure) -> Event: ...
    @classmethod
    def new_protection(cls, system_id: str, data: Buffer, origin: str) -> Event: ...
    @classmethod
    def new_qos(
        cls, type: QOSType, proportion: float, diff: int, timestamp: int
    ) -> Optional[Event]: ...
    @classmethod
    def new_reconfigure(cls) -> Event: ...
    @classmethod
    def new_seek(
        cls,
        rate: float,
        format: Format,
        flags: SeekFlags,
        start_type: SeekType,
        start: int,
        stop_type: SeekType,
        stop: int,
    ) -> Optional[Event]: ...
    @classmethod
    def new_segment(cls, segment: Segment) -> Optional[Event]: ...
    @classmethod
    def new_segment_done(cls, format: Format, position: int) -> Event: ...
    @classmethod
    def new_select_streams(cls, streams: list[str]) -> Event: ...
    @classmethod
    def new_sink_message(cls, name: str, msg: Message) -> Event: ...
    @classmethod
    def new_step(
        cls, format: Format, amount: int, rate: float, flush: bool, intermediate: bool
    ) -> Optional[Event]: ...
    @classmethod
    def new_stream_collection(cls, collection: StreamCollection) -> Event: ...
    @classmethod
    def new_stream_group_done(cls, group_id: int) -> Event: ...
    @classmethod
    def new_stream_start(cls, stream_id: str) -> Event: ...
    @classmethod
    def new_tag(cls, taglist: TagList) -> Event: ...
    @classmethod
    def new_toc(cls, toc: Toc, updated: bool) -> Event: ...
    @classmethod
    def new_toc_select(cls, uid: str) -> Event: ...
    def parse_buffer_size(self) -> Tuple[Format, int, int, bool]: ...
    def parse_caps(self) -> Caps: ...
    def parse_flush_stop(self) -> bool: ...
    def parse_gap(self) -> Tuple[int, int]: ...
    def parse_gap_flags(self) -> GapFlags: ...
    def parse_group_id(self) -> Tuple[bool, int]: ...
    def parse_instant_rate_change(self) -> Tuple[float, SegmentFlags]: ...
    def parse_instant_rate_sync_time(self) -> Tuple[float, int, int]: ...
    def parse_latency(self) -> int: ...
    def parse_protection(self) -> Tuple[str, Buffer, str]: ...
    def parse_qos(self) -> Tuple[QOSType, float, int, int]: ...
    def parse_seek(
        self,
    ) -> Tuple[float, Format, SeekFlags, SeekType, int, SeekType, int]: ...
    def parse_seek_trickmode_interval(self) -> int: ...
    def parse_segment(self) -> Segment: ...
    def parse_segment_done(self) -> Tuple[Format, int]: ...
    def parse_select_streams(self) -> list[str]: ...
    def parse_sink_message(self) -> Message: ...
    def parse_step(self) -> Tuple[Format, int, float, bool, bool]: ...
    def parse_stream(self) -> Stream: ...
    def parse_stream_collection(self) -> StreamCollection: ...
    def parse_stream_flags(self) -> StreamFlags: ...
    def parse_stream_group_done(self) -> int: ...
    def parse_stream_start(self) -> str: ...
    def parse_tag(self) -> TagList: ...
    def parse_toc(self) -> Tuple[Toc, bool]: ...
    def parse_toc_select(self) -> str: ...
    def set_gap_flags(self, flags: GapFlags) -> None: ...
    def set_group_id(self, group_id: int) -> None: ...
    def set_running_time_offset(self, offset: int) -> None: ...
    def set_seek_trickmode_interval(self, interval: int) -> None: ...
    def set_seqnum(self, seqnum: int) -> None: ...
    def set_stream(self, stream: Stream) -> None: ...
    def set_stream_flags(self, flags: StreamFlags) -> None: ...
    def writable_structure(self) -> Structure: ...

class FlagSet:
    @staticmethod
    def register(flags_type: Type) -> Type: ...

class FormatDefinition(GObject.GPointer):
    value: Format = ...
    nick: str = ...
    description: str = ...
    quark: int = ...

class Fraction: ...
class FractionRange: ...

class GhostPad(ProxyPad):
    class Props:
        caps: Caps
        direction: PadDirection
        offset: int
        template: PadTemplate
        name: Optional[str]
        parent: Optional[Object]
    props: Props = ...
    pad: ProxyPad = ...
    priv: GhostPadPrivate = ...
    def __init__(
        self,
        direction: PadDirection = ...,
        offset: int = ...,
        template: PadTemplate = ...,
        name: str = ...,
        parent: Object = ...,
    ): ...
    @staticmethod
    def activate_mode_default(
        pad: Pad, parent: Optional[Object], mode: PadMode, active: bool
    ) -> bool: ...
    def construct(self) -> bool: ...
    def get_target(self) -> Optional[Pad]: ...
    @staticmethod
    def internal_activate_mode_default(
        pad: Pad, parent: Optional[Object], mode: PadMode, active: bool
    ) -> bool: ...
    @classmethod
    def new(cls, name: Optional[str], target: Pad) -> GhostPad: ...
    @classmethod
    def new_from_template(
        cls, name: Optional[str], target: Pad, templ: PadTemplate
    ) -> GhostPad: ...
    @classmethod
    def new_no_target(cls, name: Optional[str], dir: PadDirection) -> GhostPad: ...
    @classmethod
    def new_no_target_from_template(
        cls, name: Optional[str], templ: PadTemplate
    ) -> GhostPad: ...
    def set_target(self, newtarget: Optional[Pad] = None) -> bool: ...

class GhostPadClass(GObject.GPointer):
    parent_class: ProxyPadClass = ...
    _gst_reserved: list[None] = ...

class GhostPadPrivate(GObject.GPointer): ...
class Int64Range: ...
class IntRange: ...

# override
class Iterator(GObject.GBoxed):
    item: Callable[[Iterator, Any], IteratorItem] = ...
    pushed: Iterator = ...
    type: Type = ...
    lock: GLib.Mutex = ...
    cookie: int = ...
    master_cookie: int = ...
    size: int = ...
    _gst_reserved: list[None] = ...
    def copy(self) -> Iterator: ...
    def filter(self, func: Callable[[None, None], int], user_data: Any) -> Iterator: ...
    def find_custom(
        self, func: Callable[[None, None], int], *user_data: Any
    ) -> Tuple[bool, Any]: ...
    def fold(
        self, func: Callable[..., bool], ret: Any, *user_data: Any
    ) -> IteratorResult: ...
    def foreach(self, func: Callable[..., None], *user_data: Any) -> IteratorResult: ...
    def free(self) -> None: ...
    @classmethod
    def new_single(cls, type: Type, object: Any) -> Iterator: ...
    def next(self) -> Tuple[IteratorResult, Any]: ...
    def push(self, other: Iterator) -> None: ...
    def resync(self) -> None: ...

class MapInfo(GObject.GPointer):
    memory: Memory = ...
    flags: MapFlags = ...
    data: bytes = ...
    size: int = ...
    maxsize: int = ...
    user_data: list[None] = ...
    _gst_reserved: list[None] = ...

class Memory(GObject.GBoxed):
    mini_object: MiniObject = ...
    allocator: Allocator = ...
    parent: Memory = ...
    maxsize: int = ...
    align: int = ...
    offset: int = ...
    size: int = ...
    def copy(self, offset: int, size: int) -> Memory: ...
    def get_sizes(self) -> Tuple[int, int, int]: ...
    def is_span(self, mem2: Memory) -> Tuple[bool, int]: ...
    def is_type(self, mem_type: str) -> bool: ...
    def make_mapped(self, flags: MapFlags) -> Tuple[Optional[Memory], MapInfo]: ...
    def map(self, flags: MapFlags) -> Tuple[bool, MapInfo]: ...
    # override
    @classmethod
    def new_wrapped(
        cls,
        flags: MemoryFlags,
        data: Sequence[int],
        maxsize: int,
        offset: int,
        user_data: None,
        notify: Optional[Callable[[None], None]] = None,
        *_user_data: Any,
    ) -> Optional[Memory]: ...
    def resize(self, offset: int, size: int) -> None: ...
    def share(self, offset: int, size: int) -> Memory: ...
    def unmap(self, info: MapInfo) -> None: ...

class Message(GObject.GBoxed):
    mini_object: MiniObject = ...
    type: MessageType = ...
    timestamp: int = ...
    src: Object = ...
    seqnum: int = ...
    lock: GLib.Mutex = ...
    cond: GLib.Cond = ...
    def add_redirect_entry(
        self,
        location: str,
        tag_list: Optional[TagList] = None,
        entry_struct: Optional[Structure] = None,
    ) -> None: ...
    def get_num_redirect_entries(self) -> int: ...
    def get_seqnum(self) -> int: ...
    def get_stream_status_object(self) -> Optional[Any]: ...
    def get_structure(self) -> Optional[Structure]: ...
    def has_name(self, name: str) -> bool: ...
    @classmethod
    def new_application(
        cls, src: Optional[Object], structure: Structure
    ) -> Optional[Message]: ...
    @classmethod
    def new_async_done(cls, src: Optional[Object], running_time: int) -> Message: ...
    @classmethod
    def new_async_start(cls, src: Optional[Object] = None) -> Message: ...
    @classmethod
    def new_buffering(
        cls, src: Optional[Object], percent: int
    ) -> Optional[Message]: ...
    @classmethod
    def new_clock_lost(cls, src: Optional[Object], clock: Clock) -> Message: ...
    @classmethod
    def new_clock_provide(
        cls, src: Optional[Object], clock: Clock, ready: bool
    ) -> Message: ...
    @classmethod
    def new_custom(
        cls,
        type: MessageType,
        src: Optional[Object] = None,
        structure: Optional[Structure] = None,
    ) -> Optional[Message]: ...
    @classmethod
    def new_device_added(cls, src: Object, device: Device) -> Message: ...
    @classmethod
    def new_device_changed(
        cls, src: Object, device: Device, changed_device: Device
    ) -> Message: ...
    @classmethod
    def new_device_removed(cls, src: Object, device: Device) -> Message: ...
    @classmethod
    def new_duration_changed(cls, src: Optional[Object] = None) -> Message: ...
    @classmethod
    def new_element(
        cls, src: Optional[Object], structure: Structure
    ) -> Optional[Message]: ...
    @classmethod
    def new_eos(cls, src: Optional[Object] = None) -> Message: ...
    @classmethod
    def new_error(
        cls, src: Optional[Object], error: GLib.Error, debug: str
    ) -> Message: ...
    @classmethod
    def new_error_with_details(
        cls,
        src: Optional[Object],
        error: GLib.Error,
        debug: str,
        details: Optional[Structure] = None,
    ) -> Optional[Message]: ...
    @classmethod
    def new_have_context(cls, src: Optional[Object], context: Context) -> Message: ...
    @classmethod
    def new_info(
        cls, src: Optional[Object], error: GLib.Error, debug: str
    ) -> Message: ...
    @classmethod
    def new_info_with_details(
        cls,
        src: Optional[Object],
        error: GLib.Error,
        debug: str,
        details: Optional[Structure] = None,
    ) -> Optional[Message]: ...
    @classmethod
    def new_instant_rate_request(
        cls, src: Object, rate_multiplier: float
    ) -> Message: ...
    @classmethod
    def new_latency(cls, src: Optional[Object] = None) -> Message: ...
    @classmethod
    def new_need_context(cls, src: Optional[Object], context_type: str) -> Message: ...
    @classmethod
    def new_new_clock(cls, src: Optional[Object], clock: Clock) -> Message: ...
    @classmethod
    def new_progress(
        cls, src: Object, type: ProgressType, code: str, text: str
    ) -> Optional[Message]: ...
    @classmethod
    def new_property_notify(
        cls, src: Object, property_name: str, val: Optional[Any] = None
    ) -> Message: ...
    @classmethod
    def new_qos(
        cls,
        src: Object,
        live: bool,
        running_time: int,
        stream_time: int,
        timestamp: int,
        duration: int,
    ) -> Message: ...
    @classmethod
    def new_redirect(
        cls,
        src: Object,
        location: str,
        tag_list: Optional[TagList] = None,
        entry_struct: Optional[Structure] = None,
    ) -> Message: ...
    @classmethod
    def new_request_state(cls, src: Optional[Object], state: State) -> Message: ...
    @classmethod
    def new_reset_time(cls, src: Optional[Object], running_time: int) -> Message: ...
    @classmethod
    def new_segment_done(
        cls, src: Optional[Object], format: Format, position: int
    ) -> Message: ...
    @classmethod
    def new_segment_start(
        cls, src: Optional[Object], format: Format, position: int
    ) -> Message: ...
    @classmethod
    def new_state_changed(
        cls, src: Optional[Object], oldstate: State, newstate: State, pending: State
    ) -> Message: ...
    @classmethod
    def new_state_dirty(cls, src: Optional[Object] = None) -> Message: ...
    @classmethod
    def new_step_done(
        cls,
        src: Object,
        format: Format,
        amount: int,
        rate: float,
        flush: bool,
        intermediate: bool,
        duration: int,
        eos: bool,
    ) -> Message: ...
    @classmethod
    def new_step_start(
        cls,
        src: Object,
        active: bool,
        format: Format,
        amount: int,
        rate: float,
        flush: bool,
        intermediate: bool,
    ) -> Message: ...
    @classmethod
    def new_stream_collection(
        cls, src: Object, collection: StreamCollection
    ) -> Message: ...
    @classmethod
    def new_stream_start(cls, src: Optional[Object] = None) -> Message: ...
    @classmethod
    def new_stream_status(
        cls, src: Object, type: StreamStatusType, owner: Element
    ) -> Message: ...
    @classmethod
    def new_streams_selected(
        cls, src: Object, collection: StreamCollection
    ) -> Message: ...
    @classmethod
    def new_structure_change(
        cls,
        src: Optional[Object],
        type: StructureChangeType,
        owner: Element,
        busy: bool,
    ) -> Message: ...
    @classmethod
    def new_tag(cls, src: Optional[Object], tag_list: TagList) -> Message: ...
    @classmethod
    def new_toc(cls, src: Object, toc: Toc, updated: bool) -> Message: ...
    @classmethod
    def new_warning(
        cls, src: Optional[Object], error: GLib.Error, debug: str
    ) -> Message: ...
    @classmethod
    def new_warning_with_details(
        cls,
        src: Optional[Object],
        error: GLib.Error,
        debug: str,
        details: Optional[Structure] = None,
    ) -> Optional[Message]: ...
    def parse_async_done(self) -> int: ...
    def parse_buffering(self) -> int: ...
    def parse_buffering_stats(self) -> Tuple[BufferingMode, int, int, int]: ...
    def parse_clock_lost(self) -> Clock: ...
    def parse_clock_provide(self) -> Tuple[Clock, bool]: ...
    def parse_context_type(self) -> Tuple[bool, str]: ...
    def parse_device_added(self) -> Device: ...
    def parse_device_changed(self) -> Tuple[Device, Device]: ...
    def parse_device_removed(self) -> Device: ...
    def parse_error(self) -> Tuple[GLib.Error, str]: ...
    def parse_error_details(self) -> Structure: ...
    def parse_group_id(self) -> Tuple[bool, int]: ...
    def parse_have_context(self) -> Context: ...
    def parse_info(self) -> Tuple[GLib.Error, str]: ...
    def parse_info_details(self) -> Structure: ...
    def parse_instant_rate_request(self) -> float: ...
    def parse_new_clock(self) -> Clock: ...
    def parse_progress(self) -> Tuple[ProgressType, str, str]: ...
    def parse_property_notify(self) -> Tuple[Object, str, Any]: ...
    def parse_qos(self) -> Tuple[bool, int, int, int, int]: ...
    def parse_qos_stats(self) -> Tuple[Format, int, int]: ...
    def parse_qos_values(self) -> Tuple[int, float, int]: ...
    def parse_redirect_entry(
        self, entry_index: int
    ) -> Tuple[str, TagList, Structure]: ...
    def parse_request_state(self) -> State: ...
    def parse_reset_time(self) -> int: ...
    def parse_segment_done(self) -> Tuple[Format, int]: ...
    def parse_segment_start(self) -> Tuple[Format, int]: ...
    def parse_state_changed(self) -> Tuple[State, State, State]: ...
    def parse_step_done(self) -> Tuple[Format, int, float, bool, bool, int, bool]: ...
    def parse_step_start(self) -> Tuple[bool, Format, int, float, bool, bool]: ...
    def parse_stream_collection(self) -> StreamCollection: ...
    def parse_stream_status(self) -> Tuple[StreamStatusType, Element]: ...
    def parse_streams_selected(self) -> StreamCollection: ...
    def parse_structure_change(self) -> Tuple[StructureChangeType, Element, bool]: ...
    def parse_tag(self) -> TagList: ...
    def parse_toc(self) -> Tuple[Toc, bool]: ...
    def parse_warning(self) -> Tuple[GLib.Error, str]: ...
    def parse_warning_details(self) -> Structure: ...
    def set_buffering_stats(
        self, mode: BufferingMode, avg_in: int, avg_out: int, buffering_left: int
    ) -> None: ...
    def set_group_id(self, group_id: int) -> None: ...
    def set_qos_stats(self, format: Format, processed: int, dropped: int) -> None: ...
    def set_qos_values(self, jitter: int, proportion: float, quality: int) -> None: ...
    def set_seqnum(self, seqnum: int) -> None: ...
    def set_stream_status_object(self, object: Any) -> None: ...
    def streams_selected_add(self, stream: Stream) -> None: ...
    def streams_selected_get_size(self) -> int: ...
    def streams_selected_get_stream(self, idx: int) -> Optional[Stream]: ...
    def writable_structure(self) -> Structure: ...

class Meta(GObject.GPointer):
    flags: MetaFlags = ...
    info: MetaInfo = ...
    @staticmethod
    def api_type_get_tags(api: Type) -> list[str]: ...
    @staticmethod
    def api_type_has_tag(api: Type, tag: int) -> bool: ...
    @staticmethod
    def api_type_register(api: str, tags: Sequence[str]) -> Type: ...
    def compare_seqnum(self, meta2: Meta) -> int: ...
    @staticmethod
    def get_info(impl: str) -> Optional[MetaInfo]: ...
    def get_seqnum(self) -> int: ...
    @staticmethod
    def register(
        api: Type,
        impl: str,
        size: int,
        init_func: Callable[[Meta, None, Buffer], bool],
        free_func: Callable[[Meta, Buffer], None],
        transform_func: Callable[[Buffer, Meta, Buffer, int, None], bool],
    ) -> MetaInfo: ...
    @staticmethod
    def register_custom(
        name: str,
        tags: Sequence[str],
        transform_func: Optional[Callable[..., bool]] = None,
        *user_data: Any,
    ) -> MetaInfo: ...

class MetaInfo(GObject.GPointer):
    api: Type = ...
    type: Type = ...
    size: int = ...
    init_func: Callable[[Meta, None, Buffer], bool] = ...
    free_func: Callable[[Meta, Buffer], None] = ...
    transform_func: Callable[[Buffer, Meta, Buffer, int, None], bool] = ...
    def is_custom(self) -> bool: ...

class MetaTransformCopy(GObject.GPointer):
    region: bool = ...
    offset: int = ...
    size: int = ...

class MiniObject(GObject.GBoxed):
    type: Type = ...
    refcount: int = ...
    lockstate: int = ...
    flags: int = ...
    copy: Callable[[MiniObject], MiniObject] = ...
    dispose: Callable[[MiniObject], bool] = ...
    free: Callable[[MiniObject], None] = ...
    priv_uint: int = ...
    priv_pointer: None = ...
    def add_parent(self, parent: MiniObject) -> None: ...
    def get_qdata(self, quark: int) -> None: ...
    def is_writable(self) -> bool: ...
    def lock(self, flags: LockFlags) -> bool: ...
    def remove_parent(self, parent: MiniObject) -> None: ...
    @staticmethod
    def replace(newdata: Optional[MiniObject] = None) -> Tuple[bool, MiniObject]: ...
    def set_qdata(
        self, quark: int, data: None, destroy: Callable[[None], None]
    ) -> None: ...
    def steal_qdata(self, quark: int) -> None: ...
    @staticmethod
    def take(newdata: MiniObject) -> Tuple[bool, MiniObject]: ...
    def unlock(self, flags: LockFlags) -> None: ...

class Object(GObject.InitiallyUnowned):
    class Props:
        name: Optional[str]
        parent: Optional[Object]
    props: Props = ...
    object: GObject.InitiallyUnowned = ...
    lock: GLib.Mutex = ...
    name: str = ...
    parent: Object = ...
    flags: int = ...
    control_bindings: list[None] = ...
    control_rate: int = ...
    last_sync: int = ...
    _gst_reserved: None = ...
    def __init__(self, name: str = ..., parent: Object = ...): ...
    def add_control_binding(self, binding: ControlBinding) -> bool: ...
    @staticmethod
    def check_uniqueness(list: list[Object], name: str) -> bool: ...
    @staticmethod
    def default_deep_notify(
        object: GObject.Object,
        orig: Object,
        pspec: GObject.ParamSpec,
        excluded_props: Optional[Sequence[str]] = None,
    ) -> None: ...
    def default_error(self, error: GLib.Error, debug: Optional[str] = None) -> None: ...
    def do_deep_notify(self, orig: Object, pspec: GObject.ParamSpec) -> None: ...
    def get_control_binding(self, property_name: str) -> Optional[ControlBinding]: ...
    def get_control_rate(self) -> int: ...
    def get_g_value_array(
        self,
        property_name: str,
        timestamp: int,
        interval: int,
        n_values: int,
        values: Sequence[Any],
    ) -> bool: ...
    def get_name(self) -> Optional[str]: ...
    def get_parent(self) -> Optional[Object]: ...
    def get_path_string(self) -> str: ...
    def get_value(self, property_name: str, timestamp: int) -> Optional[Any]: ...
    def has_active_control_bindings(self) -> bool: ...
    def has_ancestor(self, ancestor: Object) -> bool: ...
    def has_as_ancestor(self, ancestor: Object) -> bool: ...
    def has_as_parent(self, parent: Object) -> bool: ...
    def ref(self) -> Object: ...
    def remove_control_binding(self, binding: ControlBinding) -> bool: ...
    @staticmethod
    def replace(newobj: Optional[Object] = None) -> Tuple[bool, Object]: ...
    def set_control_binding_disabled(
        self, property_name: str, disabled: bool
    ) -> None: ...
    def set_control_bindings_disabled(self, disabled: bool) -> None: ...
    def set_control_rate(self, control_rate: int) -> None: ...
    def set_name(self, name: Optional[str] = None) -> bool: ...
    def set_parent(self, parent: Object) -> bool: ...
    def suggest_next_sync(self) -> int: ...
    def sync_values(self, timestamp: int) -> bool: ...
    def unparent(self) -> None: ...
    def unref(self) -> None: ...

class ObjectClass(GObject.GPointer):
    parent_class: GObject.InitiallyUnownedClass = ...
    path_string_separator: str = ...
    deep_notify: Callable[[Object, Object, GObject.ParamSpec], None] = ...
    _gst_reserved: list[None] = ...

class Pad(Object):
    class Props:
        caps: Caps
        direction: PadDirection
        offset: int
        template: PadTemplate
        name: Optional[str]
        parent: Optional[Object]
    props: Props = ...
    object: Object = ...
    element_private: None = ...
    padtemplate: PadTemplate = ...
    direction: PadDirection = ...
    stream_rec_lock: GLib.RecMutex = ...
    task: Task = ...
    block_cond: GLib.Cond = ...
    probes: GLib.HookList = ...
    mode: PadMode = ...
    activatefunc: Callable[[Pad, Object], bool] = ...
    activatedata: None = ...
    activatenotify: Callable[[None], None] = ...
    activatemodefunc: Callable[[Pad, Object, PadMode, bool], bool] = ...
    activatemodedata: None = ...
    activatemodenotify: Callable[[None], None] = ...
    peer: Pad = ...
    linkfunc: Callable[[Pad, Optional[Object], Pad], PadLinkReturn] = ...
    linkdata: None = ...
    linknotify: Callable[[None], None] = ...
    unlinkfunc: Callable[[Pad, Optional[Object]], None] = ...
    unlinkdata: None = ...
    unlinknotify: Callable[[None], None] = ...
    chainfunc: Callable[[Pad, Optional[Object], Buffer], FlowReturn] = ...
    chaindata: None = ...
    chainnotify: Callable[[None], None] = ...
    chainlistfunc: Callable[[Pad, Optional[Object], BufferList], FlowReturn] = ...
    chainlistdata: None = ...
    chainlistnotify: Callable[[None], None] = ...
    getrangefunc: Callable[[Pad, Optional[Object], int, int, Buffer], FlowReturn] = ...
    getrangedata: None = ...
    getrangenotify: Callable[[None], None] = ...
    eventfunc: Callable[[Pad, Optional[Object], Event], bool] = ...
    eventdata: None = ...
    eventnotify: Callable[[None], None] = ...
    offset: int = ...
    queryfunc: Callable[[Pad, Optional[Object], Query], bool] = ...
    querydata: None = ...
    querynotify: Callable[[None], None] = ...
    iterintlinkfunc: Callable[[Pad, Optional[Object]], Iterator] = ...
    iterintlinkdata: None = ...
    iterintlinknotify: Callable[[None], None] = ...
    num_probes: int = ...
    num_blocked: int = ...
    priv: PadPrivate = ...
    def __init__(
        self,
        direction: PadDirection = ...,
        offset: int = ...,
        template: PadTemplate = ...,
        name: str = ...,
        parent: Object = ...,
    ): ...
    def activate_mode(self, mode: PadMode, active: bool) -> bool: ...
    def add_probe(
        self,
        mask: PadProbeType,
        callback: Callable[..., PadProbeReturn],
        *user_data: Any,
    ) -> int: ...
    def can_link(self, sinkpad: Pad) -> bool: ...
    def chain(self, buffer: Buffer) -> FlowReturn: ...
    def chain_list(self, list: BufferList) -> FlowReturn: ...
    def check_reconfigure(self) -> bool: ...
    def create_stream_id(
        self, parent: Element, stream_id: Optional[str] = None
    ) -> str: ...
    def do_linked(self, peer: Pad) -> None: ...
    def do_unlinked(self, peer: Pad) -> None: ...
    def event_default(self, parent: Optional[Object], event: Event) -> bool: ...
    def forward(self, forward: Callable[..., bool], *user_data: Any) -> bool: ...
    def get_allowed_caps(self) -> Optional[Caps]: ...
    def get_current_caps(self) -> Optional[Caps]: ...
    def get_direction(self) -> PadDirection: ...
    def get_element_private(self) -> None: ...
    def get_last_flow_return(self) -> FlowReturn: ...
    def get_offset(self) -> int: ...
    def get_pad_template(self) -> Optional[PadTemplate]: ...
    def get_pad_template_caps(self) -> Caps: ...
    def get_parent_element(self) -> Optional[Element]: ...
    def get_peer(self) -> Optional[Pad]: ...
    def get_range(self, offset: int, size: int) -> Tuple[FlowReturn, Buffer]: ...
    def get_single_internal_link(self) -> Optional[Pad]: ...
    def get_sticky_event(self, event_type: EventType, idx: int) -> Optional[Event]: ...
    def get_stream(self) -> Optional[Stream]: ...
    def get_stream_id(self) -> Optional[str]: ...
    def get_task_state(self) -> TaskState: ...
    def has_current_caps(self) -> bool: ...
    def is_active(self) -> bool: ...
    def is_blocked(self) -> bool: ...
    def is_blocking(self) -> bool: ...
    def is_linked(self) -> bool: ...
    def iterate_internal_links(self) -> Optional[Iterator]: ...
    def iterate_internal_links_default(
        self, parent: Optional[Object] = None
    ) -> Optional[Iterator]: ...
    def link(self, sinkpad: Pad) -> PadLinkReturn: ...
    def link_full(self, sinkpad: Pad, flags: PadLinkCheck) -> PadLinkReturn: ...
    @staticmethod
    def link_get_name(ret: PadLinkReturn) -> str: ...
    def link_maybe_ghosting(self, sink: Pad) -> bool: ...
    def link_maybe_ghosting_full(self, sink: Pad, flags: PadLinkCheck) -> bool: ...
    def mark_reconfigure(self) -> None: ...
    def needs_reconfigure(self) -> bool: ...
    @classmethod
    def new(cls, name: Optional[str], direction: PadDirection) -> Pad: ...
    @classmethod
    def new_from_static_template(cls, templ: StaticPadTemplate, name: str) -> Pad: ...
    @classmethod
    def new_from_template(
        cls, templ: PadTemplate, name: Optional[str] = None
    ) -> Pad: ...
    def pause_task(self) -> bool: ...
    def peer_query(self, query: Query) -> bool: ...
    def peer_query_accept_caps(self, caps: Caps) -> bool: ...
    def peer_query_caps(self, filter: Optional[Caps] = None) -> Caps: ...
    def peer_query_convert(
        self, src_format: Format, src_val: int, dest_format: Format
    ) -> Tuple[bool, int]: ...
    def peer_query_duration(self, format: Format) -> Tuple[bool, int]: ...
    def peer_query_position(self, format: Format) -> Tuple[bool, int]: ...
    def proxy_query_accept_caps(self, query: Query) -> bool: ...
    def proxy_query_caps(self, query: Query) -> bool: ...
    def pull_range(self, offset: int, size: int) -> Tuple[FlowReturn, Buffer]: ...
    def push(self, buffer: Buffer) -> FlowReturn: ...
    def push_event(self, event: Event) -> bool: ...
    def push_list(self, list: BufferList) -> FlowReturn: ...
    def query(self, query: Query) -> bool: ...
    def query_accept_caps(self, caps: Caps) -> bool: ...
    def query_caps(self, filter: Optional[Caps] = None) -> Caps: ...
    def query_convert(
        self, src_format: Format, src_val: int, dest_format: Format
    ) -> Tuple[bool, int]: ...
    def query_default(self, parent: Optional[Object], query: Query) -> bool: ...
    def query_duration(self, format: Format) -> Tuple[bool, int]: ...
    def query_position(self, format: Format) -> Tuple[bool, int]: ...
    def remove_probe(self, id: int) -> None: ...
    def send_event(self, event: Event) -> bool: ...
    def set_activate_function_full(
        self, activate: Callable[[Pad, Object], bool], *user_data: Any
    ) -> None: ...
    def set_activatemode_function_full(
        self,
        activatemode: Callable[[Pad, Object, PadMode, bool], bool],
        *user_data: Any,
    ) -> None: ...
    def set_active(self, active: bool) -> bool: ...
    def set_chain_function_full(
        self,
        chain: Callable[[Pad, Optional[Object], Buffer], FlowReturn],
        *user_data: Any,
    ) -> None: ...
    def set_chain_list_function_full(
        self,
        chainlist: Callable[[Pad, Optional[Object], BufferList], FlowReturn],
        *user_data: Any,
    ) -> None: ...
    def set_element_private(self, priv: None) -> None: ...
    def set_event_full_function_full(
        self,
        event: Callable[[Pad, Optional[Object], Event], FlowReturn],
        *user_data: Any,
    ) -> None: ...
    def set_event_function_full(
        self, event: Callable[[Pad, Optional[Object], Event], bool], *user_data: Any
    ) -> None: ...
    def set_getrange_function_full(
        self,
        get: Callable[[Pad, Optional[Object], int, int, Buffer], FlowReturn],
        *user_data: Any,
    ) -> None: ...
    def set_iterate_internal_links_function_full(
        self, iterintlink: Callable[[Pad, Optional[Object]], Iterator], *user_data: Any
    ) -> None: ...
    def set_link_function_full(
        self,
        link: Callable[[Pad, Optional[Object], Pad], PadLinkReturn],
        *user_data: Any,
    ) -> None: ...
    def set_offset(self, offset: int) -> None: ...
    def set_query_function_full(
        self, query: Callable[[Pad, Optional[Object], Query], bool], *user_data: Any
    ) -> None: ...
    def set_unlink_function_full(
        self, unlink: Callable[[Pad, Optional[Object]], None], *user_data: Any
    ) -> None: ...
    def start_task(self, func: Callable[..., None], *user_data: Any) -> bool: ...
    def sticky_events_foreach(
        self, foreach_func: Callable[..., bool], *user_data: Any
    ) -> None: ...
    def stop_task(self) -> bool: ...
    def store_sticky_event(self, event: Event) -> FlowReturn: ...
    def unlink(self, sinkpad: Pad) -> bool: ...
    def use_fixed_caps(self) -> None: ...

class PadClass(GObject.GPointer):
    parent_class: ObjectClass = ...
    linked: Callable[[Pad, Pad], None] = ...
    unlinked: Callable[[Pad, Pad], None] = ...
    _gst_reserved: list[None] = ...

class PadPrivate(GObject.GPointer): ...

class PadProbeInfo(GObject.GPointer):
    type: PadProbeType = ...
    id: int = ...
    data: None = ...
    offset: int = ...
    size: int = ...
    def get_buffer(self) -> Optional[Buffer]: ...
    def get_buffer_list(self) -> Optional[BufferList]: ...
    def get_event(self) -> Optional[Event]: ...
    def get_query(self) -> Optional[Query]: ...

class PadTemplate(Object):
    class Props:
        caps: Caps
        direction: PadDirection
        gtype: Type
        name_template: str
        presence: PadPresence
        name: Optional[str]
        parent: Optional[Object]
    props: Props = ...
    object: Object = ...
    name_template: str = ...
    direction: PadDirection = ...
    presence: PadPresence = ...
    caps: Caps = ...
    def __init__(
        self,
        caps: Caps = ...,
        direction: PadDirection = ...,
        gtype: Type = ...,
        name_template: str = ...,
        presence: PadPresence = ...,
        name: str = ...,
        parent: Object = ...,
    ): ...
    def do_pad_created(self, pad: Pad) -> None: ...
    def get_caps(self) -> Caps: ...
    def get_documentation_caps(self) -> Caps: ...
    @classmethod
    def new(
        cls,
        name_template: str,
        direction: PadDirection,
        presence: PadPresence,
        caps: Caps,
    ) -> Optional[PadTemplate]: ...
    @classmethod
    def new_from_static_pad_template_with_gtype(
        cls, pad_template: StaticPadTemplate, pad_type: Type
    ) -> Optional[PadTemplate]: ...
    @classmethod
    def new_with_gtype(
        cls,
        name_template: str,
        direction: PadDirection,
        presence: PadPresence,
        caps: Caps,
        pad_type: Type,
    ) -> Optional[PadTemplate]: ...
    def pad_created(self, pad: Pad) -> None: ...
    def set_documentation_caps(self, caps: Caps) -> None: ...

class PadTemplateClass(GObject.GPointer):
    parent_class: ObjectClass = ...
    pad_created: Callable[[PadTemplate, Pad], None] = ...
    _gst_reserved: list[None] = ...

class ParamArray(GObject.ParamSpec): ...
class ParamFraction(GObject.ParamSpec): ...

class ParamSpecArray(GObject.GPointer):
    parent_instance: GObject.ParamSpec = ...
    element_spec: GObject.ParamSpec = ...

class ParamSpecFraction(GObject.GPointer):
    parent_instance: GObject.ParamSpec = ...
    min_num: int = ...
    min_den: int = ...
    max_num: int = ...
    max_den: int = ...
    def_num: int = ...
    def_den: int = ...

class ParentBufferMeta(GObject.GPointer):
    parent: Meta = ...
    buffer: Buffer = ...
    @staticmethod
    def get_info() -> MetaInfo: ...

class ParseContext(GObject.GBoxed):
    def copy(self) -> Optional[ParseContext]: ...
    def free(self) -> None: ...
    def get_missing_elements(self) -> Optional[list[str]]: ...
    @classmethod
    def new(cls) -> Optional[ParseContext]: ...

class Pipeline(Bin, ChildProxy):
    class Props:
        auto_flush_bus: bool
        delay: int
        latency: int
        async_handling: bool
        message_forward: bool
        name: Optional[str]
        parent: Optional[Object]
    props: Props = ...
    bin: Bin = ...
    fixed_clock: Clock = ...
    stream_time: int = ...
    delay: int = ...
    priv: PipelinePrivate = ...
    _gst_reserved: list[None] = ...
    def __init__(
        self,
        auto_flush_bus: bool = ...,
        delay: int = ...,
        latency: int = ...,
        async_handling: bool = ...,
        message_forward: bool = ...,
        name: str = ...,
        parent: Object = ...,
    ): ...
    def auto_clock(self) -> None: ...
    def get_auto_flush_bus(self) -> bool: ...
    def get_bus(self) -> Bus: ...
    def get_delay(self) -> int: ...
    def get_latency(self) -> int: ...
    def get_pipeline_clock(self) -> Clock: ...
    @classmethod
    def new(cls, name: Optional[str] = None) -> Pipeline: ...
    def set_auto_flush_bus(self, auto_flush: bool) -> None: ...
    def set_delay(self, delay: int) -> None: ...
    def set_latency(self, latency: int) -> None: ...
    def use_clock(self, clock: Optional[Clock] = None) -> None: ...

class PipelineClass(GObject.GPointer):
    parent_class: BinClass = ...
    _gst_reserved: list[None] = ...

class PipelinePrivate(GObject.GPointer): ...

class Plugin(Object):
    class Props:
        name: Optional[str]
        parent: Optional[Object]
    props: Props = ...
    def __init__(self, name: str = ..., parent: Object = ...): ...
    def add_dependency(
        self,
        env_vars: Optional[Sequence[str]],
        paths: Optional[Sequence[str]],
        names: Optional[Sequence[str]],
        flags: PluginDependencyFlags,
    ) -> None: ...
    def add_dependency_simple(
        self,
        env_vars: Optional[str],
        paths: Optional[str],
        names: Optional[str],
        flags: PluginDependencyFlags,
    ) -> None: ...
    def get_cache_data(self) -> Optional[Structure]: ...
    def get_description(self) -> str: ...
    def get_filename(self) -> Optional[str]: ...
    def get_license(self) -> str: ...
    def get_name(self) -> str: ...
    def get_origin(self) -> str: ...
    def get_package(self) -> str: ...
    def get_release_date_string(self) -> Optional[str]: ...
    def get_source(self) -> str: ...
    def get_version(self) -> str: ...
    def is_loaded(self) -> bool: ...
    @staticmethod
    def list_free(list: list[Plugin]) -> None: ...
    def load(self) -> Optional[Plugin]: ...
    @staticmethod
    def load_by_name(name: str) -> Optional[Plugin]: ...
    @staticmethod
    def load_file(filename: str) -> Plugin: ...
    @staticmethod
    def register_static(
        major_version: int,
        minor_version: int,
        name: str,
        description: str,
        init_func: Callable[[Plugin], bool],
        version: str,
        license: str,
        source: str,
        package: str,
        origin: str,
    ) -> bool: ...
    @staticmethod
    def register_static_full(
        major_version: int,
        minor_version: int,
        name: str,
        description: str,
        init_full_func: Callable[..., bool],
        version: str,
        license: str,
        source: str,
        package: str,
        origin: str,
        *user_data: Any,
    ) -> bool: ...
    def set_cache_data(self, cache_data: Structure) -> None: ...

class PluginClass(GObject.GPointer): ...

class PluginDesc(GObject.GPointer):
    major_version: int = ...
    minor_version: int = ...
    name: str = ...
    description: str = ...
    plugin_init: Callable[[Plugin], bool] = ...
    version: str = ...
    license: str = ...
    source: str = ...
    package: str = ...
    origin: str = ...
    release_datetime: str = ...
    _gst_reserved: list[None] = ...

class PluginFeature(Object):
    class Props:
        name: Optional[str]
        parent: Optional[Object]
    props: Props = ...
    def __init__(self, name: str = ..., parent: Object = ...): ...
    def check_version(self, min_major: int, min_minor: int, min_micro: int) -> bool: ...
    def get_plugin(self) -> Optional[Plugin]: ...
    def get_plugin_name(self) -> Optional[str]: ...
    def get_rank(self) -> int: ...
    @staticmethod
    def list_copy(list: list[PluginFeature]) -> list[PluginFeature]: ...
    @staticmethod
    def list_debug(list: list[PluginFeature]) -> None: ...
    @staticmethod
    def list_free(list: list[PluginFeature]) -> None: ...
    def load(self) -> Optional[PluginFeature]: ...
    @staticmethod
    def rank_compare_func(p1: None, p2: None) -> int: ...
    def set_rank(self, rank: int) -> None: ...

class PluginFeatureClass(GObject.GPointer): ...

class Poll(GObject.GPointer):
    def add_fd(self, fd: PollFD) -> bool: ...
    def fd_can_read(self, fd: PollFD) -> bool: ...
    def fd_can_write(self, fd: PollFD) -> bool: ...
    def fd_ctl_pri(self, fd: PollFD, active: bool) -> bool: ...
    def fd_ctl_read(self, fd: PollFD, active: bool) -> bool: ...
    def fd_ctl_write(self, fd: PollFD, active: bool) -> bool: ...
    def fd_has_closed(self, fd: PollFD) -> bool: ...
    def fd_has_error(self, fd: PollFD) -> bool: ...
    def fd_has_pri(self, fd: PollFD) -> bool: ...
    def fd_ignored(self, fd: PollFD) -> None: ...
    def free(self) -> None: ...
    def get_read_gpollfd(self, fd: GLib.PollFD) -> None: ...
    def read_control(self) -> bool: ...
    def remove_fd(self, fd: PollFD) -> bool: ...
    def restart(self) -> None: ...
    def set_controllable(self, controllable: bool) -> bool: ...
    def set_flushing(self, flushing: bool) -> None: ...
    def wait(self, timeout: int) -> int: ...
    def write_control(self) -> bool: ...

class PollFD(GObject.GPointer):
    fd: int = ...
    idx: int = ...
    def init(self) -> None: ...

class Preset(GObject.GInterface):
    def delete_preset(self, name: str) -> bool: ...
    @staticmethod
    def get_app_dir() -> Optional[str]: ...
    def get_meta(self, name: str, tag: str) -> Tuple[bool, str]: ...
    def get_preset_names(self) -> list[str]: ...
    def get_property_names(self) -> list[str]: ...
    def is_editable(self) -> bool: ...
    def load_preset(self, name: str) -> bool: ...
    def rename_preset(self, old_name: str, new_name: str) -> bool: ...
    def save_preset(self, name: str) -> bool: ...
    @staticmethod
    def set_app_dir(app_dir: str) -> bool: ...
    def set_meta(self, name: str, tag: str, value: Optional[str] = None) -> bool: ...

class PresetInterface(GObject.GPointer):
    parent: GObject.TypeInterface = ...
    get_preset_names: Callable[[Preset], list[str]] = ...
    get_property_names: Callable[[Preset], list[str]] = ...
    load_preset: Callable[[Preset, str], bool] = ...
    save_preset: Callable[[Preset, str], bool] = ...
    rename_preset: Callable[[Preset, str, str], bool] = ...
    delete_preset: Callable[[Preset, str], bool] = ...
    set_meta: Callable[[Preset, str, str, Optional[str]], bool] = ...
    get_meta: Callable[[Preset, str, str], Tuple[bool, str]] = ...
    _gst_reserved: list[None] = ...

class Promise(GObject.GBoxed):
    parent: MiniObject = ...
    def expire(self) -> None: ...
    def get_reply(self) -> Optional[Structure]: ...
    def interrupt(self) -> None: ...
    @classmethod
    def new(cls) -> Promise: ...
    @classmethod
    def new_with_change_func(
        cls, func: Callable[..., None], *user_data: Any
    ) -> Promise: ...
    def reply(self, s: Optional[Structure] = None) -> None: ...
    def wait(self) -> PromiseResult: ...

class ProtectionMeta(GObject.GPointer):
    meta: Meta = ...
    info: Structure = ...
    @staticmethod
    def get_info() -> MetaInfo: ...

class ProxyPad(Pad):
    class Props:
        caps: Caps
        direction: PadDirection
        offset: int
        template: PadTemplate
        name: Optional[str]
        parent: Optional[Object]
    props: Props = ...
    pad: Pad = ...
    priv: ProxyPadPrivate = ...
    def __init__(
        self,
        direction: PadDirection = ...,
        offset: int = ...,
        template: PadTemplate = ...,
        name: str = ...,
        parent: Object = ...,
    ): ...
    @staticmethod
    def chain_default(
        pad: Pad, parent: Optional[Object], buffer: Buffer
    ) -> FlowReturn: ...
    @staticmethod
    def chain_list_default(
        pad: Pad, parent: Optional[Object], list: BufferList
    ) -> FlowReturn: ...
    def get_internal(self) -> Optional[ProxyPad]: ...
    @staticmethod
    def getrange_default(
        pad: Pad, parent: Object, offset: int, size: int
    ) -> Tuple[FlowReturn, Buffer]: ...
    @staticmethod
    def iterate_internal_links_default(
        pad: Pad, parent: Optional[Object] = None
    ) -> Optional[Iterator]: ...

class ProxyPadClass(GObject.GPointer):
    parent_class: PadClass = ...
    _gst_reserved: list[None] = ...

class ProxyPadPrivate(GObject.GPointer): ...

class Query(GObject.GBoxed):
    mini_object: MiniObject = ...
    type: QueryType = ...
    def add_allocation_meta(
        self, api: Type, params: Optional[Structure] = None
    ) -> None: ...
    def add_allocation_param(
        self,
        allocator: Optional[Allocator] = None,
        params: Optional[AllocationParams] = None,
    ) -> None: ...
    def add_allocation_pool(
        self, pool: Optional[BufferPool], size: int, min_buffers: int, max_buffers: int
    ) -> None: ...
    def add_buffering_range(self, start: int, stop: int) -> bool: ...
    def add_scheduling_mode(self, mode: PadMode) -> None: ...
    def find_allocation_meta(self, api: Type) -> Tuple[bool, int]: ...
    def get_n_allocation_metas(self) -> int: ...
    def get_n_allocation_params(self) -> int: ...
    def get_n_allocation_pools(self) -> int: ...
    def get_n_buffering_ranges(self) -> int: ...
    def get_n_scheduling_modes(self) -> int: ...
    def get_structure(self) -> Optional[Structure]: ...
    def has_scheduling_mode(self, mode: PadMode) -> bool: ...
    def has_scheduling_mode_with_flags(
        self, mode: PadMode, flags: SchedulingFlags
    ) -> bool: ...
    @classmethod
    def new_accept_caps(cls, caps: Caps) -> Query: ...
    @classmethod
    def new_allocation(cls, caps: Caps, need_pool: bool) -> Query: ...
    @classmethod
    def new_bitrate(cls) -> Query: ...
    @classmethod
    def new_buffering(cls, format: Format) -> Query: ...
    @classmethod
    def new_caps(cls, filter: Caps) -> Query: ...
    @classmethod
    def new_context(cls, context_type: str) -> Query: ...
    @classmethod
    def new_convert(
        cls, src_format: Format, value: int, dest_format: Format
    ) -> Query: ...
    @classmethod
    def new_custom(
        cls, type: QueryType, structure: Optional[Structure] = None
    ) -> Optional[Query]: ...
    @classmethod
    def new_drain(cls) -> Query: ...
    @classmethod
    def new_duration(cls, format: Format) -> Query: ...
    @classmethod
    def new_formats(cls) -> Query: ...
    @classmethod
    def new_latency(cls) -> Query: ...
    @classmethod
    def new_position(cls, format: Format) -> Query: ...
    @classmethod
    def new_scheduling(cls) -> Query: ...
    @classmethod
    def new_seeking(cls, format: Format) -> Query: ...
    @classmethod
    def new_segment(cls, format: Format) -> Query: ...
    @classmethod
    def new_uri(cls) -> Query: ...
    def parse_accept_caps(self) -> Caps: ...
    def parse_accept_caps_result(self) -> bool: ...
    def parse_allocation(self) -> Tuple[Caps, bool]: ...
    def parse_bitrate(self) -> int: ...
    def parse_buffering_percent(self) -> Tuple[bool, int]: ...
    def parse_buffering_range(self) -> Tuple[Format, int, int, int]: ...
    def parse_buffering_stats(self) -> Tuple[BufferingMode, int, int, int]: ...
    def parse_caps(self) -> Caps: ...
    def parse_caps_result(self) -> Caps: ...
    def parse_context(self) -> Context: ...
    def parse_context_type(self) -> Tuple[bool, str]: ...
    def parse_convert(self) -> Tuple[Format, int, Format, int]: ...
    def parse_duration(self) -> Tuple[Format, int]: ...
    def parse_latency(self) -> Tuple[bool, int, int]: ...
    def parse_n_formats(self) -> int: ...
    def parse_nth_allocation_meta(self, index: int) -> Tuple[Type, Structure]: ...
    def parse_nth_allocation_param(
        self, index: int
    ) -> Tuple[Allocator, AllocationParams]: ...
    def parse_nth_allocation_pool(
        self, index: int
    ) -> Tuple[BufferPool, int, int, int]: ...
    def parse_nth_buffering_range(self, index: int) -> Tuple[bool, int, int]: ...
    def parse_nth_format(self, nth: int) -> Format: ...
    def parse_nth_scheduling_mode(self, index: int) -> PadMode: ...
    def parse_position(self) -> Tuple[Format, int]: ...
    def parse_scheduling(self) -> Tuple[SchedulingFlags, int, int, int]: ...
    def parse_seeking(self) -> Tuple[Format, bool, int, int]: ...
    def parse_segment(self) -> Tuple[float, Format, int, int]: ...
    def parse_uri(self) -> str: ...
    def parse_uri_redirection(self) -> str: ...
    def parse_uri_redirection_permanent(self) -> bool: ...
    def remove_nth_allocation_meta(self, index: int) -> None: ...
    def remove_nth_allocation_param(self, index: int) -> None: ...
    def remove_nth_allocation_pool(self, index: int) -> None: ...
    def set_accept_caps_result(self, result: bool) -> None: ...
    def set_bitrate(self, nominal_bitrate: int) -> None: ...
    def set_buffering_percent(self, busy: bool, percent: int) -> None: ...
    def set_buffering_range(
        self, format: Format, start: int, stop: int, estimated_total: int
    ) -> None: ...
    def set_buffering_stats(
        self, mode: BufferingMode, avg_in: int, avg_out: int, buffering_left: int
    ) -> None: ...
    def set_caps_result(self, caps: Caps) -> None: ...
    def set_context(self, context: Context) -> None: ...
    def set_convert(
        self, src_format: Format, src_value: int, dest_format: Format, dest_value: int
    ) -> None: ...
    def set_duration(self, format: Format, duration: int) -> None: ...
    def set_formatsv(self, n_formats: int, formats: Sequence[Format]) -> None: ...
    def set_latency(self, live: bool, min_latency: int, max_latency: int) -> None: ...
    def set_nth_allocation_param(
        self,
        index: int,
        allocator: Optional[Allocator] = None,
        params: Optional[AllocationParams] = None,
    ) -> None: ...
    def set_nth_allocation_pool(
        self,
        index: int,
        pool: Optional[BufferPool],
        size: int,
        min_buffers: int,
        max_buffers: int,
    ) -> None: ...
    def set_position(self, format: Format, cur: int) -> None: ...
    def set_scheduling(
        self, flags: SchedulingFlags, minsize: int, maxsize: int, align: int
    ) -> None: ...
    def set_seeking(
        self, format: Format, seekable: bool, segment_start: int, segment_end: int
    ) -> None: ...
    def set_segment(
        self, rate: float, format: Format, start_value: int, stop_value: int
    ) -> None: ...
    def set_uri(self, uri: str) -> None: ...
    def set_uri_redirection(self, uri: str) -> None: ...
    def set_uri_redirection_permanent(self, permanent: bool) -> None: ...
    def writable_structure(self) -> Structure: ...

class ReferenceTimestampMeta(GObject.GPointer):
    parent: Meta = ...
    reference: Caps = ...
    timestamp: int = ...
    duration: int = ...
    @staticmethod
    def get_info() -> MetaInfo: ...

class Registry(Object):
    class Props:
        name: Optional[str]
        parent: Optional[Object]
    props: Props = ...
    object: Object = ...
    priv: RegistryPrivate = ...
    def __init__(self, name: str = ..., parent: Object = ...): ...
    def add_feature(self, feature: PluginFeature) -> bool: ...
    def add_plugin(self, plugin: Plugin) -> bool: ...
    def check_feature_version(
        self, feature_name: str, min_major: int, min_minor: int, min_micro: int
    ) -> bool: ...
    def feature_filter(
        self, filter: Callable[..., bool], first: bool, *user_data: Any
    ) -> list[PluginFeature]: ...
    def find_feature(self, name: str, type: Type) -> Optional[PluginFeature]: ...
    def find_plugin(self, name: str) -> Optional[Plugin]: ...
    @staticmethod
    def fork_is_enabled() -> bool: ...
    @staticmethod
    def fork_set_enabled(enabled: bool) -> None: ...
    @staticmethod
    def get() -> Registry: ...
    def get_feature_list(self, type: Type) -> list[PluginFeature]: ...
    def get_feature_list_by_plugin(self, name: str) -> list[PluginFeature]: ...
    def get_feature_list_cookie(self) -> int: ...
    def get_plugin_list(self) -> list[Plugin]: ...
    def lookup(self, filename: str) -> Optional[Plugin]: ...
    def lookup_feature(self, name: str) -> Optional[PluginFeature]: ...
    def plugin_filter(
        self, filter: Callable[..., bool], first: bool, *user_data: Any
    ) -> list[Plugin]: ...
    def remove_feature(self, feature: PluginFeature) -> None: ...
    def remove_plugin(self, plugin: Plugin) -> None: ...
    def scan_path(self, path: str) -> bool: ...

class RegistryClass(GObject.GPointer):
    parent_class: ObjectClass = ...

class RegistryPrivate(GObject.GPointer): ...

class Sample(GObject.GBoxed):
    def get_buffer(self) -> Optional[Buffer]: ...
    def get_buffer_list(self) -> Optional[BufferList]: ...
    def get_caps(self) -> Optional[Caps]: ...
    def get_info(self) -> Optional[Structure]: ...
    def get_segment(self) -> Segment: ...
    @classmethod
    def new(
        cls,
        buffer: Optional[Buffer] = None,
        caps: Optional[Caps] = None,
        segment: Optional[Segment] = None,
        info: Optional[Structure] = None,
    ) -> Sample: ...
    def set_buffer(self, buffer: Buffer) -> None: ...
    def set_buffer_list(self, buffer_list: BufferList) -> None: ...
    def set_caps(self, caps: Caps) -> None: ...
    def set_info(self, info: Structure) -> bool: ...
    def set_segment(self, segment: Segment) -> None: ...

class Segment(GObject.GBoxed):
    flags: SegmentFlags = ...
    rate: float = ...
    applied_rate: float = ...
    format: Format = ...
    base: int = ...
    offset: int = ...
    start: int = ...
    stop: int = ...
    time: int = ...
    position: int = ...
    duration: int = ...
    _gst_reserved: list[None] = ...
    def clip(self, format: Format, start: int, stop: int) -> Tuple[bool, int, int]: ...
    def copy(self) -> Segment: ...
    def copy_into(self, dest: Segment) -> None: ...
    def do_seek(
        self,
        rate: float,
        format: Format,
        flags: SeekFlags,
        start_type: SeekType,
        start: int,
        stop_type: SeekType,
        stop: int,
    ) -> Tuple[bool, bool]: ...
    def free(self) -> None: ...
    def init(self, format: Format) -> None: ...
    def is_equal(self, s1: Segment) -> bool: ...
    @classmethod
    def new(cls) -> Segment: ...
    def offset_running_time(self, format: Format, offset: int) -> bool: ...
    def position_from_running_time(self, format: Format, running_time: int) -> int: ...
    def position_from_running_time_full(
        self, format: Format, running_time: int
    ) -> Tuple[int, int]: ...
    def position_from_stream_time(self, format: Format, stream_time: int) -> int: ...
    def position_from_stream_time_full(
        self, format: Format, stream_time: int
    ) -> Tuple[int, int]: ...
    def set_running_time(self, format: Format, running_time: int) -> bool: ...
    def to_position(self, format: Format, running_time: int) -> int: ...
    def to_running_time(self, format: Format, position: int) -> int: ...
    def to_running_time_full(
        self, format: Format, position: int
    ) -> Tuple[int, int]: ...
    def to_stream_time(self, format: Format, position: int) -> int: ...
    def to_stream_time_full(self, format: Format, position: int) -> Tuple[int, int]: ...

class SharedTaskPool(TaskPool):
    class Props:
        name: Optional[str]
        parent: Optional[Object]
    props: Props = ...
    parent: TaskPool = ...
    priv: SharedTaskPoolPrivate = ...
    _gst_reserved: list[None] = ...
    def __init__(self, name: str = ..., parent: Object = ...): ...
    def get_max_threads(self) -> int: ...
    @classmethod
    def new(cls) -> SharedTaskPool: ...
    def set_max_threads(self, max_threads: int) -> None: ...

class SharedTaskPoolClass(GObject.GPointer):
    parent_class: TaskPoolClass = ...
    _gst_reserved: list[None] = ...

class SharedTaskPoolPrivate(GObject.GPointer): ...

class StaticCaps(GObject.GPointer):
    caps: Caps = ...
    string: str = ...
    _gst_reserved: list[None] = ...
    def cleanup(self) -> None: ...
    def get(self) -> Optional[Caps]: ...

class StaticPadTemplate(GObject.GPointer):
    name_template: str = ...
    direction: PadDirection = ...
    presence: PadPresence = ...
    static_caps: StaticCaps = ...
    def get(self) -> Optional[PadTemplate]: ...
    def get_caps(self) -> Caps: ...

class Stream(Object):
    class Props:
        caps: Optional[Caps]
        stream_flags: StreamFlags
        stream_id: Optional[str]
        stream_type: StreamType
        tags: Optional[TagList]
        name: Optional[str]
        parent: Optional[Object]
    props: Props = ...
    object: Object = ...
    stream_id: str = ...
    priv: StreamPrivate = ...
    _gst_reserved: list[None] = ...
    def __init__(
        self,
        caps: Caps = ...,
        stream_flags: StreamFlags = ...,
        stream_id: str = ...,
        stream_type: StreamType = ...,
        tags: TagList = ...,
        name: str = ...,
        parent: Object = ...,
    ): ...
    def get_caps(self) -> Optional[Caps]: ...
    def get_stream_flags(self) -> StreamFlags: ...
    def get_stream_id(self) -> Optional[str]: ...
    def get_stream_type(self) -> StreamType: ...
    def get_tags(self) -> Optional[TagList]: ...
    @classmethod
    def new(
        cls,
        stream_id: Optional[str],
        caps: Optional[Caps],
        type: StreamType,
        flags: StreamFlags,
    ) -> Stream: ...
    def set_caps(self, caps: Optional[Caps] = None) -> None: ...
    def set_stream_flags(self, flags: StreamFlags) -> None: ...
    def set_stream_type(self, stream_type: StreamType) -> None: ...
    def set_tags(self, tags: Optional[TagList] = None) -> None: ...

class StreamClass(GObject.GPointer):
    parent_class: ObjectClass = ...
    _gst_reserved: list[None] = ...

class StreamCollection(Object):
    class Props:
        upstream_id: Optional[str]
        name: Optional[str]
        parent: Optional[Object]
    props: Props = ...
    object: Object = ...
    upstream_id: str = ...
    priv: StreamCollectionPrivate = ...
    _gst_reserved: list[None] = ...
    def __init__(
        self, upstream_id: str = ..., name: str = ..., parent: Object = ...
    ): ...
    def add_stream(self, stream: Stream) -> bool: ...
    def do_stream_notify(self, stream: Stream, pspec: GObject.ParamSpec) -> None: ...
    def get_size(self) -> int: ...
    def get_stream(self, index: int) -> Optional[Stream]: ...
    def get_upstream_id(self) -> Optional[str]: ...
    @classmethod
    def new(cls, upstream_id: Optional[str] = None) -> StreamCollection: ...

class StreamCollectionClass(GObject.GPointer):
    parent_class: ObjectClass = ...
    stream_notify: Callable[[StreamCollection, Stream, GObject.ParamSpec], None] = ...
    _gst_reserved: list[None] = ...

class StreamCollectionPrivate(GObject.GPointer): ...
class StreamPrivate(GObject.GPointer): ...

class Structure(GObject.GBoxed):
    type: Type = ...
    name: int = ...
    def can_intersect(self, struct2: Structure) -> bool: ...
    def copy(self) -> Structure: ...
    def filter_and_map_in_place(
        self, func: Callable[..., bool], *user_data: Any
    ) -> None: ...
    def fixate(self) -> None: ...
    def fixate_field(self, field_name: str) -> bool: ...
    def fixate_field_boolean(self, field_name: str, target: bool) -> bool: ...
    def fixate_field_nearest_double(self, field_name: str, target: float) -> bool: ...
    def fixate_field_nearest_fraction(
        self, field_name: str, target_numerator: int, target_denominator: int
    ) -> bool: ...
    def fixate_field_nearest_int(self, field_name: str, target: int) -> bool: ...
    def fixate_field_string(self, field_name: str, target: str) -> bool: ...
    def foreach(self, func: Callable[..., bool], *user_data: Any) -> bool: ...
    def free(self) -> None: ...
    @classmethod
    def from_string(cls, string: str) -> Structure: ...
    def get_array(self, fieldname: str) -> Tuple[bool, GObject.ValueArray]: ...
    def get_boolean(self, fieldname: str) -> Tuple[bool, bool]: ...
    def get_clock_time(self, fieldname: str) -> Tuple[bool, int]: ...
    def get_date(self, fieldname: str) -> Tuple[bool, GLib.Date]: ...
    def get_date_time(self, fieldname: str) -> Tuple[bool, DateTime]: ...
    def get_double(self, fieldname: str) -> Tuple[bool, float]: ...
    def get_enum(self, fieldname: str, enumtype: Type) -> Tuple[bool, int]: ...
    def get_field_type(self, fieldname: str) -> Type: ...
    def get_flagset(self, fieldname: str) -> Tuple[bool, int, int]: ...
    def get_fraction(self, fieldname: str) -> Tuple[bool, int, int]: ...
    def get_int(self, fieldname: str) -> Tuple[bool, int]: ...
    def get_int64(self, fieldname: str) -> Tuple[bool, int]: ...
    def get_list(self, fieldname: str) -> Tuple[bool, GObject.ValueArray]: ...
    def get_name(self) -> str: ...
    def get_name_id(self) -> int: ...
    def get_string(self, fieldname: str) -> Optional[str]: ...
    def get_uint(self, fieldname: str) -> Tuple[bool, int]: ...
    def get_uint64(self, fieldname: str) -> Tuple[bool, int]: ...
    def get_value(self, fieldname: str) -> Optional[Any]: ...
    def has_field(self, fieldname: str) -> bool: ...
    def has_field_typed(self, fieldname: str, type: Type) -> bool: ...
    def has_name(self, name: str) -> bool: ...
    def id_get_value(self, field: int) -> Optional[Any]: ...
    def id_has_field(self, field: int) -> bool: ...
    def id_has_field_typed(self, field: int, type: Type) -> bool: ...
    def id_set_value(self, field: int, value: Any) -> None: ...
    def id_take_value(self, field: int, value: Any) -> None: ...
    def intersect(self, struct2: Structure) -> Optional[Structure]: ...
    def is_equal(self, structure2: Structure) -> bool: ...
    def is_subset(self, superset: Structure) -> bool: ...
    def map_in_place(self, func: Callable[..., bool], *user_data: Any) -> bool: ...
    def n_fields(self) -> int: ...
    @classmethod
    def new_empty(cls, name: str) -> Structure: ...
    @classmethod
    def new_from_string(cls, string: str) -> Optional[Structure]: ...
    @classmethod
    def new_id_empty(cls, quark: int) -> Structure: ...
    def nth_field_name(self, index: int) -> str: ...
    def remove_all_fields(self) -> None: ...
    def remove_field(self, fieldname: str) -> None: ...
    def serialize(self, flags: SerializeFlags) -> str: ...
    def set_array(self, fieldname: str, array: GObject.ValueArray) -> None: ...
    def set_list(self, fieldname: str, array: GObject.ValueArray) -> None: ...
    def set_name(self, name: str) -> None: ...
    def set_parent_refcount(self, refcount: int) -> bool: ...
    def set_value(self, fieldname: str, value: Any) -> None: ...
    @staticmethod
    def take(newstr: Optional[Structure] = None) -> Tuple[bool, Structure]: ...
    def take_value(self, fieldname: str, value: Any) -> None: ...
    def to_string(self) -> str: ...

class SystemClock(Clock):
    class Props:
        clock_type: ClockType
        timeout: int
        window_size: int
        window_threshold: int
        name: Optional[str]
        parent: Optional[Object]
    props: Props = ...
    clock: Clock = ...
    priv: SystemClockPrivate = ...
    _gst_reserved: list[None] = ...
    def __init__(
        self,
        clock_type: ClockType = ...,
        timeout: int = ...,
        window_size: int = ...,
        window_threshold: int = ...,
        name: str = ...,
        parent: Object = ...,
    ): ...
    @staticmethod
    def obtain() -> Clock: ...
    @staticmethod
    def set_default(new_clock: Optional[Clock] = None) -> None: ...

class SystemClockClass(GObject.GPointer):
    parent_class: ClockClass = ...
    _gst_reserved: list[None] = ...

class SystemClockPrivate(GObject.GPointer): ...

class TagList(GObject.GBoxed):
    mini_object: MiniObject = ...
    def add_value(self, mode: TagMergeMode, tag: str, value: Any) -> None: ...
    def copy(self) -> TagList: ...
    @staticmethod
    def copy_value(list: TagList, tag: str) -> Tuple[bool, Any]: ...
    def foreach(self, func: Callable[..., None], *user_data: Any) -> None: ...
    def get_boolean(self, tag: str) -> Tuple[bool, bool]: ...
    def get_boolean_index(self, tag: str, index: int) -> Tuple[bool, bool]: ...
    def get_date(self, tag: str) -> Tuple[bool, GLib.Date]: ...
    def get_date_index(self, tag: str, index: int) -> Tuple[bool, GLib.Date]: ...
    def get_date_time(self, tag: str) -> Tuple[bool, DateTime]: ...
    def get_date_time_index(self, tag: str, index: int) -> Tuple[bool, DateTime]: ...
    def get_double(self, tag: str) -> Tuple[bool, float]: ...
    def get_double_index(self, tag: str, index: int) -> Tuple[bool, float]: ...
    def get_float(self, tag: str) -> Tuple[bool, float]: ...
    def get_float_index(self, tag: str, index: int) -> Tuple[bool, float]: ...
    def get_int(self, tag: str) -> Tuple[bool, int]: ...
    def get_int64(self, tag: str) -> Tuple[bool, int]: ...
    def get_int64_index(self, tag: str, index: int) -> Tuple[bool, int]: ...
    def get_int_index(self, tag: str, index: int) -> Tuple[bool, int]: ...
    def get_pointer(self, tag: str) -> Tuple[bool, None]: ...
    def get_pointer_index(self, tag: str, index: int) -> Tuple[bool, None]: ...
    def get_sample(self, tag: str) -> Tuple[bool, Sample]: ...
    def get_sample_index(self, tag: str, index: int) -> Tuple[bool, Sample]: ...
    def get_scope(self) -> TagScope: ...
    def get_string(self, tag: str) -> Tuple[bool, str]: ...
    def get_string_index(self, tag: str, index: int) -> Tuple[bool, str]: ...
    def get_tag_size(self, tag: str) -> int: ...
    def get_uint(self, tag: str) -> Tuple[bool, int]: ...
    def get_uint64(self, tag: str) -> Tuple[bool, int]: ...
    def get_uint64_index(self, tag: str, index: int) -> Tuple[bool, int]: ...
    def get_uint_index(self, tag: str, index: int) -> Tuple[bool, int]: ...
    def get_value_index(self, tag: str, index: int) -> Optional[Any]: ...
    def insert(self, from_: TagList, mode: TagMergeMode) -> None: ...
    def is_empty(self) -> bool: ...
    def is_equal(self, list2: TagList) -> bool: ...
    def merge(
        self, list2: Optional[TagList], mode: TagMergeMode
    ) -> Optional[TagList]: ...
    def n_tags(self) -> int: ...
    @classmethod
    def new_empty(cls) -> TagList: ...
    @classmethod
    def new_from_string(cls, str: str) -> Optional[TagList]: ...
    def nth_tag_name(self, index: int) -> str: ...
    def peek_string_index(self, tag: str, index: int) -> Tuple[bool, str]: ...
    def remove_tag(self, tag: str) -> None: ...
    def set_scope(self, scope: TagScope) -> None: ...
    def to_string(self) -> Optional[str]: ...

class TagSetter(GObject.GInterface):
    def add_tag_value(self, mode: TagMergeMode, tag: str, value: Any) -> None: ...
    def get_tag_list(self) -> Optional[TagList]: ...
    def get_tag_merge_mode(self) -> TagMergeMode: ...
    def merge_tags(self, list: TagList, mode: TagMergeMode) -> None: ...
    def reset_tags(self) -> None: ...
    def set_tag_merge_mode(self, mode: TagMergeMode) -> None: ...

class TagSetterInterface(GObject.GPointer):
    g_iface: GObject.TypeInterface = ...

class Task(Object):
    class Props:
        name: Optional[str]
        parent: Optional[Object]
    props: Props = ...
    object: Object = ...
    state: TaskState = ...
    cond: GLib.Cond = ...
    lock: GLib.RecMutex = ...
    func: Callable[..., None] = ...
    user_data: None = ...
    notify: Callable[[None], None] = ...
    running: bool = ...
    thread: GLib.Thread = ...
    priv: TaskPrivate = ...
    _gst_reserved: list[None] = ...
    def __init__(self, name: str = ..., parent: Object = ...): ...
    @staticmethod
    def cleanup_all() -> None: ...
    def get_pool(self) -> TaskPool: ...
    def get_state(self) -> TaskState: ...
    def join(self) -> bool: ...
    @classmethod
    def new(cls, func: Callable[..., None], *user_data: Any) -> Task: ...
    def pause(self) -> bool: ...
    def resume(self) -> bool: ...
    def set_enter_callback(
        self, enter_func: Callable[..., None], *user_data: Any
    ) -> None: ...
    def set_leave_callback(
        self, leave_func: Callable[..., None], *user_data: Any
    ) -> None: ...
    def set_lock(self, mutex: GLib.RecMutex) -> None: ...
    def set_pool(self, pool: TaskPool) -> None: ...
    def set_state(self, state: TaskState) -> bool: ...
    def start(self) -> bool: ...
    def stop(self) -> bool: ...

class TaskClass(GObject.GPointer):
    parent_class: ObjectClass = ...
    pool: TaskPool = ...
    _gst_reserved: list[None] = ...

class TaskPool(Object):
    class Props:
        name: Optional[str]
        parent: Optional[Object]
    props: Props = ...
    object: Object = ...
    pool: GLib.ThreadPool = ...
    _gst_reserved: list[None] = ...
    def __init__(self, name: str = ..., parent: Object = ...): ...
    def cleanup(self) -> None: ...
    def dispose_handle(self, id: None) -> None: ...
    def do_cleanup(self) -> None: ...
    def do_dispose_handle(self, id: None) -> None: ...
    def do_join(self, id: None) -> None: ...
    def do_prepare(self) -> None: ...
    def do_push(self, func: Callable[..., None], *user_data: Any) -> None: ...
    def join(self, id: None) -> None: ...
    @classmethod
    def new(cls) -> TaskPool: ...
    def prepare(self) -> None: ...
    def push(self, func: Callable[..., None], *user_data: Any) -> None: ...

class TaskPoolClass(GObject.GPointer):
    parent_class: ObjectClass = ...
    prepare: Callable[[TaskPool], None] = ...
    cleanup: Callable[[TaskPool], None] = ...
    push: Callable[..., None] = ...
    join: Callable[[TaskPool, None], None] = ...
    dispose_handle: Callable[[TaskPool, None], None] = ...
    _gst_reserved: list[None] = ...

class TaskPrivate(GObject.GPointer): ...

class TimedValue(GObject.GPointer):
    timestamp: int = ...
    value: float = ...

class Toc(GObject.GBoxed):
    def append_entry(self, entry: TocEntry) -> None: ...
    def dump(self) -> None: ...
    def find_entry(self, uid: str) -> Optional[TocEntry]: ...
    def get_entries(self) -> list[TocEntry]: ...
    def get_scope(self) -> TocScope: ...
    def get_tags(self) -> TagList: ...
    def merge_tags(self, tags: Optional[TagList], mode: TagMergeMode) -> None: ...
    @classmethod
    def new(cls, scope: TocScope) -> Toc: ...
    def set_tags(self, tags: Optional[TagList] = None) -> None: ...

class TocEntry(GObject.GBoxed):
    def append_sub_entry(self, subentry: TocEntry) -> None: ...
    def get_entry_type(self) -> TocEntryType: ...
    def get_loop(self) -> Tuple[bool, TocLoopType, int]: ...
    def get_parent(self) -> Optional[TocEntry]: ...
    def get_start_stop_times(self) -> Tuple[bool, int, int]: ...
    def get_sub_entries(self) -> list[TocEntry]: ...
    def get_tags(self) -> TagList: ...
    def get_toc(self) -> Toc: ...
    def get_uid(self) -> str: ...
    def is_alternative(self) -> bool: ...
    def is_sequence(self) -> bool: ...
    def merge_tags(self, tags: Optional[TagList], mode: TagMergeMode) -> None: ...
    @classmethod
    def new(cls, type: TocEntryType, uid: str) -> TocEntry: ...
    def set_loop(self, loop_type: TocLoopType, repeat_count: int) -> None: ...
    def set_start_stop_times(self, start: int, stop: int) -> None: ...
    def set_tags(self, tags: Optional[TagList] = None) -> None: ...

class TocSetter(GObject.GInterface):
    def get_toc(self) -> Optional[Toc]: ...
    def reset(self) -> None: ...
    def set_toc(self, toc: Optional[Toc] = None) -> None: ...

class TocSetterInterface(GObject.GPointer):
    g_iface: GObject.TypeInterface = ...

class Tracer(Object):
    class Props:
        params: str
        name: Optional[str]
        parent: Optional[Object]
    props: Props = ...
    parent: Object = ...
    priv: TracerPrivate = ...
    _gst_reserved: list[None] = ...
    def __init__(self, params: str = ..., name: str = ..., parent: Object = ...): ...
    @staticmethod
    def register(plugin: Optional[Plugin], name: str, type: Type) -> bool: ...

class TracerClass(GObject.GPointer):
    parent_class: ObjectClass = ...
    _gst_reserved: list[None] = ...

class TracerFactory(PluginFeature):
    class Props:
        name: Optional[str]
        parent: Optional[Object]
    props: Props = ...
    def __init__(self, name: str = ..., parent: Object = ...): ...
    @staticmethod
    def get_list() -> list[TracerFactory]: ...
    def get_tracer_type(self) -> Type: ...

class TracerFactoryClass(GObject.GPointer): ...
class TracerPrivate(GObject.GPointer): ...

class TracerRecord(Object):
    class Props:
        name: Optional[str]
        parent: Optional[Object]
    props: Props = ...
    def __init__(self, name: str = ..., parent: Object = ...): ...

class TracerRecordClass(GObject.GPointer): ...

class TypeFind(GObject.GPointer):
    peek: Callable[[None, int, int], int] = ...
    suggest: Callable[[None, int, Caps], None] = ...
    data: None = ...
    get_length: Callable[[None], int] = ...
    _gst_reserved: list[None] = ...
    def get_length(self) -> int: ...
    def peek(self, offset: int) -> Optional[bytes]: ...
    @staticmethod
    def register(
        plugin: Optional[Plugin],
        name: str,
        rank: int,
        func: Callable[..., None],
        extensions: Optional[str] = None,
        possible_caps: Optional[Caps] = None,
        *data: Any,
    ) -> bool: ...
    def suggest(self, probability: int, caps: Caps) -> None: ...
    def suggest_empty_simple(self, probability: int, media_type: str) -> None: ...

class TypeFindFactory(PluginFeature):
    class Props:
        name: Optional[str]
        parent: Optional[Object]
    props: Props = ...
    def __init__(self, name: str = ..., parent: Object = ...): ...
    def call_function(self, find: TypeFind) -> None: ...
    def get_caps(self) -> Optional[Caps]: ...
    def get_extensions(self) -> Optional[list[str]]: ...
    @staticmethod
    def get_list() -> list[TypeFindFactory]: ...
    def has_function(self) -> bool: ...

class TypeFindFactoryClass(GObject.GPointer): ...

class URIHandler(GObject.GInterface):
    def get_protocols(self) -> Optional[list[str]]: ...
    def get_uri(self) -> Optional[str]: ...
    def get_uri_type(self) -> URIType: ...
    def set_uri(self, uri: str) -> bool: ...

class URIHandlerInterface(GObject.GPointer):
    parent: GObject.TypeInterface = ...
    get_type: Callable[[Type], URIType] = ...
    get_protocols: Callable[[Type], list[str]] = ...
    get_uri: Callable[[URIHandler], Optional[str]] = ...
    set_uri: Callable[[URIHandler, str], bool] = ...

class Uri(GObject.GBoxed):
    def append_path(self, relative_path: str) -> bool: ...
    def append_path_segment(self, path_segment: str) -> bool: ...
    @staticmethod
    def construct(protocol: str, location: str) -> str: ...
    def equal(self, second: Uri) -> bool: ...
    @staticmethod
    def from_string(uri: str) -> Optional[Uri]: ...
    @staticmethod
    def from_string_escaped(uri: str) -> Optional[Uri]: ...
    def from_string_with_base(self, uri: str) -> Uri: ...
    def get_fragment(self) -> Optional[str]: ...
    def get_host(self) -> Optional[str]: ...
    @staticmethod
    def get_location(uri: str) -> Optional[str]: ...
    def get_media_fragment_table(self) -> Optional[dict[str, str]]: ...
    def get_path(self) -> Optional[str]: ...
    def get_path_segments(self) -> list[str]: ...
    def get_path_string(self) -> Optional[str]: ...
    def get_port(self) -> int: ...
    @staticmethod
    def get_protocol(uri: str) -> Optional[str]: ...
    def get_query_keys(self) -> list[str]: ...
    def get_query_string(self) -> Optional[str]: ...
    def get_query_table(self) -> Optional[dict[str, str]]: ...
    def get_query_value(self, query_key: str) -> Optional[str]: ...
    def get_scheme(self) -> Optional[str]: ...
    def get_userinfo(self) -> Optional[str]: ...
    @staticmethod
    def has_protocol(uri: str, protocol: str) -> bool: ...
    def is_normalized(self) -> bool: ...
    @staticmethod
    def is_valid(uri: str) -> bool: ...
    def is_writable(self) -> bool: ...
    def join(self, ref_uri: Optional[Uri] = None) -> Optional[Uri]: ...
    @staticmethod
    def join_strings(base_uri: str, ref_uri: str) -> str: ...
    def make_writable(self) -> Uri: ...
    @classmethod
    def new(
        cls,
        scheme: Optional[str],
        userinfo: Optional[str],
        host: Optional[str],
        port: int,
        path: Optional[str] = None,
        query: Optional[str] = None,
        fragment: Optional[str] = None,
    ) -> Uri: ...
    def new_with_base(
        self,
        scheme: Optional[str],
        userinfo: Optional[str],
        host: Optional[str],
        port: int,
        path: Optional[str] = None,
        query: Optional[str] = None,
        fragment: Optional[str] = None,
    ) -> Uri: ...
    def normalize(self) -> bool: ...
    @staticmethod
    def protocol_is_supported(type: URIType, protocol: str) -> bool: ...
    @staticmethod
    def protocol_is_valid(protocol: str) -> bool: ...
    def query_has_key(self, query_key: str) -> bool: ...
    def remove_query_key(self, query_key: str) -> bool: ...
    def set_fragment(self, fragment: Optional[str] = None) -> bool: ...
    def set_host(self, host: str) -> bool: ...
    def set_path(self, path: str) -> bool: ...
    def set_path_segments(self, path_segments: Optional[list[str]] = None) -> bool: ...
    def set_path_string(self, path: str) -> bool: ...
    def set_port(self, port: int) -> bool: ...
    def set_query_string(self, query: str) -> bool: ...
    def set_query_table(self, query_table: Optional[dict[str, str]] = None) -> bool: ...
    def set_query_value(
        self, query_key: str, query_value: Optional[str] = None
    ) -> bool: ...
    def set_scheme(self, scheme: str) -> bool: ...
    def set_userinfo(self, userinfo: str) -> bool: ...
    def to_string(self) -> str: ...

class ValueArray:
    @staticmethod
    def append_and_take_value(value: Any, append_value: Any) -> None: ...
    @staticmethod
    def append_value(value: Any, append_value: Any) -> None: ...
    @staticmethod
    def get_size(value: Any) -> int: ...
    @staticmethod
    def get_value(value: Any, index: int) -> Any: ...
    @staticmethod
    def init(value: Any, prealloc: int) -> Any: ...
    @staticmethod
    def prepend_value(value: Any, prepend_value: Any) -> None: ...

class ValueList:
    @staticmethod
    def append_and_take_value(value: Any, append_value: Any) -> None: ...
    @staticmethod
    def append_value(value: Any, append_value: Any) -> None: ...
    @staticmethod
    def concat(value1: Any, value2: Any) -> Any: ...
    @staticmethod
    def get_size(value: Any) -> int: ...
    @staticmethod
    def get_value(value: Any, index: int) -> Any: ...
    @staticmethod
    def init(value: Any, prealloc: int) -> Any: ...
    @staticmethod
    def merge(value1: Any, value2: Any) -> Any: ...
    @staticmethod
    def prepend_value(value: Any, prepend_value: Any) -> None: ...

class ValueTable(GObject.GPointer):
    type: Type = ...
    compare: Callable[[Any, Any], int] = ...
    serialize: Callable[[Any], str] = ...
    deserialize: Callable[[Any, str], bool] = ...
    deserialize_with_pspec: Callable[[Any, str, GObject.ParamSpec], bool] = ...
    _gst_reserved: list[None] = ...

class AllocatorFlags(GObject.GFlags):
    CUSTOM_ALLOC = 16
    LAST = 1048576

class BinFlags(GObject.GFlags):
    LAST = 524288
    NO_RESYNC = 16384
    STREAMS_AWARE = 32768

class BufferCopyFlags(GObject.GFlags):
    DEEP = 32
    FLAGS = 1
    MEMORY = 8
    MERGE = 16
    META = 4
    NONE = 0
    TIMESTAMPS = 2

class BufferFlags(GObject.GFlags):
    CORRUPTED = 256
    DECODE_ONLY = 32
    DELTA_UNIT = 8192
    DISCONT = 64
    DROPPABLE = 4096
    GAP = 2048
    HEADER = 1024
    LAST = 1048576
    LIVE = 16
    MARKER = 512
    NON_DROPPABLE = 65536
    RESYNC = 128
    SYNC_AFTER = 32768
    TAG_MEMORY = 16384

class BufferPoolAcquireFlags(GObject.GFlags):
    DISCONT = 4
    DONTWAIT = 2
    KEY_UNIT = 1
    LAST = 65536
    NONE = 0

class BusFlags(GObject.GFlags):
    FLAG_LAST = 32
    FLUSHING = 16

class CapsFlags(GObject.GFlags):
    ANY = 16

class ClockFlags(GObject.GFlags):
    CAN_DO_PERIODIC_ASYNC = 128
    CAN_DO_PERIODIC_SYNC = 64
    CAN_DO_SINGLE_ASYNC = 32
    CAN_DO_SINGLE_SYNC = 16
    CAN_SET_MASTER = 512
    CAN_SET_RESOLUTION = 256
    LAST = 4096
    NEEDS_STARTUP_SYNC = 1024

class DebugColorFlags(GObject.GFlags):
    BG_BLACK = 0
    BG_BLUE = 64
    BG_CYAN = 96
    BG_GREEN = 32
    BG_MAGENTA = 80
    BG_RED = 16
    BG_WHITE = 112
    BG_YELLOW = 48
    BOLD = 256
    FG_BLACK = 0
    FG_BLUE = 4
    FG_CYAN = 6
    FG_GREEN = 2
    FG_MAGENTA = 5
    FG_RED = 1
    FG_WHITE = 7
    FG_YELLOW = 3
    UNDERLINE = 512

class DebugGraphDetails(GObject.GFlags):
    ALL = 15
    CAPS_DETAILS = 2
    FULL_PARAMS = 16
    MEDIA_TYPE = 1
    NON_DEFAULT_PARAMS = 4
    STATES = 8
    VERBOSE = 4294967295

class ElementFlags(GObject.GFlags):
    INDEXABLE = 512
    LAST = 16384
    LOCKED_STATE = 16
    PROVIDE_CLOCK = 128
    REQUIRE_CLOCK = 256
    SINK = 32
    SOURCE = 64

class EventTypeFlags(GObject.GFlags):
    DOWNSTREAM = 2
    SERIALIZED = 4
    STICKY = 8
    STICKY_MULTI = 16
    UPSTREAM = 1

class GapFlags(GObject.GFlags):
    DATA = 1

class LockFlags(GObject.GFlags):
    EXCLUSIVE = 4
    LAST = 256
    READ = 1
    WRITE = 2

class MapFlags(GObject.GFlags):
    FLAG_LAST = 65536
    READ = 1
    WRITE = 2

class MemoryFlags(GObject.GFlags):
    LAST = 1048576
    NOT_MAPPABLE = 256
    NO_SHARE = 16
    PHYSICALLY_CONTIGUOUS = 128
    READONLY = 2
    ZERO_PADDED = 64
    ZERO_PREFIXED = 32

class MessageType(GObject.GFlags):
    ANY = 4294967295
    APPLICATION = 16384
    ASYNC_DONE = 2097152
    ASYNC_START = 1048576
    BUFFERING = 32
    CLOCK_LOST = 1024
    CLOCK_PROVIDE = 512
    DEVICE_ADDED = 2147483649
    DEVICE_CHANGED = 2147483655
    DEVICE_REMOVED = 2147483650
    DURATION_CHANGED = 262144
    ELEMENT = 32768
    EOS = 1
    ERROR = 2
    EXTENDED = 2147483648
    HAVE_CONTEXT = 1073741824
    INFO = 8
    INSTANT_RATE_REQUEST = 2147483656
    LATENCY = 524288
    NEED_CONTEXT = 536870912
    NEW_CLOCK = 2048
    PROGRESS = 33554432
    PROPERTY_NOTIFY = 2147483651
    QOS = 16777216
    REDIRECT = 2147483654
    REQUEST_STATE = 4194304
    RESET_TIME = 134217728
    SEGMENT_DONE = 131072
    SEGMENT_START = 65536
    STATE_CHANGED = 64
    STATE_DIRTY = 128
    STEP_DONE = 256
    STEP_START = 8388608
    STREAMS_SELECTED = 2147483653
    STREAM_COLLECTION = 2147483652
    STREAM_START = 268435456
    STREAM_STATUS = 8192
    STRUCTURE_CHANGE = 4096
    TAG = 16
    TOC = 67108864
    UNKNOWN = 0
    WARNING = 4
    @staticmethod
    def get_name(type: MessageType) -> str: ...
    @staticmethod
    def to_quark(type: MessageType) -> int: ...

class MetaFlags(GObject.GFlags):
    LAST = 65536
    LOCKED = 4
    NONE = 0
    POOLED = 2
    READONLY = 1

class MiniObjectFlags(GObject.GFlags):
    LAST = 16
    LOCKABLE = 1
    LOCK_READONLY = 2
    MAY_BE_LEAKED = 4

class ObjectFlags(GObject.GFlags):
    LAST = 16
    MAY_BE_LEAKED = 1

class PadFlags(GObject.GFlags):
    ACCEPT_INTERSECT = 32768
    ACCEPT_TEMPLATE = 65536
    BLOCKED = 16
    BLOCKING = 128
    EOS = 64
    FIXED_CAPS = 2048
    FLUSHING = 32
    LAST = 1048576
    NEED_PARENT = 256
    NEED_RECONFIGURE = 512
    PENDING_EVENTS = 1024
    PROXY_ALLOCATION = 8192
    PROXY_CAPS = 4096
    PROXY_SCHEDULING = 16384

class PadLinkCheck(GObject.GFlags):
    CAPS = 4
    DEFAULT = 5
    HIERARCHY = 1
    NOTHING = 0
    NO_RECONFIGURE = 8
    TEMPLATE_CAPS = 2

class PadProbeType(GObject.GFlags):
    ALL_BOTH = 1776
    BLOCK = 2
    BLOCKING = 3
    BLOCK_DOWNSTREAM = 114
    BLOCK_UPSTREAM = 130
    BUFFER = 16
    BUFFER_LIST = 32
    DATA_BOTH = 240
    DATA_DOWNSTREAM = 112
    DATA_UPSTREAM = 128
    EVENT_BOTH = 192
    EVENT_DOWNSTREAM = 64
    EVENT_FLUSH = 256
    EVENT_UPSTREAM = 128
    IDLE = 1
    INVALID = 0
    PULL = 8192
    PUSH = 4096
    QUERY_BOTH = 1536
    QUERY_DOWNSTREAM = 512
    QUERY_UPSTREAM = 1024
    SCHEDULING = 12288

class PadTemplateFlags(GObject.GFlags):
    LAST = 256

class ParseFlags(GObject.GFlags):
    FATAL_ERRORS = 1
    NONE = 0
    NO_SINGLE_ELEMENT_BINS = 2
    PLACE_IN_BIN = 4

class PipelineFlags(GObject.GFlags):
    FIXED_CLOCK = 524288
    LAST = 8388608

class PluginAPIFlags(GObject.GFlags):
    MEMBERS = 1

class PluginDependencyFlags(GObject.GFlags):
    FILE_NAME_IS_PREFIX = 8
    FILE_NAME_IS_SUFFIX = 4
    NONE = 0
    PATHS_ARE_DEFAULT_ONLY = 2
    PATHS_ARE_RELATIVE_TO_EXE = 16
    RECURSE = 1

class PluginFlags(GObject.GFlags):
    BLACKLISTED = 32
    CACHED = 16

class QueryTypeFlags(GObject.GFlags):
    DOWNSTREAM = 2
    SERIALIZED = 4
    UPSTREAM = 1

class SchedulingFlags(GObject.GFlags):
    BANDWIDTH_LIMITED = 4
    SEEKABLE = 1
    SEQUENTIAL = 2

class SeekFlags(GObject.GFlags):
    ACCURATE = 2
    FLUSH = 1
    INSTANT_RATE_CHANGE = 1024
    KEY_UNIT = 4
    NONE = 0
    SEGMENT = 8
    SKIP = 16
    SNAP_AFTER = 64
    SNAP_BEFORE = 32
    SNAP_NEAREST = 96
    TRICKMODE = 16
    TRICKMODE_FORWARD_PREDICTED = 512
    TRICKMODE_KEY_UNITS = 128
    TRICKMODE_NO_AUDIO = 256

class SegmentFlags(GObject.GFlags):
    NONE = 0
    RESET = 1
    SEGMENT = 8
    SKIP = 16
    TRICKMODE = 16
    TRICKMODE_FORWARD_PREDICTED = 512
    TRICKMODE_KEY_UNITS = 128
    TRICKMODE_NO_AUDIO = 256

class SerializeFlags(GObject.GFlags):
    BACKWARD_COMPAT = 1
    NONE = 0

class StackTraceFlags(GObject.GFlags):
    FULL = 1
    NONE = 0

class StreamFlags(GObject.GFlags):
    NONE = 0
    SELECT = 2
    SPARSE = 1
    UNSELECT = 4

class StreamType(GObject.GFlags):
    AUDIO = 2
    CONTAINER = 8
    TEXT = 16
    UNKNOWN = 1
    VIDEO = 4
    @staticmethod
    def get_name(stype: StreamType) -> str: ...

class TracerValueFlags(GObject.GFlags):
    AGGREGATED = 2
    NONE = 0
    OPTIONAL = 1

class BufferingMode(GObject.GEnum):
    DOWNLOAD = 1
    LIVE = 3
    STREAM = 0
    TIMESHIFT = 2

class BusSyncReply(GObject.GEnum):
    ASYNC = 2
    DROP = 0
    PASS = 1

class CapsIntersectMode(GObject.GEnum):
    FIRST = 1
    ZIG_ZAG = 0

class ClockEntryType(GObject.GEnum):
    PERIODIC = 1
    SINGLE = 0

class ClockReturn(GObject.GEnum):
    BADTIME = 4
    BUSY = 3
    DONE = 7
    EARLY = 1
    ERROR = 5
    OK = 0
    UNSCHEDULED = 2
    UNSUPPORTED = 6

class ClockType(GObject.GEnum):
    MONOTONIC = 1
    OTHER = 2
    REALTIME = 0
    TAI = 3

class CoreError(GObject.GEnum):
    CAPS = 10
    CLOCK = 13
    DISABLED = 14
    EVENT = 8
    FAILED = 1
    MISSING_PLUGIN = 12
    NEGOTIATION = 7
    NOT_IMPLEMENTED = 3
    NUM_ERRORS = 15
    PAD = 5
    SEEK = 9
    STATE_CHANGE = 4
    TAG = 11
    THREAD = 6
    TOO_LAZY = 2
    @staticmethod
    def quark() -> int: ...

class DebugColorMode(GObject.GEnum):
    OFF = 0
    ON = 1
    UNIX = 2

class DebugLevel(GObject.GEnum):
    COUNT = 10
    DEBUG = 5
    ERROR = 1
    FIXME = 3
    INFO = 4
    LOG = 6
    MEMDUMP = 9
    NONE = 0
    TRACE = 7
    WARNING = 2
    @staticmethod
    def get_name(level: DebugLevel) -> str: ...

class EventType(GObject.GEnum):
    BUFFERSIZE = 23054
    CAPS = 12814
    CUSTOM_BOTH = 79367
    CUSTOM_BOTH_OOB = 81923
    CUSTOM_DOWNSTREAM = 71686
    CUSTOM_DOWNSTREAM_OOB = 74242
    CUSTOM_DOWNSTREAM_STICKY = 76830
    CUSTOM_UPSTREAM = 69121
    EOS = 28174
    FLUSH_START = 2563
    FLUSH_STOP = 5127
    GAP = 40966
    INSTANT_RATE_CHANGE = 46090
    INSTANT_RATE_SYNC_TIME = 66817
    LATENCY = 56321
    NAVIGATION = 53761
    PROTECTION = 33310
    QOS = 48641
    RECONFIGURE = 61441
    SEEK = 51201
    SEGMENT = 17934
    SEGMENT_DONE = 38406
    SELECT_STREAMS = 66561
    SINK_MESSAGE = 25630
    STEP = 58881
    STREAM_COLLECTION = 19230
    STREAM_GROUP_DONE = 26894
    STREAM_START = 10254
    TAG = 20510
    TOC = 30750
    TOC_SELECT = 64001
    UNKNOWN = 0
    @staticmethod
    def get_flags(type: EventType) -> EventTypeFlags: ...
    @staticmethod
    def get_name(type: EventType) -> str: ...
    @staticmethod
    def to_quark(type: EventType) -> int: ...

class FlowReturn(GObject.GEnum):
    CUSTOM_ERROR = -100
    CUSTOM_ERROR_1 = -101
    CUSTOM_ERROR_2 = -102
    CUSTOM_SUCCESS = 100
    CUSTOM_SUCCESS_1 = 101
    CUSTOM_SUCCESS_2 = 102
    EOS = -3
    ERROR = -5
    FLUSHING = -2
    NOT_LINKED = -1
    NOT_NEGOTIATED = -4
    NOT_SUPPORTED = -6
    OK = 0

class Format(GObject.GEnum):
    BUFFERS = 4
    BYTES = 2
    DEFAULT = 1
    PERCENT = 5
    TIME = 3
    UNDEFINED = 0
    @staticmethod
    def get_by_nick(nick: str) -> Format: ...
    @staticmethod
    def get_details(format: Format) -> Optional[FormatDefinition]: ...
    @staticmethod
    def get_name(format: Format) -> Optional[str]: ...
    @staticmethod
    def iterate_definitions() -> Iterator: ...
    @staticmethod
    def register(nick: str, description: str) -> Format: ...
    @staticmethod
    def to_quark(format: Format) -> int: ...

class IteratorItem(GObject.GEnum):
    END = 2
    PASS = 1
    SKIP = 0

class IteratorResult(GObject.GEnum):
    DONE = 0
    ERROR = 3
    OK = 1
    RESYNC = 2

class LibraryError(GObject.GEnum):
    ENCODE = 6
    FAILED = 1
    INIT = 3
    NUM_ERRORS = 7
    SETTINGS = 5
    SHUTDOWN = 4
    TOO_LAZY = 2
    @staticmethod
    def quark() -> int: ...

class PadDirection(GObject.GEnum):
    SINK = 2
    SRC = 1
    UNKNOWN = 0

class PadLinkReturn(GObject.GEnum):
    NOFORMAT = -4
    NOSCHED = -5
    OK = 0
    REFUSED = -6
    WAS_LINKED = -2
    WRONG_DIRECTION = -3
    WRONG_HIERARCHY = -1

class PadMode(GObject.GEnum):
    NONE = 0
    PULL = 2
    PUSH = 1
    @staticmethod
    def get_name(mode: PadMode) -> str: ...

class PadPresence(GObject.GEnum):
    ALWAYS = 0
    REQUEST = 2
    SOMETIMES = 1

class PadProbeReturn(GObject.GEnum):
    DROP = 0
    HANDLED = 4
    OK = 1
    PASS = 3
    REMOVE = 2

class ParseError(GObject.GEnum):
    COULD_NOT_SET_PROPERTY = 4
    DELAYED_LINK = 7
    EMPTY = 6
    EMPTY_BIN = 5
    LINK = 3
    NO_SUCH_ELEMENT = 1
    NO_SUCH_PROPERTY = 2
    SYNTAX = 0
    @staticmethod
    def quark() -> int: ...

class PluginError(GObject.GEnum):
    DEPENDENCIES = 1
    MODULE = 0
    NAME_MISMATCH = 2
    @staticmethod
    def quark() -> int: ...

class ProgressType(GObject.GEnum):
    CANCELED = 3
    COMPLETE = 2
    CONTINUE = 1
    ERROR = 4
    START = 0

class PromiseResult(GObject.GEnum):
    EXPIRED = 3
    INTERRUPTED = 1
    PENDING = 0
    REPLIED = 2

class QOSType(GObject.GEnum):
    OVERFLOW = 0
    THROTTLE = 2
    UNDERFLOW = 1

class QueryType(GObject.GEnum):
    ACCEPT_CAPS = 40963
    ALLOCATION = 35846
    BITRATE = 51202
    BUFFERING = 28163
    CAPS = 43523
    CONTEXT = 48643
    CONVERT = 20483
    CUSTOM = 30723
    DRAIN = 46086
    DURATION = 5123
    FORMATS = 23043
    JITTER = 10243
    LATENCY = 7683
    POSITION = 2563
    RATE = 12803
    SCHEDULING = 38401
    SEEKING = 15363
    SEGMENT = 17923
    UNKNOWN = 0
    URI = 33283
    @staticmethod
    def get_flags(type: QueryType) -> QueryTypeFlags: ...
    @staticmethod
    def get_name(type: QueryType) -> str: ...
    @staticmethod
    def to_quark(type: QueryType) -> int: ...

class Rank(GObject.GEnum):
    MARGINAL = 64
    NONE = 0
    PRIMARY = 256
    SECONDARY = 128

class ResourceError(GObject.GEnum):
    BUSY = 4
    CLOSE = 8
    FAILED = 1
    NOT_AUTHORIZED = 15
    NOT_FOUND = 3
    NO_SPACE_LEFT = 14
    NUM_ERRORS = 16
    OPEN_READ = 5
    OPEN_READ_WRITE = 7
    OPEN_WRITE = 6
    READ = 9
    SEEK = 11
    SETTINGS = 13
    SYNC = 12
    TOO_LAZY = 2
    WRITE = 10
    @staticmethod
    def quark() -> int: ...

class SearchMode(GObject.GEnum):
    AFTER = 2
    BEFORE = 1
    EXACT = 0

class SeekType(GObject.GEnum):
    END = 2
    NONE = 0
    SET = 1

class State(GObject.GEnum):
    NULL = 1
    PAUSED = 3
    PLAYING = 4
    READY = 2
    VOID_PENDING = 0

class StateChange(GObject.GEnum):
    NULL_TO_NULL = 9
    NULL_TO_READY = 10
    PAUSED_TO_PAUSED = 27
    PAUSED_TO_PLAYING = 28
    PAUSED_TO_READY = 26
    PLAYING_TO_PAUSED = 35
    PLAYING_TO_PLAYING = 36
    READY_TO_NULL = 17
    READY_TO_PAUSED = 19
    READY_TO_READY = 18
    @staticmethod
    def get_name(transition: StateChange) -> str: ...

class StateChangeReturn(GObject.GEnum):
    ASYNC = 2
    FAILURE = 0
    NO_PREROLL = 3
    SUCCESS = 1

class StreamError(GObject.GEnum):
    CODEC_NOT_FOUND = 6
    DECODE = 7
    DECRYPT = 12
    DECRYPT_NOKEY = 13
    DEMUX = 9
    ENCODE = 8
    FAILED = 1
    FORMAT = 11
    MUX = 10
    NOT_IMPLEMENTED = 3
    NUM_ERRORS = 14
    TOO_LAZY = 2
    TYPE_NOT_FOUND = 4
    WRONG_TYPE = 5
    @staticmethod
    def quark() -> int: ...

class StreamStatusType(GObject.GEnum):
    CREATE = 0
    DESTROY = 3
    ENTER = 1
    LEAVE = 2
    PAUSE = 9
    START = 8
    STOP = 10

class StructureChangeType(GObject.GEnum):
    LINK = 0
    UNLINK = 1

class TagFlag(GObject.GEnum):
    COUNT = 4
    DECODED = 3
    ENCODED = 2
    META = 1
    UNDEFINED = 0

class TagMergeMode(GObject.GEnum):
    APPEND = 3
    COUNT = 7
    KEEP = 5
    KEEP_ALL = 6
    PREPEND = 4
    REPLACE = 2
    REPLACE_ALL = 1
    UNDEFINED = 0

class TagScope(GObject.GEnum):
    GLOBAL = 1
    STREAM = 0

class TaskState(GObject.GEnum):
    PAUSED = 2
    STARTED = 0
    STOPPED = 1

class TocEntryType(GObject.GEnum):
    ANGLE = -3
    CHAPTER = 3
    EDITION = -1
    INVALID = 0
    TITLE = 1
    TRACK = 2
    VERSION = -2
    @staticmethod
    def get_nick(type: TocEntryType) -> str: ...

class TocLoopType(GObject.GEnum):
    FORWARD = 1
    NONE = 0
    PING_PONG = 3
    REVERSE = 2

class TocScope(GObject.GEnum):
    CURRENT = 2
    GLOBAL = 1

class TracerValueScope(GObject.GEnum):
    ELEMENT = 2
    PAD = 3
    PROCESS = 0
    THREAD = 1

class TypeFindProbability(GObject.GEnum):
    LIKELY = 80
    MAXIMUM = 100
    MINIMUM = 1
    NEARLY_CERTAIN = 99
    NONE = 0
    POSSIBLE = 50

class URIError(GObject.GEnum):
    BAD_REFERENCE = 3
    BAD_STATE = 2
    BAD_URI = 1
    UNSUPPORTED_PROTOCOL = 0
    @staticmethod
    def quark() -> int: ...

class URIType(GObject.GEnum):
    SINK = 1
    SRC = 2
    UNKNOWN = 0
